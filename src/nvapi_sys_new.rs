#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]

/* automatically generated by rust-bindgen 0.60.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const NVAPI_DEFAULT_HANDLE: u32 = 0;
pub const NVAPI_GENERIC_STRING_MAX: u32 = 4096;
pub const NVAPI_LONG_STRING_MAX: u32 = 256;
pub const NVAPI_SHORT_STRING_MAX: u32 = 64;
pub const NVAPI_MAX_PHYSICAL_GPUS: u32 = 64;
pub const NVAPI_MAX_PHYSICAL_BRIDGES: u32 = 100;
pub const NVAPI_PHYSICAL_GPUS: u32 = 32;
pub const NVAPI_MAX_LOGICAL_GPUS: u32 = 64;
pub const NVAPI_MAX_AVAILABLE_GPU_TOPOLOGIES: u32 = 256;
pub const NVAPI_MAX_AVAILABLE_SLI_GROUPS: u32 = 256;
pub const NVAPI_MAX_GPU_TOPOLOGIES: u32 = 64;
pub const NVAPI_MAX_GPU_PER_TOPOLOGY: u32 = 8;
pub const NVAPI_MAX_DISPLAY_HEADS: u32 = 2;
pub const NVAPI_ADVANCED_DISPLAY_HEADS: u32 = 4;
pub const NVAPI_MAX_DISPLAYS: u32 = 128;
pub const NVAPI_MAX_ACPI_IDS: u32 = 16;
pub const NVAPI_MAX_VIEW_MODES: u32 = 8;
pub const NVAPI_SYSTEM_MAX_HWBCS: u32 = 128;
pub const NVAPI_SYSTEM_HWBC_INVALID_ID: u32 = 4294967295;
pub const NV_MAX_HEADS: u32 = 4;
pub const NVAPI_MAX_HEADS_PER_GPU: u32 = 32;
pub const NV_MAX_VID_STREAMS: u32 = 4;
pub const NV_MAX_VID_STREAMS_EX: u32 = 20;
pub const NV_MAX_VID_PROFILES: u32 = 4;
pub const NVAPI_MAX_AUDIO_DEVICES: u32 = 16;
pub const NV_MOSAIC_MAX_DISPLAYS: u32 = 64;
pub const NV_EDID_V1_DATA_SIZE: u32 = 256;
pub const NV_EDID_DATA_SIZE: u32 = 256;
pub const NVAPI_MAX_VIEW_TARGET: u32 = 2;
pub const NVAPI_ADVANCED_MAX_VIEW_TARGET: u32 = 4;
pub const NV_TIMING_H_SYNC_POSITIVE: u32 = 0;
pub const NV_TIMING_H_SYNC_NEGATIVE: u32 = 1;
pub const NV_TIMING_H_SYNC_DEFAULT: u32 = 1;
pub const NV_TIMING_V_SYNC_POSITIVE: u32 = 0;
pub const NV_TIMING_V_SYNC_NEGATIVE: u32 = 1;
pub const NV_TIMING_V_SYNC_DEFAULT: u32 = 0;
pub const NV_TIMING_PROGRESSIVE: u32 = 0;
pub const NV_TIMING_INTERLACED: u32 = 1;
pub const NV_TIMING_INTERLACED_EXTRA_VBLANK_ON_FIELD2: u32 = 1;
pub const NV_TIMING_INTERLACED_NO_EXTRA_VBLANK_ON_FIELD2: u32 = 2;
pub const NVAPI_MAX_DISPLAY_PATH: u32 = 2;
pub const NVAPI_ADVANCED_MAX_DISPLAY_PATH: u32 = 4;
pub const NVAPI_UNICODE_STRING_MAX: u32 = 2048;
pub const NVAPI_BINARY_DATA_MAX: u32 = 4096;
pub const NVAPI_MAX_GPU_CLOCKS: u32 = 32;
pub const NVAPI_MAX_GPU_PUBLIC_CLOCKS: u32 = 32;
pub const NVAPI_MAX_GPU_PERF_CLOCKS: u32 = 32;
pub const NVAPI_MAX_GPU_PERF_VOLTAGES: u32 = 16;
pub const NVAPI_MAX_GPU_PERF_PSTATES: u32 = 16;
pub const NVAPI_MAX_GPU_PSTATE20_PSTATES: u32 = 16;
pub const NVAPI_MAX_GPU_PSTATE20_CLOCKS: u32 = 8;
pub const NVAPI_MAX_GPU_PSTATE20_BASE_VOLTAGES: u32 = 4;
pub const NVAPI_OGLEXPERT_DETAIL_NONE: u32 = 0;
pub const NVAPI_OGLEXPERT_DETAIL_ERROR: u32 = 1;
pub const NVAPI_OGLEXPERT_DETAIL_SWFALLBACK: u32 = 2;
pub const NVAPI_OGLEXPERT_DETAIL_BASIC_INFO: u32 = 4;
pub const NVAPI_OGLEXPERT_DETAIL_DETAILED_INFO: u32 = 8;
pub const NVAPI_OGLEXPERT_DETAIL_PERFORMANCE_WARNING: u32 = 16;
pub const NVAPI_OGLEXPERT_DETAIL_QUALITY_WARNING: u32 = 32;
pub const NVAPI_OGLEXPERT_DETAIL_USAGE_WARNING: u32 = 64;
pub const NVAPI_OGLEXPERT_DETAIL_ALL: u32 = 4294967295;
pub const NVAPI_OGLEXPERT_REPORT_NONE: u32 = 0;
pub const NVAPI_OGLEXPERT_REPORT_ERROR: u32 = 1;
pub const NVAPI_OGLEXPERT_REPORT_SWFALLBACK: u32 = 2;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_VERTEX: u32 = 4;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_GEOMETRY: u32 = 8;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_XFB: u32 = 16;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_RASTER: u32 = 32;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_FRAGMENT: u32 = 64;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_ROP: u32 = 128;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_FRAMEBUFFER: u32 = 256;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_PIXEL: u32 = 512;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_TEXTURE: u32 = 1024;
pub const NVAPI_OGLEXPERT_REPORT_OBJECT_BUFFEROBJECT: u32 = 2048;
pub const NVAPI_OGLEXPERT_REPORT_OBJECT_TEXTURE: u32 = 4096;
pub const NVAPI_OGLEXPERT_REPORT_OBJECT_PROGRAM: u32 = 8192;
pub const NVAPI_OGLEXPERT_REPORT_OBJECT_FBO: u32 = 16384;
pub const NVAPI_OGLEXPERT_REPORT_FEATURE_SLI: u32 = 32768;
pub const NVAPI_OGLEXPERT_REPORT_ALL: u32 = 4294967295;
pub const NVAPI_OGLEXPERT_OUTPUT_TO_NONE: u32 = 0;
pub const NVAPI_OGLEXPERT_OUTPUT_TO_CONSOLE: u32 = 1;
pub const NVAPI_OGLEXPERT_OUTPUT_TO_DEBUGGER: u32 = 4;
pub const NVAPI_OGLEXPERT_OUTPUT_TO_CALLBACK: u32 = 8;
pub const NVAPI_OGLEXPERT_OUTPUT_TO_ALL: u32 = 4294967295;
pub const NVAPI_MAX_SIZEOF_I2C_DATA_BUFFER: u32 = 4096;
pub const NVAPI_MAX_SIZEOF_I2C_REG_ADDRESS: u32 = 4;
pub const NVAPI_DISPLAY_DEVICE_MASK_MAX: u32 = 24;
pub const NVAPI_I2C_SPEED_DEPRECATED: u32 = 65535;
pub const NV_LICENSE_MAX_COUNT: u32 = 3;
pub const NV_LICENSE_SIGNATURE_SIZE: u32 = 128;
pub const NV_LICENSE_INFO_MAX_LENGTH: u32 = 128;
pub const NVAPI_MAX_GPU_UTILIZATIONS: u32 = 8;
pub const NVAPI_MAX_THERMAL_SENSORS_PER_GPU: u32 = 3;
pub const NV_GPU_MAX_CLOCK_FREQUENCIES: u32 = 3;
pub const NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_COLOR_ENDPOINTS: u32 = 2;
pub const NV_GPU_CLIENT_ILLUM_DEVICE_NUM_DEVICES_MAX: u32 = 32;
pub const NV_GPU_CLIENT_ILLUM_ZONE_NUM_ZONES_MAX: u32 = 32;
pub const NVAPI_MAX_MOSAIC_DISPLAY_ROWS: u32 = 8;
pub const NVAPI_MAX_MOSAIC_DISPLAY_COLUMNS: u32 = 8;
pub const NV_MOSAIC_TOPO_VALIDITY_VALID: u32 = 0;
pub const NV_MOSAIC_TOPO_VALIDITY_MISSING_GPU: u32 = 1;
pub const NV_MOSAIC_TOPO_VALIDITY_MISSING_DISPLAY: u32 = 2;
pub const NV_MOSAIC_TOPO_VALIDITY_MIXED_DISPLAY_TYPES: u32 = 4;
pub const NV_MOSAIC_DISPLAY_SETTINGS_MAX: u32 = 40;
pub const NV_MOSAIC_TOPO_IDX_DEFAULT: u32 = 0;
pub const NV_MOSAIC_TOPO_IDX_LEFT_EYE: u32 = 0;
pub const NV_MOSAIC_TOPO_IDX_RIGHT_EYE: u32 = 1;
pub const NV_MOSAIC_TOPO_NUM_EYES: u32 = 2;
pub const NV_MOSAIC_MAX_TOPO_PER_TOPO_GROUP: u32 = 2;
pub const NVAPI_MAX_MOSAIC_TOPOS: u32 = 16;
pub const NVAPI_MAX_GSYNC_DEVICES: u32 = 4;
pub const NVAPI_GSYNC_BOARD_ID_P358: u32 = 856;
pub const NVAPI_GSYNC_BOARD_ID_P2060: u32 = 8288;
pub const NVAPI_GSYNC_BOARD_ID_P2061: u32 = 8289;
pub const NVAPI_MAX_RJ45_PER_GSYNC: u32 = 2;
pub const NV_MULTIVIEW_MAX_SUPPORTED_VIEWS: u32 = 4;
pub const NV_MODIFIED_W_MAX_VIEWPORTS: u32 = 16;
pub const NVVIOOWNERID_NONE: u32 = 0;
pub const NVVIO_O_READ: u32 = 0;
pub const NVVIO_O_WRITE_EXCLUSIVE: u32 = 65537;
pub const NVVIO_VALID_ACCESSRIGHTS: u32 = 65537;
pub const NVVIO_OWNERID_INITIALIZED: u32 = 2147483648;
pub const NVVIO_OWNERID_EXCLUSIVE: u32 = 1073741824;
pub const NVVIO_OWNERID_TYPEMASK: u32 = 268435455;
pub const NVAPI_MAX_VIO_DEVICES: u32 = 8;
pub const NVAPI_MAX_VIO_JACKS: u32 = 4;
pub const NVAPI_MAX_VIO_CHANNELS_PER_JACK: u32 = 2;
pub const NVAPI_MAX_VIO_STREAMS: u32 = 4;
pub const NVAPI_MIN_VIO_STREAMS: u32 = 1;
pub const NVAPI_MAX_VIO_LINKS_PER_STREAM: u32 = 2;
pub const NVAPI_MAX_FRAMELOCK_MAPPING_MODES: u32 = 20;
pub const NVAPI_GVI_MIN_RAW_CAPTURE_IMAGES: u32 = 1;
pub const NVAPI_GVI_MAX_RAW_CAPTURE_IMAGES: u32 = 32;
pub const NVAPI_GVI_DEFAULT_RAW_CAPTURE_IMAGES: u32 = 5;
pub const NVVIOCAPS_VIDOUT_SDI: u32 = 1;
pub const NVVIOCAPS_SYNC_INTERNAL: u32 = 256;
pub const NVVIOCAPS_SYNC_GENLOCK: u32 = 512;
pub const NVVIOCAPS_SYNCSRC_SDI: u32 = 4096;
pub const NVVIOCAPS_SYNCSRC_COMP: u32 = 8192;
pub const NVVIOCAPS_OUTPUTMODE_DESKTOP: u32 = 65536;
pub const NVVIOCAPS_OUTPUTMODE_OPENGL: u32 = 131072;
pub const NVVIOCAPS_VIDIN_SDI: u32 = 1048576;
pub const NVVIOCAPS_PACKED_ANC_SUPPORTED: u32 = 2097152;
pub const NVVIOCAPS_AUDIO_BLANKING_SUPPORTED: u32 = 4194304;
pub const NVVIOCLASS_SDI: u32 = 1;
pub const NVVIOBUFFERFORMAT_R8G8B8: u32 = 1;
pub const NVVIOBUFFERFORMAT_R8G8B8Z24: u32 = 2;
pub const NVVIOBUFFERFORMAT_R8G8B8A8: u32 = 4;
pub const NVVIOBUFFERFORMAT_R8G8B8A8Z24: u32 = 8;
pub const NVVIOBUFFERFORMAT_R16FPG16FPB16FP: u32 = 16;
pub const NVVIOBUFFERFORMAT_R16FPG16FPB16FPZ24: u32 = 32;
pub const NVVIOBUFFERFORMAT_R16FPG16FPB16FPA16FP: u32 = 64;
pub const NVVIOBUFFERFORMAT_R16FPG16FPB16FPA16FPZ24: u32 = 128;
pub const MAX_NUM_COMPOSITE_RANGE: u32 = 2;
pub const NVVIOCONFIG_SIGNALFORMAT: u32 = 1;
pub const NVVIOCONFIG_DATAFORMAT: u32 = 2;
pub const NVVIOCONFIG_OUTPUTREGION: u32 = 4;
pub const NVVIOCONFIG_OUTPUTAREA: u32 = 8;
pub const NVVIOCONFIG_COLORCONVERSION: u32 = 16;
pub const NVVIOCONFIG_GAMMACORRECTION: u32 = 32;
pub const NVVIOCONFIG_SYNCSOURCEENABLE: u32 = 64;
pub const NVVIOCONFIG_SYNCDELAY: u32 = 128;
pub const NVVIOCONFIG_COMPOSITESYNCTYPE: u32 = 256;
pub const NVVIOCONFIG_FRAMELOCKENABLE: u32 = 512;
pub const NVVIOCONFIG_422FILTER: u32 = 1024;
pub const NVVIOCONFIG_COMPOSITETERMINATE: u32 = 2048;
pub const NVVIOCONFIG_DATAINTEGRITYCHECK: u32 = 4096;
pub const NVVIOCONFIG_CSCOVERRIDE: u32 = 8192;
pub const NVVIOCONFIG_FLIPQUEUELENGTH: u32 = 16384;
pub const NVVIOCONFIG_ANCTIMECODEGENERATION: u32 = 32768;
pub const NVVIOCONFIG_COMPOSITE: u32 = 65536;
pub const NVVIOCONFIG_ALPHAKEYCOMPOSITE: u32 = 131072;
pub const NVVIOCONFIG_COMPOSITE_Y: u32 = 262144;
pub const NVVIOCONFIG_COMPOSITE_CR: u32 = 524288;
pub const NVVIOCONFIG_COMPOSITE_CB: u32 = 1048576;
pub const NVVIOCONFIG_FULL_COLOR_RANGE: u32 = 2097152;
pub const NVVIOCONFIG_RGB_DATA: u32 = 4194304;
pub const NVVIOCONFIG_RESERVED_SDIOUTPUTENABLE: u32 = 8388608;
pub const NVVIOCONFIG_STREAMS: u32 = 16777216;
pub const NVVIOCONFIG_ANC_PARITY_COMPUTATION: u32 = 33554432;
pub const NVVIOCONFIG_ANC_AUDIO_REPEAT: u32 = 67108864;
pub const NVVIOCONFIG_ALLFIELDS: u32 = 134217727;
pub const NVVIOCONFIG_VALIDFIELDS: u32 = 134217727;
pub const NVVIOCONFIG_DRIVERFIELDS: u32 = 16412;
pub const NVVIOCONFIG_GAMMAFIELDS: u32 = 32;
pub const NVVIOCONFIG_RMCTRLFIELDS: u32 = 2039619;
pub const NVVIOCONFIG_RMSKEWFIELDS: u32 = 128;
pub const NVVIOCONFIG_ALLOWSDIRUNNING_FIELDS: u32 = 35631232;
pub const NVVIOCONFIG_RMMODESET_FIELDS: u32 = 67109699;
pub const NVAPI_STEREO_QUADBUFFERED_API_VERSION: u32 = 2;
pub const NVAPI_SETTING_MAX_VALUES: u32 = 100;
pub const NV_GPU_CLIENT_UTIL_DOMAINS_MAX_V1: u32 = 4;
pub type size_t = ::std::os::raw::c_ulonglong;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type max_align_t = f64;
pub type NvU64 = ::std::os::raw::c_ulonglong;
pub type NvS64 = ::std::os::raw::c_longlong;
pub type NvS32 = ::std::os::raw::c_int;
pub type NvU32 = ::std::os::raw::c_ulong;
pub type temp_NvU32 = ::std::os::raw::c_ulong;
pub type NvS16 = ::std::os::raw::c_short;
pub type NvU16 = ::std::os::raw::c_ushort;
pub type NvU8 = ::std::os::raw::c_uchar;
pub type NvS8 = ::std::os::raw::c_schar;
pub type NvF32 = f32;
pub type NvBool = NvU8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_RECT {
    pub left: NvU32,
    pub top: NvU32,
    pub right: NvU32,
    pub bottom: NvU32,
}
#[test]
fn bindgen_test_layout__NV_RECT() {
    assert_eq!(
        ::std::mem::size_of::<_NV_RECT>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_RECT))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_RECT>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_RECT))
    );
    fn test_field_left() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_RECT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_RECT),
                "::",
                stringify!(left)
            )
        );
    }
    test_field_left();
    fn test_field_top() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_RECT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_RECT),
                "::",
                stringify!(top)
            )
        );
    }
    test_field_top();
    fn test_field_right() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_RECT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_RECT),
                "::",
                stringify!(right)
            )
        );
    }
    test_field_right();
    fn test_field_bottom() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_RECT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_RECT),
                "::",
                stringify!(bottom)
            )
        );
    }
    test_field_bottom();
}
pub type NV_RECT = _NV_RECT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NvLogicalGpuHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvLogicalGpuHandle__() {
    assert_eq!(
        ::std::mem::size_of::<NvLogicalGpuHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvLogicalGpuHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvLogicalGpuHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvLogicalGpuHandle__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvLogicalGpuHandle__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NvLogicalGpuHandle__),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type NvLogicalGpuHandle = *mut NvLogicalGpuHandle__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NvPhysicalGpuHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvPhysicalGpuHandle__() {
    assert_eq!(
        ::std::mem::size_of::<NvPhysicalGpuHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvPhysicalGpuHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvPhysicalGpuHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvPhysicalGpuHandle__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvPhysicalGpuHandle__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NvPhysicalGpuHandle__),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type NvPhysicalGpuHandle = *mut NvPhysicalGpuHandle__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NvDisplayHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvDisplayHandle__() {
    assert_eq!(
        ::std::mem::size_of::<NvDisplayHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvDisplayHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDisplayHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvDisplayHandle__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDisplayHandle__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDisplayHandle__),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type NvDisplayHandle = *mut NvDisplayHandle__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NvMonitorHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvMonitorHandle__() {
    assert_eq!(
        ::std::mem::size_of::<NvMonitorHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvMonitorHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvMonitorHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvMonitorHandle__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvMonitorHandle__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NvMonitorHandle__),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type NvMonitorHandle = *mut NvMonitorHandle__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NvUnAttachedDisplayHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvUnAttachedDisplayHandle__() {
    assert_eq!(
        ::std::mem::size_of::<NvUnAttachedDisplayHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvUnAttachedDisplayHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvUnAttachedDisplayHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvUnAttachedDisplayHandle__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvUnAttachedDisplayHandle__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NvUnAttachedDisplayHandle__),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type NvUnAttachedDisplayHandle = *mut NvUnAttachedDisplayHandle__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NvVisualComputingDeviceHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvVisualComputingDeviceHandle__() {
    assert_eq!(
        ::std::mem::size_of::<NvVisualComputingDeviceHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvVisualComputingDeviceHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvVisualComputingDeviceHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvVisualComputingDeviceHandle__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvVisualComputingDeviceHandle__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NvVisualComputingDeviceHandle__),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type NvVisualComputingDeviceHandle = *mut NvVisualComputingDeviceHandle__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NvEventHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvEventHandle__() {
    assert_eq!(
        ::std::mem::size_of::<NvEventHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvEventHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvEventHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvEventHandle__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvEventHandle__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NvEventHandle__),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type NvEventHandle = *mut NvEventHandle__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NvHICHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvHICHandle__() {
    assert_eq!(
        ::std::mem::size_of::<NvHICHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvHICHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvHICHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvHICHandle__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvHICHandle__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NvHICHandle__),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type NvHICHandle = *mut NvHICHandle__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NvGSyncDeviceHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvGSyncDeviceHandle__() {
    assert_eq!(
        ::std::mem::size_of::<NvGSyncDeviceHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvGSyncDeviceHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvGSyncDeviceHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvGSyncDeviceHandle__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvGSyncDeviceHandle__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NvGSyncDeviceHandle__),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type NvGSyncDeviceHandle = *mut NvGSyncDeviceHandle__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NvVioHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvVioHandle__() {
    assert_eq!(
        ::std::mem::size_of::<NvVioHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvVioHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvVioHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvVioHandle__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvVioHandle__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NvVioHandle__),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type NvVioHandle = *mut NvVioHandle__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NvTransitionHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvTransitionHandle__() {
    assert_eq!(
        ::std::mem::size_of::<NvTransitionHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvTransitionHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvTransitionHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvTransitionHandle__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvTransitionHandle__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NvTransitionHandle__),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type NvTransitionHandle = *mut NvTransitionHandle__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NvAudioHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvAudioHandle__() {
    assert_eq!(
        ::std::mem::size_of::<NvAudioHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvAudioHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvAudioHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvAudioHandle__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvAudioHandle__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NvAudioHandle__),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type NvAudioHandle = *mut NvAudioHandle__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Nv3DVPContextHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Nv3DVPContextHandle__() {
    assert_eq!(
        ::std::mem::size_of::<Nv3DVPContextHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(Nv3DVPContextHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<Nv3DVPContextHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(Nv3DVPContextHandle__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Nv3DVPContextHandle__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Nv3DVPContextHandle__),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type Nv3DVPContextHandle = *mut Nv3DVPContextHandle__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Nv3DVPTransceiverHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Nv3DVPTransceiverHandle__() {
    assert_eq!(
        ::std::mem::size_of::<Nv3DVPTransceiverHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(Nv3DVPTransceiverHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<Nv3DVPTransceiverHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(Nv3DVPTransceiverHandle__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Nv3DVPTransceiverHandle__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Nv3DVPTransceiverHandle__),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type Nv3DVPTransceiverHandle = *mut Nv3DVPTransceiverHandle__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Nv3DVPGlassesHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Nv3DVPGlassesHandle__() {
    assert_eq!(
        ::std::mem::size_of::<Nv3DVPGlassesHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(Nv3DVPGlassesHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<Nv3DVPGlassesHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(Nv3DVPGlassesHandle__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Nv3DVPGlassesHandle__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Nv3DVPGlassesHandle__),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type Nv3DVPGlassesHandle = *mut Nv3DVPGlassesHandle__;
pub type StereoHandle = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NvSourceHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvSourceHandle__() {
    assert_eq!(
        ::std::mem::size_of::<NvSourceHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvSourceHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvSourceHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvSourceHandle__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvSourceHandle__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NvSourceHandle__),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type NvSourceHandle = *mut NvSourceHandle__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NvTargetHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvTargetHandle__() {
    assert_eq!(
        ::std::mem::size_of::<NvTargetHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvTargetHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvTargetHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvTargetHandle__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvTargetHandle__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NvTargetHandle__),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type NvTargetHandle = *mut NvTargetHandle__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NVDX_SwapChainHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NVDX_SwapChainHandle__() {
    assert_eq!(
        ::std::mem::size_of::<NVDX_SwapChainHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NVDX_SwapChainHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NVDX_SwapChainHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NVDX_SwapChainHandle__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NVDX_SwapChainHandle__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NVDX_SwapChainHandle__),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type NVDX_SwapChainHandle = *mut NVDX_SwapChainHandle__;
extern "C" {
    pub static NVDX_SWAPCHAIN_NONE: NVDX_SwapChainHandle;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NvPresentBarrierClientHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvPresentBarrierClientHandle__() {
    assert_eq!(
        ::std::mem::size_of::<NvPresentBarrierClientHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvPresentBarrierClientHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvPresentBarrierClientHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvPresentBarrierClientHandle__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvPresentBarrierClientHandle__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NvPresentBarrierClientHandle__),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type NvPresentBarrierClientHandle = *mut NvPresentBarrierClientHandle__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NvSBox {
    pub sX: NvS32,
    pub sY: NvS32,
    pub sWidth: NvS32,
    pub sHeight: NvS32,
}
#[test]
fn bindgen_test_layout_NvSBox() {
    assert_eq!(
        ::std::mem::size_of::<NvSBox>(),
        16usize,
        concat!("Size of: ", stringify!(NvSBox))
    );
    assert_eq!(
        ::std::mem::align_of::<NvSBox>(),
        4usize,
        concat!("Alignment of ", stringify!(NvSBox))
    );
    fn test_field_sX() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvSBox>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sX) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NvSBox),
                "::",
                stringify!(sX)
            )
        );
    }
    test_field_sX();
    fn test_field_sY() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvSBox>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sY) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NvSBox),
                "::",
                stringify!(sY)
            )
        );
    }
    test_field_sY();
    fn test_field_sWidth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvSBox>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sWidth) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NvSBox),
                "::",
                stringify!(sWidth)
            )
        );
    }
    test_field_sWidth();
    fn test_field_sHeight() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvSBox>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sHeight) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NvSBox),
                "::",
                stringify!(sHeight)
            )
        );
    }
    test_field_sHeight();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NvGUID {
    pub data1: NvU32,
    pub data2: NvU16,
    pub data3: NvU16,
    pub data4: [NvU8; 8usize],
}
#[test]
fn bindgen_test_layout_NvGUID() {
    assert_eq!(
        ::std::mem::size_of::<NvGUID>(),
        16usize,
        concat!("Size of: ", stringify!(NvGUID))
    );
    assert_eq!(
        ::std::mem::align_of::<NvGUID>(),
        4usize,
        concat!("Alignment of ", stringify!(NvGUID))
    );
    fn test_field_data1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvGUID>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data1) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NvGUID),
                "::",
                stringify!(data1)
            )
        );
    }
    test_field_data1();
    fn test_field_data2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvGUID>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data2) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NvGUID),
                "::",
                stringify!(data2)
            )
        );
    }
    test_field_data2();
    fn test_field_data3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvGUID>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data3) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(NvGUID),
                "::",
                stringify!(data3)
            )
        );
    }
    test_field_data3();
    fn test_field_data4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvGUID>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data4) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NvGUID),
                "::",
                stringify!(data4)
            )
        );
    }
    test_field_data4();
}
pub type NvLUID = NvGUID;
pub type NvAPI_String = [::std::os::raw::c_char; 4096usize];
pub type NvAPI_LongString = [::std::os::raw::c_char; 256usize];
pub type NvAPI_ShortString = [::std::os::raw::c_char; 64usize];
pub type NvAPI_UnicodeShortString = [NvU16; 64usize];
#[doc = "!< Success. Request is completed."]
pub const _NvAPI_Status_NVAPI_OK: _NvAPI_Status = 0;
#[doc = "!< Generic error"]
pub const _NvAPI_Status_NVAPI_ERROR: _NvAPI_Status = -1;
#[doc = "!< NVAPI support library cannot be loaded."]
pub const _NvAPI_Status_NVAPI_LIBRARY_NOT_FOUND: _NvAPI_Status = -2;
#[doc = "!< not implemented in current driver installation"]
pub const _NvAPI_Status_NVAPI_NO_IMPLEMENTATION: _NvAPI_Status = -3;
#[doc = "!< NvAPI_Initialize has not been called (successfully)"]
pub const _NvAPI_Status_NVAPI_API_NOT_INITIALIZED: _NvAPI_Status = -4;
#[doc = "!< The argument/parameter value is not valid or NULL."]
pub const _NvAPI_Status_NVAPI_INVALID_ARGUMENT: _NvAPI_Status = -5;
#[doc = "!< No NVIDIA display driver, or NVIDIA GPU driving a display, was found."]
pub const _NvAPI_Status_NVAPI_NVIDIA_DEVICE_NOT_FOUND: _NvAPI_Status = -6;
#[doc = "!< No more items to enumerate"]
pub const _NvAPI_Status_NVAPI_END_ENUMERATION: _NvAPI_Status = -7;
#[doc = "!< Invalid handle"]
pub const _NvAPI_Status_NVAPI_INVALID_HANDLE: _NvAPI_Status = -8;
#[doc = "!< An argument's structure version is not supported"]
pub const _NvAPI_Status_NVAPI_INCOMPATIBLE_STRUCT_VERSION: _NvAPI_Status = -9;
#[doc = "!< The handle is no longer valid (likely due to GPU or display re-configuration)"]
pub const _NvAPI_Status_NVAPI_HANDLE_INVALIDATED: _NvAPI_Status = -10;
#[doc = "!< No NVIDIA OpenGL context is current (but needs to be)"]
pub const _NvAPI_Status_NVAPI_OPENGL_CONTEXT_NOT_CURRENT: _NvAPI_Status = -11;
#[doc = "!< An invalid pointer, usually NULL, was passed as a parameter"]
pub const _NvAPI_Status_NVAPI_INVALID_POINTER: _NvAPI_Status = -14;
#[doc = "!< OpenGL Expert is not supported by the current drivers"]
pub const _NvAPI_Status_NVAPI_NO_GL_EXPERT: _NvAPI_Status = -12;
#[doc = "!< OpenGL Expert is supported, but driver instrumentation is currently disabled"]
pub const _NvAPI_Status_NVAPI_INSTRUMENTATION_DISABLED: _NvAPI_Status = -13;
#[doc = "!< OpenGL does not support Nsight"]
pub const _NvAPI_Status_NVAPI_NO_GL_NSIGHT: _NvAPI_Status = -15;
#[doc = "!< Expected a logical GPU handle for one or more parameters"]
pub const _NvAPI_Status_NVAPI_EXPECTED_LOGICAL_GPU_HANDLE: _NvAPI_Status = -100;
#[doc = "!< Expected a physical GPU handle for one or more parameters"]
pub const _NvAPI_Status_NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: _NvAPI_Status = -101;
#[doc = "!< Expected an NV display handle for one or more parameters"]
pub const _NvAPI_Status_NVAPI_EXPECTED_DISPLAY_HANDLE: _NvAPI_Status = -102;
#[doc = "!< The combination of parameters is not valid."]
pub const _NvAPI_Status_NVAPI_INVALID_COMBINATION: _NvAPI_Status = -103;
#[doc = "!< Requested feature is not supported in the selected GPU"]
pub const _NvAPI_Status_NVAPI_NOT_SUPPORTED: _NvAPI_Status = -104;
#[doc = "!< No port ID was found for the I2C transaction"]
pub const _NvAPI_Status_NVAPI_PORTID_NOT_FOUND: _NvAPI_Status = -105;
#[doc = "!< Expected an unattached display handle as one of the input parameters."]
pub const _NvAPI_Status_NVAPI_EXPECTED_UNATTACHED_DISPLAY_HANDLE: _NvAPI_Status = -106;
#[doc = "!< Invalid perf level"]
pub const _NvAPI_Status_NVAPI_INVALID_PERF_LEVEL: _NvAPI_Status = -107;
#[doc = "!< Device is busy; request not fulfilled"]
pub const _NvAPI_Status_NVAPI_DEVICE_BUSY: _NvAPI_Status = -108;
#[doc = "!< NV persist file is not found"]
pub const _NvAPI_Status_NVAPI_NV_PERSIST_FILE_NOT_FOUND: _NvAPI_Status = -109;
#[doc = "!< NV persist data is not found"]
pub const _NvAPI_Status_NVAPI_PERSIST_DATA_NOT_FOUND: _NvAPI_Status = -110;
#[doc = "!< Expected a TV output display"]
pub const _NvAPI_Status_NVAPI_EXPECTED_TV_DISPLAY: _NvAPI_Status = -111;
#[doc = "!< Expected a TV output on the D Connector - HDTV_EIAJ4120."]
pub const _NvAPI_Status_NVAPI_EXPECTED_TV_DISPLAY_ON_DCONNECTOR: _NvAPI_Status = -112;
#[doc = "!< SLI is not active on this device."]
pub const _NvAPI_Status_NVAPI_NO_ACTIVE_SLI_TOPOLOGY: _NvAPI_Status = -113;
#[doc = "!< Setup of SLI rendering mode is not possible right now."]
pub const _NvAPI_Status_NVAPI_SLI_RENDERING_MODE_NOTALLOWED: _NvAPI_Status = -114;
#[doc = "!< Expected a digital flat panel."]
pub const _NvAPI_Status_NVAPI_EXPECTED_DIGITAL_FLAT_PANEL: _NvAPI_Status = -115;
#[doc = "!< Argument exceeds the expected size."]
pub const _NvAPI_Status_NVAPI_ARGUMENT_EXCEED_MAX_SIZE: _NvAPI_Status = -116;
#[doc = "!< Inhibit is ON due to one of the flags in NV_GPU_DISPLAY_CHANGE_INHIBIT or SLI active."]
pub const _NvAPI_Status_NVAPI_DEVICE_SWITCHING_NOT_ALLOWED: _NvAPI_Status = -117;
#[doc = "!< Testing of clocks is not supported."]
pub const _NvAPI_Status_NVAPI_TESTING_CLOCKS_NOT_SUPPORTED: _NvAPI_Status = -118;
#[doc = "!< The specified underscan config is from an unknown source (e.g. INF)"]
pub const _NvAPI_Status_NVAPI_UNKNOWN_UNDERSCAN_CONFIG: _NvAPI_Status = -119;
#[doc = "!< Timeout while reconfiguring GPUs"]
pub const _NvAPI_Status_NVAPI_TIMEOUT_RECONFIGURING_GPU_TOPO: _NvAPI_Status = -120;
#[doc = "!< Requested data was not found"]
pub const _NvAPI_Status_NVAPI_DATA_NOT_FOUND: _NvAPI_Status = -121;
#[doc = "!< Expected an analog display"]
pub const _NvAPI_Status_NVAPI_EXPECTED_ANALOG_DISPLAY: _NvAPI_Status = -122;
#[doc = "!< No SLI video bridge is present"]
pub const _NvAPI_Status_NVAPI_NO_VIDLINK: _NvAPI_Status = -123;
#[doc = "!< NVAPI requires a reboot for the settings to take effect"]
pub const _NvAPI_Status_NVAPI_REQUIRES_REBOOT: _NvAPI_Status = -124;
#[doc = "!< The function is not supported with the current Hybrid mode."]
pub const _NvAPI_Status_NVAPI_INVALID_HYBRID_MODE: _NvAPI_Status = -125;
#[doc = "!< The target types are not all the same"]
pub const _NvAPI_Status_NVAPI_MIXED_TARGET_TYPES: _NvAPI_Status = -126;
#[doc = "!< The function is not supported from 32-bit on a 64-bit system."]
pub const _NvAPI_Status_NVAPI_SYSWOW64_NOT_SUPPORTED: _NvAPI_Status = -127;
#[doc = "!< There is no implicit GPU topology active. Use NVAPI_SetHybridMode to change topology."]
pub const _NvAPI_Status_NVAPI_IMPLICIT_SET_GPU_TOPOLOGY_CHANGE_NOT_ALLOWED: _NvAPI_Status = -128;
#[doc = "!< Prompt the user to close all non-migratable applications."]
pub const _NvAPI_Status_NVAPI_REQUEST_USER_TO_CLOSE_NON_MIGRATABLE_APPS: _NvAPI_Status = -129;
#[doc = "!< Could not allocate sufficient memory to complete the call."]
pub const _NvAPI_Status_NVAPI_OUT_OF_MEMORY: _NvAPI_Status = -130;
#[doc = "!< The previous operation that is transferring information to or from this surface is incomplete."]
pub const _NvAPI_Status_NVAPI_WAS_STILL_DRAWING: _NvAPI_Status = -131;
#[doc = "!< The file was not found."]
pub const _NvAPI_Status_NVAPI_FILE_NOT_FOUND: _NvAPI_Status = -132;
#[doc = "!< There are too many unique instances of a particular type of state object."]
pub const _NvAPI_Status_NVAPI_TOO_MANY_UNIQUE_STATE_OBJECTS: _NvAPI_Status = -133;
#[doc = "!< The method call is invalid. For example, a method's parameter may not be a valid pointer."]
pub const _NvAPI_Status_NVAPI_INVALID_CALL: _NvAPI_Status = -134;
#[doc = "!< d3d10_1.dll cannot be loaded."]
pub const _NvAPI_Status_NVAPI_D3D10_1_LIBRARY_NOT_FOUND: _NvAPI_Status = -135;
#[doc = "!< Couldn't find the function in the loaded DLL."]
pub const _NvAPI_Status_NVAPI_FUNCTION_NOT_FOUND: _NvAPI_Status = -136;
#[doc = "!< The application will require Administrator privileges to access this API."]
#[doc = "!< The application can be elevated to a higher permission level by selecting \"Run as Administrator\"."]
pub const _NvAPI_Status_NVAPI_INVALID_USER_PRIVILEGE: _NvAPI_Status = -137;
#[doc = "!< The handle corresponds to GDIPrimary."]
pub const _NvAPI_Status_NVAPI_EXPECTED_NON_PRIMARY_DISPLAY_HANDLE: _NvAPI_Status = -138;
#[doc = "!< Setting Physx GPU requires that the GPU is compute-capable."]
pub const _NvAPI_Status_NVAPI_EXPECTED_COMPUTE_GPU_HANDLE: _NvAPI_Status = -139;
#[doc = "!< The Stereo part of NVAPI failed to initialize completely. Check if the stereo driver is installed."]
pub const _NvAPI_Status_NVAPI_STEREO_NOT_INITIALIZED: _NvAPI_Status = -140;
#[doc = "!< Access to stereo-related registry keys or values has failed."]
pub const _NvAPI_Status_NVAPI_STEREO_REGISTRY_ACCESS_FAILED: _NvAPI_Status = -141;
#[doc = "!< The given registry profile type is not supported."]
pub const _NvAPI_Status_NVAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED: _NvAPI_Status = -142;
#[doc = "!< The given registry value is not supported."]
pub const _NvAPI_Status_NVAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED: _NvAPI_Status = -143;
#[doc = "!< Stereo is not enabled and the function needed it to execute completely."]
pub const _NvAPI_Status_NVAPI_STEREO_NOT_ENABLED: _NvAPI_Status = -144;
#[doc = "!< Stereo is not turned on and the function needed it to execute completely."]
pub const _NvAPI_Status_NVAPI_STEREO_NOT_TURNED_ON: _NvAPI_Status = -145;
#[doc = "!< Invalid device interface."]
pub const _NvAPI_Status_NVAPI_STEREO_INVALID_DEVICE_INTERFACE: _NvAPI_Status = -146;
#[doc = "!< Separation percentage or JPEG image capture quality is out of [0-100] range."]
pub const _NvAPI_Status_NVAPI_STEREO_PARAMETER_OUT_OF_RANGE: _NvAPI_Status = -147;
#[doc = "!< The given frustum adjust mode is not supported."]
pub const _NvAPI_Status_NVAPI_STEREO_FRUSTUM_ADJUST_MODE_NOT_SUPPORTED: _NvAPI_Status = -148;
#[doc = "!< The mosaic topology is not possible given the current state of the hardware."]
pub const _NvAPI_Status_NVAPI_TOPO_NOT_POSSIBLE: _NvAPI_Status = -149;
#[doc = "!< An attempt to do a display resolution mode change has failed."]
pub const _NvAPI_Status_NVAPI_MODE_CHANGE_FAILED: _NvAPI_Status = -150;
#[doc = "!< d3d11.dll/d3d11_beta.dll cannot be loaded."]
pub const _NvAPI_Status_NVAPI_D3D11_LIBRARY_NOT_FOUND: _NvAPI_Status = -151;
#[doc = "!< Address is outside of valid range."]
pub const _NvAPI_Status_NVAPI_INVALID_ADDRESS: _NvAPI_Status = -152;
#[doc = "!< The pre-allocated string is too small to hold the result."]
pub const _NvAPI_Status_NVAPI_STRING_TOO_SMALL: _NvAPI_Status = -153;
#[doc = "!< The input does not match any of the available devices."]
pub const _NvAPI_Status_NVAPI_MATCHING_DEVICE_NOT_FOUND: _NvAPI_Status = -154;
#[doc = "!< Driver is running."]
pub const _NvAPI_Status_NVAPI_DRIVER_RUNNING: _NvAPI_Status = -155;
#[doc = "!< Driver is not running."]
pub const _NvAPI_Status_NVAPI_DRIVER_NOTRUNNING: _NvAPI_Status = -156;
#[doc = "!< A driver reload is required to apply these settings."]
pub const _NvAPI_Status_NVAPI_ERROR_DRIVER_RELOAD_REQUIRED: _NvAPI_Status = -157;
#[doc = "!< Intended setting is not allowed."]
pub const _NvAPI_Status_NVAPI_SET_NOT_ALLOWED: _NvAPI_Status = -158;
#[doc = "!< Information can't be returned due to \"advanced display topology\"."]
pub const _NvAPI_Status_NVAPI_ADVANCED_DISPLAY_TOPOLOGY_REQUIRED: _NvAPI_Status = -159;
#[doc = "!< Setting is not found."]
pub const _NvAPI_Status_NVAPI_SETTING_NOT_FOUND: _NvAPI_Status = -160;
#[doc = "!< Setting size is too large."]
pub const _NvAPI_Status_NVAPI_SETTING_SIZE_TOO_LARGE: _NvAPI_Status = -161;
#[doc = "!< There are too many settings for a profile."]
pub const _NvAPI_Status_NVAPI_TOO_MANY_SETTINGS_IN_PROFILE: _NvAPI_Status = -162;
#[doc = "!< Profile is not found."]
pub const _NvAPI_Status_NVAPI_PROFILE_NOT_FOUND: _NvAPI_Status = -163;
#[doc = "!< Profile name is duplicated."]
pub const _NvAPI_Status_NVAPI_PROFILE_NAME_IN_USE: _NvAPI_Status = -164;
#[doc = "!< Profile name is empty."]
pub const _NvAPI_Status_NVAPI_PROFILE_NAME_EMPTY: _NvAPI_Status = -165;
#[doc = "!< Application not found in the Profile."]
pub const _NvAPI_Status_NVAPI_EXECUTABLE_NOT_FOUND: _NvAPI_Status = -166;
#[doc = "!< Application already exists in the other profile."]
pub const _NvAPI_Status_NVAPI_EXECUTABLE_ALREADY_IN_USE: _NvAPI_Status = -167;
#[doc = "!< Data Type mismatch"]
pub const _NvAPI_Status_NVAPI_DATATYPE_MISMATCH: _NvAPI_Status = -168;
#[doc = "!< The profile passed as parameter has been removed and is no longer valid."]
pub const _NvAPI_Status_NVAPI_PROFILE_REMOVED: _NvAPI_Status = -169;
#[doc = "!< An unregistered resource was passed as a parameter."]
pub const _NvAPI_Status_NVAPI_UNREGISTERED_RESOURCE: _NvAPI_Status = -170;
#[doc = "!< The DisplayId corresponds to a display which is not within the normal outputId range."]
pub const _NvAPI_Status_NVAPI_ID_OUT_OF_RANGE: _NvAPI_Status = -171;
#[doc = "!< Display topology is not valid so the driver cannot do a mode set on this configuration."]
pub const _NvAPI_Status_NVAPI_DISPLAYCONFIG_VALIDATION_FAILED: _NvAPI_Status = -172;
#[doc = "!< Display Port Multi-Stream topology has been changed."]
pub const _NvAPI_Status_NVAPI_DPMST_CHANGED: _NvAPI_Status = -173;
#[doc = "!< Input buffer is insufficient to hold the contents."]
pub const _NvAPI_Status_NVAPI_INSUFFICIENT_BUFFER: _NvAPI_Status = -174;
#[doc = "!< No access to the caller."]
pub const _NvAPI_Status_NVAPI_ACCESS_DENIED: _NvAPI_Status = -175;
#[doc = "!< The requested action cannot be performed without Mosaic being enabled."]
pub const _NvAPI_Status_NVAPI_MOSAIC_NOT_ACTIVE: _NvAPI_Status = -176;
#[doc = "!< The surface is relocated away from video memory."]
pub const _NvAPI_Status_NVAPI_SHARE_RESOURCE_RELOCATED: _NvAPI_Status = -177;
#[doc = "!< The user should disable DWM before calling NvAPI."]
pub const _NvAPI_Status_NVAPI_REQUEST_USER_TO_DISABLE_DWM: _NvAPI_Status = -178;
#[doc = "!< D3D device status is D3DERR_DEVICELOST or D3DERR_DEVICENOTRESET - the user has to reset the device."]
pub const _NvAPI_Status_NVAPI_D3D_DEVICE_LOST: _NvAPI_Status = -179;
#[doc = "!< The requested action cannot be performed in the current state."]
pub const _NvAPI_Status_NVAPI_INVALID_CONFIGURATION: _NvAPI_Status = -180;
#[doc = "!< Call failed as stereo handshake not completed."]
pub const _NvAPI_Status_NVAPI_STEREO_HANDSHAKE_NOT_DONE: _NvAPI_Status = -181;
#[doc = "!< The path provided was too short to determine the correct NVDRS_APPLICATION"]
pub const _NvAPI_Status_NVAPI_EXECUTABLE_PATH_IS_AMBIGUOUS: _NvAPI_Status = -182;
#[doc = "!< Default stereo profile is not currently defined"]
pub const _NvAPI_Status_NVAPI_DEFAULT_STEREO_PROFILE_IS_NOT_DEFINED: _NvAPI_Status = -183;
#[doc = "!< Default stereo profile does not exist"]
pub const _NvAPI_Status_NVAPI_DEFAULT_STEREO_PROFILE_DOES_NOT_EXIST: _NvAPI_Status = -184;
#[doc = "!< A cluster is already defined with the given configuration."]
pub const _NvAPI_Status_NVAPI_CLUSTER_ALREADY_EXISTS: _NvAPI_Status = -185;
#[doc = "!< The input display id is not that of a multi stream enabled connector or a display device in a multi stream topology"]
pub const _NvAPI_Status_NVAPI_DPMST_DISPLAY_ID_EXPECTED: _NvAPI_Status = -186;
#[doc = "!< The input display id is not valid or the monitor associated to it does not support the current operation"]
pub const _NvAPI_Status_NVAPI_INVALID_DISPLAY_ID: _NvAPI_Status = -187;
#[doc = "!< While playing secure audio stream, stream goes out of sync"]
pub const _NvAPI_Status_NVAPI_STREAM_IS_OUT_OF_SYNC: _NvAPI_Status = -188;
#[doc = "!< Older audio driver version than required"]
pub const _NvAPI_Status_NVAPI_INCOMPATIBLE_AUDIO_DRIVER: _NvAPI_Status = -189;
#[doc = "!< Value already set, setting again not allowed."]
pub const _NvAPI_Status_NVAPI_VALUE_ALREADY_SET: _NvAPI_Status = -190;
#[doc = "!< Requested operation timed out"]
pub const _NvAPI_Status_NVAPI_TIMEOUT: _NvAPI_Status = -191;
#[doc = "!< The requested workstation feature set has incomplete driver internal allocation resources"]
pub const _NvAPI_Status_NVAPI_GPU_WORKSTATION_FEATURE_INCOMPLETE: _NvAPI_Status = -192;
#[doc = "!< Call failed because InitActivation was not called."]
pub const _NvAPI_Status_NVAPI_STEREO_INIT_ACTIVATION_NOT_DONE: _NvAPI_Status = -193;
#[doc = "!< The requested action cannot be performed without Sync being enabled."]
pub const _NvAPI_Status_NVAPI_SYNC_NOT_ACTIVE: _NvAPI_Status = -194;
#[doc = "!< The requested action cannot be performed without Sync Master being enabled."]
pub const _NvAPI_Status_NVAPI_SYNC_MASTER_NOT_FOUND: _NvAPI_Status = -195;
#[doc = "!< Invalid displays passed in the NV_GSYNC_DISPLAY pointer."]
pub const _NvAPI_Status_NVAPI_INVALID_SYNC_TOPOLOGY: _NvAPI_Status = -196;
#[doc = "!< The specified signing algorithm is not supported. Either an incorrect value was entered or the current installed driver/hardware does not support the input value."]
pub const _NvAPI_Status_NVAPI_ECID_SIGN_ALGO_UNSUPPORTED: _NvAPI_Status = -197;
#[doc = "!< The encrypted public key verification has failed."]
pub const _NvAPI_Status_NVAPI_ECID_KEY_VERIFICATION_FAILED: _NvAPI_Status = -198;
#[doc = "!< The device's firmware is out of date."]
pub const _NvAPI_Status_NVAPI_FIRMWARE_OUT_OF_DATE: _NvAPI_Status = -199;
#[doc = "!< The device's firmware is not supported."]
pub const _NvAPI_Status_NVAPI_FIRMWARE_REVISION_NOT_SUPPORTED: _NvAPI_Status = -200;
#[doc = "!< The caller is not authorized to modify the License."]
pub const _NvAPI_Status_NVAPI_LICENSE_CALLER_AUTHENTICATION_FAILED: _NvAPI_Status = -201;
#[doc = "!< The user tried to use a deferred context without registering the device first"]
pub const _NvAPI_Status_NVAPI_D3D_DEVICE_NOT_REGISTERED: _NvAPI_Status = -202;
#[doc = "!< Head or SourceId was not reserved for the VR Display before doing the Modeset or the dedicated display."]
pub const _NvAPI_Status_NVAPI_RESOURCE_NOT_ACQUIRED: _NvAPI_Status = -203;
#[doc = "!< Provided timing is not supported."]
pub const _NvAPI_Status_NVAPI_TIMING_NOT_SUPPORTED: _NvAPI_Status = -204;
#[doc = "!< HDCP Encryption Failed for the device. Would be applicable when the device is HDCP Capable."]
pub const _NvAPI_Status_NVAPI_HDCP_ENCRYPTION_FAILED: _NvAPI_Status = -205;
#[doc = "!< Provided mode is over sink device pclk limitation."]
pub const _NvAPI_Status_NVAPI_PCLK_LIMITATION_FAILED: _NvAPI_Status = -206;
#[doc = "!< No connector on GPU found."]
pub const _NvAPI_Status_NVAPI_NO_CONNECTOR_FOUND: _NvAPI_Status = -207;
#[doc = "!< When a non-HDCP capable HMD is connected, we would inform user by this code."]
pub const _NvAPI_Status_NVAPI_HDCP_DISABLED: _NvAPI_Status = -208;
#[doc = "!< Atleast an API is still being called"]
pub const _NvAPI_Status_NVAPI_API_IN_USE: _NvAPI_Status = -209;
#[doc = "!< No display found on Nvidia GPU(s)."]
pub const _NvAPI_Status_NVAPI_NVIDIA_DISPLAY_NOT_FOUND: _NvAPI_Status = -210;
#[doc = "!< Priv security violation, improper access to a secured register."]
pub const _NvAPI_Status_NVAPI_PRIV_SEC_VIOLATION: _NvAPI_Status = -211;
#[doc = "!< NVAPI cannot be called by this vendor"]
pub const _NvAPI_Status_NVAPI_INCORRECT_VENDOR: _NvAPI_Status = -212;
#[doc = "!< DirectMode Display is already in use"]
pub const _NvAPI_Status_NVAPI_DISPLAY_IN_USE: _NvAPI_Status = -213;
#[doc = "!< The Config is having Non-NVidia GPU with Non-HDCP HMD connected"]
pub const _NvAPI_Status_NVAPI_UNSUPPORTED_CONFIG_NON_HDCP_HMD: _NvAPI_Status = -214;
#[doc = "!< GPU's Max Display Limit has Reached"]
pub const _NvAPI_Status_NVAPI_MAX_DISPLAY_LIMIT_REACHED: _NvAPI_Status = -215;
#[doc = "!< DirectMode not Enabled on the Display"]
pub const _NvAPI_Status_NVAPI_INVALID_DIRECT_MODE_DISPLAY: _NvAPI_Status = -216;
#[doc = "!< GPU is in debug mode, OC is NOT allowed."]
pub const _NvAPI_Status_NVAPI_GPU_IN_DEBUG_MODE: _NvAPI_Status = -217;
#[doc = "!< No NvAPI context was found for this D3D object"]
pub const _NvAPI_Status_NVAPI_D3D_CONTEXT_NOT_FOUND: _NvAPI_Status = -218;
#[doc = "!< there is version mismatch between stereo driver and dx driver"]
pub const _NvAPI_Status_NVAPI_STEREO_VERSION_MISMATCH: _NvAPI_Status = -219;
#[doc = "!< GPU is not powered and so the request cannot be completed."]
pub const _NvAPI_Status_NVAPI_GPU_NOT_POWERED: _NvAPI_Status = -220;
#[doc = "!< The display driver update in progress."]
pub const _NvAPI_Status_NVAPI_ERROR_DRIVER_RELOAD_IN_PROGRESS: _NvAPI_Status = -221;
#[doc = "!< Wait for HW resources allocation"]
pub const _NvAPI_Status_NVAPI_WAIT_FOR_HW_RESOURCE: _NvAPI_Status = -222;
#[doc = "!< operation requires further HDCP action"]
pub const _NvAPI_Status_NVAPI_REQUIRE_FURTHER_HDCP_ACTION: _NvAPI_Status = -223;
#[doc = "!< Dynamic Mux transition failure"]
pub const _NvAPI_Status_NVAPI_DISPLAY_MUX_TRANSITION_FAILED: _NvAPI_Status = -224;
#[doc = "!< Invalid DSC version"]
pub const _NvAPI_Status_NVAPI_INVALID_DSC_VERSION: _NvAPI_Status = -225;
#[doc = "!< Invalid DSC slice count"]
pub const _NvAPI_Status_NVAPI_INVALID_DSC_SLICECOUNT: _NvAPI_Status = -226;
#[doc = "!< Invalid DSC output BPP"]
pub const _NvAPI_Status_NVAPI_INVALID_DSC_OUTPUT_BPP: _NvAPI_Status = -227;
#[doc = "!< There was an error while loading nvapi.dll from the driver store."]
pub const _NvAPI_Status_NVAPI_FAILED_TO_LOAD_FROM_DRIVER_STORE: _NvAPI_Status = -228;
#[doc = "!< OpenGL does not export Vulkan fake extensions"]
pub const _NvAPI_Status_NVAPI_NO_VULKAN: _NvAPI_Status = -229;
#[doc = "!< A request for NvTOPPs telemetry CData has already been made and is pending a response."]
pub const _NvAPI_Status_NVAPI_REQUEST_PENDING: _NvAPI_Status = -230;
#[doc = "!< Operation cannot be performed because the resource is in use."]
pub const _NvAPI_Status_NVAPI_RESOURCE_IN_USE: _NvAPI_Status = -231;
#[doc = "!< Device kernel image is invalid"]
pub const _NvAPI_Status_NVAPI_INVALID_IMAGE: _NvAPI_Status = -232;
#[doc = "!< PTX JIT compilation failed"]
pub const _NvAPI_Status_NVAPI_INVALID_PTX: _NvAPI_Status = -233;
#[doc = "!< Uncorrectable NVLink error was detected during the execution"]
pub const _NvAPI_Status_NVAPI_NVLINK_UNCORRECTABLE: _NvAPI_Status = -234;
#[doc = "!< PTX JIT compiler library was not found."]
pub const _NvAPI_Status_NVAPI_JIT_COMPILER_NOT_FOUND: _NvAPI_Status = -235;
#[doc = "!< Device kernel source is invalid."]
pub const _NvAPI_Status_NVAPI_INVALID_SOURCE: _NvAPI_Status = -236;
#[doc = "!< While executing a kernel, the device encountered an illegal instruction."]
pub const _NvAPI_Status_NVAPI_ILLEGAL_INSTRUCTION: _NvAPI_Status = -237;
#[doc = "!< While executing a kernel, the device program counter wrapped its address space"]
pub const _NvAPI_Status_NVAPI_INVALID_PC: _NvAPI_Status = -238;
#[doc = "!< An exception occurred on the device while executing a kernel"]
pub const _NvAPI_Status_NVAPI_LAUNCH_FAILED: _NvAPI_Status = -239;
#[doc = "!< Attempted operation is not permitted."]
pub const _NvAPI_Status_NVAPI_NOT_PERMITTED: _NvAPI_Status = -240;
#[doc = "! NvAPI Status Values"]
#[doc = "!   All NvAPI functions return one of these codes."]
#[doc = "!   \\ingroup nvapistatus"]
pub type _NvAPI_Status = ::std::os::raw::c_int;
#[doc = "! NvAPI Status Values"]
#[doc = "!   All NvAPI functions return one of these codes."]
#[doc = "!   \\ingroup nvapistatus"]
pub use self::_NvAPI_Status as NvAPI_Status;
extern "C" {
    #[doc = "!   DESCRIPTION: This API returns display driver version and driver-branch string."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [out]  pDriverVersion         Contains the driver version after successful return."]
    #[doc = "! \\param [out]  szBuildBranchString    Contains the driver-branch string after successful return."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT: either pDriverVersion is NULL or enum index too big"]
    #[doc = "! \\retval ::NVAPI_OK - completed request"]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized"]
    #[doc = "! \\retval ::NVAPI_ERROR - miscellaneous error occurred"]
    #[doc = "!"]
    #[doc = "! \\ingroup driverapi"]
    #[doc = ""]
    pub fn NvAPI_SYS_GetDriverAndBranchVersion(
        pDriverVersion: *mut NvU32,
        szBuildBranchString: *mut ::std::os::raw::c_char,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup driverapi"]
#[doc = "! Used in NvAPI_GPU_GetMemoryInfo()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_DISPLAY_DRIVER_MEMORY_INFO_V1 {
    #[doc = "!< Version info"]
    pub version: NvU32,
    #[doc = "!< Size(in kb) of the physical framebuffer."]
    pub dedicatedVideoMemory: NvU32,
    #[doc = "!< Size(in kb) of the available physical framebuffer for allocating video memory surfaces."]
    pub availableDedicatedVideoMemory: NvU32,
    #[doc = "!< Size(in kb) of system memory the driver allocates at load time."]
    pub systemVideoMemory: NvU32,
    #[doc = "!< Size(in kb) of shared system memory that driver is allowed to commit for surfaces across all allocations."]
    pub sharedSystemMemory: NvU32,
}
#[test]
fn bindgen_test_layout_NV_DISPLAY_DRIVER_MEMORY_INFO_V1() {
    assert_eq!(
        ::std::mem::size_of::<NV_DISPLAY_DRIVER_MEMORY_INFO_V1>(),
        20usize,
        concat!("Size of: ", stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_DISPLAY_DRIVER_MEMORY_INFO_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V1)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_MEMORY_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_dedicatedVideoMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_MEMORY_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dedicatedVideoMemory) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V1),
                "::",
                stringify!(dedicatedVideoMemory)
            )
        );
    }
    test_field_dedicatedVideoMemory();
    fn test_field_availableDedicatedVideoMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_MEMORY_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).availableDedicatedVideoMemory) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V1),
                "::",
                stringify!(availableDedicatedVideoMemory)
            )
        );
    }
    test_field_availableDedicatedVideoMemory();
    fn test_field_systemVideoMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_MEMORY_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).systemVideoMemory) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V1),
                "::",
                stringify!(systemVideoMemory)
            )
        );
    }
    test_field_systemVideoMemory();
    fn test_field_sharedSystemMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_MEMORY_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedSystemMemory) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V1),
                "::",
                stringify!(sharedSystemMemory)
            )
        );
    }
    test_field_sharedSystemMemory();
}
#[doc = "! \\ingroup driverapi"]
#[doc = "! Used in NvAPI_GPU_GetMemoryInfo()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_DISPLAY_DRIVER_MEMORY_INFO_V2 {
    #[doc = "!< Version info"]
    pub version: NvU32,
    #[doc = "!< Size(in kb) of the physical framebuffer."]
    pub dedicatedVideoMemory: NvU32,
    #[doc = "!< Size(in kb) of the available physical framebuffer for allocating video memory surfaces."]
    pub availableDedicatedVideoMemory: NvU32,
    #[doc = "!< Size(in kb) of system memory the driver allocates at load time."]
    pub systemVideoMemory: NvU32,
    #[doc = "!< Size(in kb) of shared system memory that driver is allowed to commit for surfaces across all allocations."]
    pub sharedSystemMemory: NvU32,
    #[doc = "!< Size(in kb) of the current available physical framebuffer for allocating video memory surfaces."]
    pub curAvailableDedicatedVideoMemory: NvU32,
}
#[test]
fn bindgen_test_layout_NV_DISPLAY_DRIVER_MEMORY_INFO_V2() {
    assert_eq!(
        ::std::mem::size_of::<NV_DISPLAY_DRIVER_MEMORY_INFO_V2>(),
        24usize,
        concat!("Size of: ", stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_DISPLAY_DRIVER_MEMORY_INFO_V2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V2)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_MEMORY_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_dedicatedVideoMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_MEMORY_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dedicatedVideoMemory) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V2),
                "::",
                stringify!(dedicatedVideoMemory)
            )
        );
    }
    test_field_dedicatedVideoMemory();
    fn test_field_availableDedicatedVideoMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_MEMORY_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).availableDedicatedVideoMemory) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V2),
                "::",
                stringify!(availableDedicatedVideoMemory)
            )
        );
    }
    test_field_availableDedicatedVideoMemory();
    fn test_field_systemVideoMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_MEMORY_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).systemVideoMemory) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V2),
                "::",
                stringify!(systemVideoMemory)
            )
        );
    }
    test_field_systemVideoMemory();
    fn test_field_sharedSystemMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_MEMORY_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedSystemMemory) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V2),
                "::",
                stringify!(sharedSystemMemory)
            )
        );
    }
    test_field_sharedSystemMemory();
    fn test_field_curAvailableDedicatedVideoMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_MEMORY_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).curAvailableDedicatedVideoMemory) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V2),
                "::",
                stringify!(curAvailableDedicatedVideoMemory)
            )
        );
    }
    test_field_curAvailableDedicatedVideoMemory();
}
#[doc = "! \\ingroup driverapi"]
#[doc = "! Used in NvAPI_GPU_GetMemoryInfo()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_DISPLAY_DRIVER_MEMORY_INFO_V3 {
    #[doc = "!< Version info"]
    pub version: NvU32,
    #[doc = "!< Size(in kb) of the physical framebuffer."]
    pub dedicatedVideoMemory: NvU32,
    #[doc = "!< Size(in kb) of the available physical framebuffer for allocating video memory surfaces."]
    pub availableDedicatedVideoMemory: NvU32,
    #[doc = "!< Size(in kb) of system memory the driver allocates at load time."]
    pub systemVideoMemory: NvU32,
    #[doc = "!< Size(in kb) of shared system memory that driver is allowed to commit for surfaces across all allocations."]
    pub sharedSystemMemory: NvU32,
    #[doc = "!< Size(in kb) of the current available physical framebuffer for allocating video memory surfaces."]
    pub curAvailableDedicatedVideoMemory: NvU32,
    #[doc = "!< Size(in kb) of the total size of memory released as a result of the evictions."]
    pub dedicatedVideoMemoryEvictionsSize: NvU32,
    #[doc = "!< Indicates the number of eviction events that caused an allocation to be removed from dedicated video memory to free GPU"]
    #[doc = "!< video memory to make room for other allocations."]
    pub dedicatedVideoMemoryEvictionCount: NvU32,
}
#[test]
fn bindgen_test_layout_NV_DISPLAY_DRIVER_MEMORY_INFO_V3() {
    assert_eq!(
        ::std::mem::size_of::<NV_DISPLAY_DRIVER_MEMORY_INFO_V3>(),
        32usize,
        concat!("Size of: ", stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_DISPLAY_DRIVER_MEMORY_INFO_V3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V3)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_MEMORY_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V3),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_dedicatedVideoMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_MEMORY_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dedicatedVideoMemory) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V3),
                "::",
                stringify!(dedicatedVideoMemory)
            )
        );
    }
    test_field_dedicatedVideoMemory();
    fn test_field_availableDedicatedVideoMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_MEMORY_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).availableDedicatedVideoMemory) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V3),
                "::",
                stringify!(availableDedicatedVideoMemory)
            )
        );
    }
    test_field_availableDedicatedVideoMemory();
    fn test_field_systemVideoMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_MEMORY_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).systemVideoMemory) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V3),
                "::",
                stringify!(systemVideoMemory)
            )
        );
    }
    test_field_systemVideoMemory();
    fn test_field_sharedSystemMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_MEMORY_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedSystemMemory) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V3),
                "::",
                stringify!(sharedSystemMemory)
            )
        );
    }
    test_field_sharedSystemMemory();
    fn test_field_curAvailableDedicatedVideoMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_MEMORY_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).curAvailableDedicatedVideoMemory) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V3),
                "::",
                stringify!(curAvailableDedicatedVideoMemory)
            )
        );
    }
    test_field_curAvailableDedicatedVideoMemory();
    fn test_field_dedicatedVideoMemoryEvictionsSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_MEMORY_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dedicatedVideoMemoryEvictionsSize) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V3),
                "::",
                stringify!(dedicatedVideoMemoryEvictionsSize)
            )
        );
    }
    test_field_dedicatedVideoMemoryEvictionsSize();
    fn test_field_dedicatedVideoMemoryEvictionCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_MEMORY_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dedicatedVideoMemoryEvictionCount) as usize
                    - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V3),
                "::",
                stringify!(dedicatedVideoMemoryEvictionCount)
            )
        );
    }
    test_field_dedicatedVideoMemoryEvictionCount();
}
#[doc = "! \\ingroup driverapi"]
#[doc = "! Used in NvAPI_GPU_GetMemoryInfo()."]
pub type NV_DISPLAY_DRIVER_MEMORY_INFO = NV_DISPLAY_DRIVER_MEMORY_INFO_V3;
extern "C" {
    #[doc = "!   DESCRIPTION: This function retrieves the available driver memory footprint for the specified GPU."]
    #[doc = "!                If the GPU is in TCC Mode, only dedicatedVideoMemory will be returned in pMemoryInfo (NV_DISPLAY_DRIVER_MEMORY_INFO)."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 177"]
    #[doc = "!"]
    #[doc = "!  \\param [in]   hPhysicalGpu  Handle of the physical GPU for which the memory information is to be extracted."]
    #[doc = "!  \\param [out]  pMemoryInfo   The memory footprint available in the driver. See NV_DISPLAY_DRIVER_MEMORY_INFO."]
    #[doc = "!"]
    #[doc = "!  \\retval       NVAPI_INVALID_ARGUMENT             pMemoryInfo is NULL."]
    #[doc = "!  \\retval       NVAPI_OK                           Call successful."]
    #[doc = "!  \\retval       NVAPI_NVIDIA_DEVICE_NOT_FOUND      No NVIDIA GPU driving a display was found."]
    #[doc = "!  \\retval       NVAPI_INCOMPATIBLE_STRUCT_VERSION  NV_DISPLAY_DRIVER_MEMORY_INFO structure version mismatch."]
    #[doc = "!"]
    #[doc = "!  \\ingroup  driverapi"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetMemoryInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pMemoryInfo: *mut NV_DISPLAY_DRIVER_MEMORY_INFO,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns an array of physical GPU handles."]
    #[doc = "! Each handle represents a physical GPU present in the system."]
    #[doc = "! That GPU may be part of an SLI configuration, or may not be visible to the OS directly."]
    #[doc = "!"]
    #[doc = "! At least one GPU must be present in the system and running an NVIDIA display driver."]
    #[doc = "!"]
    #[doc = "! The array nvGPUHandle will be filled with physical GPU handle values. The returned"]
    #[doc = "! gpuCount determines how many entries in the array are valid."]
    #[doc = "!"]
    #[doc = "! \\note In drivers older than 105.00, all physical GPU handles get invalidated on a"]
    #[doc = "!       modeset. So the calling applications need to renum the handles after every modeset.\\n"]
    #[doc = "!       With drivers 105.00 and up, all physical GPU handles are constant."]
    #[doc = "!       Physical GPU handles are constant as long as the GPUs are not physically moved and"]
    #[doc = "!       the SBIOS VGA order is unchanged."]
    #[doc = "!"]
    #[doc = "!       For GPU handles in TCC MODE please use NvAPI_EnumTCCPhysicalGPUs()"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\par Introduced in"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "! \\retval NVAPI_INVALID_ARGUMENT         nvGPUHandle or pGpuCount is NULL"]
    #[doc = "! \\retval NVAPI_OK                       One or more handles were returned"]
    #[doc = "! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_EnumPhysicalGPUs(
        nvGPUHandle: *mut NvPhysicalGpuHandle,
        pGpuCount: *mut NvU32,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup dx"]
#[doc = "! Used in NvAPI_D3D10_GetCurrentSLIState(), and NvAPI_D3D_GetCurrentSLIState()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_GET_CURRENT_SLI_STATE_V1 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< [OUT] The maximum possible value of numAFRGroups"]
    pub maxNumAFRGroups: NvU32,
    #[doc = "!< [OUT] The number of AFR groups enabled in the system"]
    pub numAFRGroups: NvU32,
    #[doc = "!< [OUT] The AFR group index for the frame currently being rendered"]
    pub currentAFRIndex: NvU32,
    #[doc = "!< [OUT] What the AFR group index will be for the next frame (i.e. after calling Present)"]
    pub nextFrameAFRIndex: NvU32,
    #[doc = "!< [OUT] The AFR group index that was used for the previous frame (~0 if more than one frame has not been rendered yet)"]
    pub previousFrameAFRIndex: NvU32,
    #[doc = "!< [OUT] Boolean: Is this frame the first time running on the current AFR group"]
    pub bIsCurAFRGroupNew: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GET_CURRENT_SLI_STATE_V1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GET_CURRENT_SLI_STATE_V1>(),
        28usize,
        concat!("Size of: ", stringify!(NV_GET_CURRENT_SLI_STATE_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GET_CURRENT_SLI_STATE_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GET_CURRENT_SLI_STATE_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GET_CURRENT_SLI_STATE_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GET_CURRENT_SLI_STATE_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_maxNumAFRGroups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GET_CURRENT_SLI_STATE_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxNumAFRGroups) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GET_CURRENT_SLI_STATE_V1),
                "::",
                stringify!(maxNumAFRGroups)
            )
        );
    }
    test_field_maxNumAFRGroups();
    fn test_field_numAFRGroups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GET_CURRENT_SLI_STATE_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numAFRGroups) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GET_CURRENT_SLI_STATE_V1),
                "::",
                stringify!(numAFRGroups)
            )
        );
    }
    test_field_numAFRGroups();
    fn test_field_currentAFRIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GET_CURRENT_SLI_STATE_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).currentAFRIndex) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GET_CURRENT_SLI_STATE_V1),
                "::",
                stringify!(currentAFRIndex)
            )
        );
    }
    test_field_currentAFRIndex();
    fn test_field_nextFrameAFRIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GET_CURRENT_SLI_STATE_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nextFrameAFRIndex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GET_CURRENT_SLI_STATE_V1),
                "::",
                stringify!(nextFrameAFRIndex)
            )
        );
    }
    test_field_nextFrameAFRIndex();
    fn test_field_previousFrameAFRIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GET_CURRENT_SLI_STATE_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).previousFrameAFRIndex) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GET_CURRENT_SLI_STATE_V1),
                "::",
                stringify!(previousFrameAFRIndex)
            )
        );
    }
    test_field_previousFrameAFRIndex();
    fn test_field_bIsCurAFRGroupNew() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GET_CURRENT_SLI_STATE_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bIsCurAFRGroupNew) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GET_CURRENT_SLI_STATE_V1),
                "::",
                stringify!(bIsCurAFRGroupNew)
            )
        );
    }
    test_field_bIsCurAFRGroupNew();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_GET_CURRENT_SLI_STATE_V2 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< [OUT] The maximum possible value of numAFRGroups"]
    pub maxNumAFRGroups: NvU32,
    #[doc = "!< [OUT] The number of AFR groups enabled in the system"]
    pub numAFRGroups: NvU32,
    #[doc = "!< [OUT] The AFR group index for the frame currently being rendered"]
    pub currentAFRIndex: NvU32,
    #[doc = "!< [OUT] What the AFR group index will be for the next frame (i.e. after calling Present)"]
    pub nextFrameAFRIndex: NvU32,
    #[doc = "!< [OUT] The AFR group index that was used for the previous frame (~0 if more than one frame has not been rendered yet)"]
    pub previousFrameAFRIndex: NvU32,
    #[doc = "!< [OUT] Boolean: Is this frame the first time running on the current AFR group"]
    pub bIsCurAFRGroupNew: NvU32,
    #[doc = "!< [OUT] The number of GPUs used in VR-SLI. If it is 0 VR-SLI is not active"]
    pub numVRSLIGpus: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GET_CURRENT_SLI_STATE_V2() {
    assert_eq!(
        ::std::mem::size_of::<NV_GET_CURRENT_SLI_STATE_V2>(),
        32usize,
        concat!("Size of: ", stringify!(NV_GET_CURRENT_SLI_STATE_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GET_CURRENT_SLI_STATE_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GET_CURRENT_SLI_STATE_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GET_CURRENT_SLI_STATE_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GET_CURRENT_SLI_STATE_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_maxNumAFRGroups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GET_CURRENT_SLI_STATE_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxNumAFRGroups) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GET_CURRENT_SLI_STATE_V2),
                "::",
                stringify!(maxNumAFRGroups)
            )
        );
    }
    test_field_maxNumAFRGroups();
    fn test_field_numAFRGroups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GET_CURRENT_SLI_STATE_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numAFRGroups) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GET_CURRENT_SLI_STATE_V2),
                "::",
                stringify!(numAFRGroups)
            )
        );
    }
    test_field_numAFRGroups();
    fn test_field_currentAFRIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GET_CURRENT_SLI_STATE_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).currentAFRIndex) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GET_CURRENT_SLI_STATE_V2),
                "::",
                stringify!(currentAFRIndex)
            )
        );
    }
    test_field_currentAFRIndex();
    fn test_field_nextFrameAFRIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GET_CURRENT_SLI_STATE_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nextFrameAFRIndex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GET_CURRENT_SLI_STATE_V2),
                "::",
                stringify!(nextFrameAFRIndex)
            )
        );
    }
    test_field_nextFrameAFRIndex();
    fn test_field_previousFrameAFRIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GET_CURRENT_SLI_STATE_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).previousFrameAFRIndex) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GET_CURRENT_SLI_STATE_V2),
                "::",
                stringify!(previousFrameAFRIndex)
            )
        );
    }
    test_field_previousFrameAFRIndex();
    fn test_field_bIsCurAFRGroupNew() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GET_CURRENT_SLI_STATE_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bIsCurAFRGroupNew) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GET_CURRENT_SLI_STATE_V2),
                "::",
                stringify!(bIsCurAFRGroupNew)
            )
        );
    }
    test_field_bIsCurAFRGroupNew();
    fn test_field_numVRSLIGpus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GET_CURRENT_SLI_STATE_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numVRSLIGpus) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GET_CURRENT_SLI_STATE_V2),
                "::",
                stringify!(numVRSLIGpus)
            )
        );
    }
    test_field_numVRSLIGpus();
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API returns the Display ID of the GDI Primary."]
    #[doc = "!"]
    #[doc = "! \\param [out]     displayId   Display ID of the GDI Primary display."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK:                          Capabilties have been returned."]
    #[doc = "! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND:     GDI Primary not on an NVIDIA GPU."]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT:            One or more args passed in are invalid."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED:          The NvAPI API needs to be initialized first"]
    #[doc = "! \\retval ::NVAPI_NO_IMPLEMENTATION:           This entrypoint not available"]
    #[doc = "! \\retval ::NVAPI_ERROR:                       Miscellaneous error occurred"]
    #[doc = "!"]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_DISP_GetGDIPrimaryDisplayId(displayId: *mut NvU32) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API returns the viewports that would be applied on"]
    #[doc = "!                  the requested display."]
    #[doc = "!"]
    #[doc = "! \\param [in]      displayId       Display ID of a single display in the active"]
    #[doc = "!                                  mosaic topology to query."]
    #[doc = "! \\param [in]      srcWidth        Width of full display topology. If both"]
    #[doc = "!                                  width and height are 0, the current"]
    #[doc = "!                                  resolution is used."]
    #[doc = "! \\param [in]      srcHeight       Height of full display topology. If both"]
    #[doc = "!                                  width and height are 0, the current"]
    #[doc = "!                                  resolution is used."]
    #[doc = "! \\param [out]     viewports       Array of NV_RECT viewports which represent"]
    #[doc = "!                                  the displays as identified in"]
    #[doc = "!                                  NvAPI_Mosaic_EnumGridTopologies. If the"]
    #[doc = "!                                  requested resolution is a single-wide"]
    #[doc = "!                                  resolution, only viewports[0] will"]
    #[doc = "!                                  contain the viewport details, regardless"]
    #[doc = "!                                  of which display is driving the display."]
    #[doc = "! \\param [out]     bezelCorrected  Returns 1 if the requested resolution is"]
    #[doc = "!                                  bezel corrected. May be NULL."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                          Capabilties have been returned."]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT            One or more args passed in are invalid."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first"]
    #[doc = "! \\retval ::NVAPI_MOSAIC_NOT_ACTIVE           The display does not belong to an active Mosaic Topology"]
    #[doc = "! \\retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available"]
    #[doc = "! \\retval ::NVAPI_ERROR                       Miscellaneous error occurred"]
    #[doc = "!"]
    #[doc = "! \\ingroup mosaicapi"]
    #[doc = ""]
    pub fn NvAPI_Mosaic_GetDisplayViewportsByResolution(
        displayId: NvU32,
        srcWidth: NvU32,
        srcHeight: NvU32,
        viewports: *mut NV_RECT,
        bezelCorrected: *mut NvU8,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This APU enables stereo mode in the registry."]
    #[doc = "!                Calls to this function affect the entire system."]
    #[doc = "!                If stereo is not enabled, then calls to functions that require that stereo is enabled have no effect,"]
    #[doc = "!                and will return the appropriate error code."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                      Stereo is now enabled."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED"]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED  Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_ERROR"]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_Enable() -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API disables stereo mode in the registry."]
    #[doc = "!                Calls to this function affect the entire system."]
    #[doc = "!                If stereo is not enabled, then calls to functions that require that stereo is enabled have no effect,"]
    #[doc = "!                and will return the appropriate error code."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                     Stereo is now disabled."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED"]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_ERROR"]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_Disable() -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API checks if stereo mode is enabled in the registry."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "! \\param [out]     pIsStereoEnabled   Address where the result of the inquiry will be placed."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                       Check was sucessfully completed and result reflects current state of stereo availability."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED"]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED   Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_ERROR"]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_IsEnabled(pIsStereoEnabled: *mut NvU8) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API destroys the stereo handle created with one of the NvAPI_Stereo_CreateHandleFrom() functions."]
    #[doc = "!                This should be called after the device corresponding to the handle has been destroyed."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "! \\param [in]     stereoHandle  Stereo handle that is to be destroyed."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                      Stereo handle is destroyed."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED"]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED  Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_ERROR"]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_DestroyHandle(stereoHandle: StereoHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API activates stereo for the device interface corresponding to the given stereo handle."]
    #[doc = "!                Activating stereo is possible only if stereo was enabled previously in the registry."]
    #[doc = "!                If stereo is not activated, then calls to functions that require that stereo is activated have no effect,"]
    #[doc = "!                and will return the appropriate error code."]
    #[doc = "!"]
    #[doc = "! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "! \\param [in]    stereoHandle  Stereo handle corresponding to the device interface."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                                Stereo is turned on."]
    #[doc = "! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED"]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED            Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_ERROR"]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_Activate(stereoHandle: StereoHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API deactivates stereo for the given device interface."]
    #[doc = "!                If stereo is not activated, then calls to functions that require that stereo is activated have no effect,"]
    #[doc = "!                and will return the appropriate error code."]
    #[doc = "!"]
    #[doc = "! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "! \\param [in]     stereoHandle  Stereo handle that corresponds to the device interface."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                               Stereo is turned off."]
    #[doc = "! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED"]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_ERROR"]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_Deactivate(stereoHandle: StereoHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API checks if stereo is activated for the given device interface."]
    #[doc = "!"]
    #[doc = "! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "! \\param [in]    stereoHandle  Stereo handle that corresponds to the device interface."]
    #[doc = "! \\param [in]    pIsStereoOn   Address where result of the inquiry will be placed."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK - Check was sucessfully completed and result reflects current state of stereo (on/off)."]
    #[doc = "! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_ERROR - Something is wrong (generic error)."]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_IsActivated(
        stereoHandle: StereoHandle,
        pIsStereoOn: *mut NvU8,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API gets current separation value (in percents)."]
    #[doc = "!"]
    #[doc = "! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "! \\param [in]     stereoHandle           Stereo handle that corresponds to the device interface."]
    #[doc = "! \\param [out]    pSeparationPercentage  Address of @c float type variable to store current separation percentage in."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                                Retrieval of separation percentage was successfull."]
    #[doc = "! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED"]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED            Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_ERROR"]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_GetSeparation(
        stereoHandle: StereoHandle,
        pSeparationPercentage: *mut f32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API sets separation to given percentage."]
    #[doc = "!"]
    #[doc = "! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom() function."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "! \\param [in]     stereoHandle             Stereo handle that corresponds to the device interface."]
    #[doc = "! \\param [in]     newSeparationPercentage  New value for separation percentage."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                               Setting of separation percentage was successfull."]
    #[doc = "! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED               NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_STEREO_PARAMETER_OUT_OF_RANGE    Given separation percentage is out of [0..100] range."]
    #[doc = "! \\retval ::NVAPI_ERROR"]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_SetSeparation(
        stereoHandle: StereoHandle,
        newSeparationPercentage: f32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API gets the current convergence value."]
    #[doc = "!"]
    #[doc = "! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "! \\param [in]     stereoHandle   Stereo handle that corresponds to the device interface."]
    #[doc = "! \\param [out]    pConvergence   Address of @c float type variable to store current convergence value in."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                               Retrieval of convergence value was successfull."]
    #[doc = "! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED"]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_ERROR"]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_GetConvergence(
        stereoHandle: StereoHandle,
        pConvergence: *mut f32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API sets convergence to the given value."]
    #[doc = "!"]
    #[doc = "! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "! \\param [in]     stereoHandle              Stereo handle that corresponds to the device interface."]
    #[doc = "! \\param [in]     newConvergence            New value for convergence."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                                Setting of convergence value was successfull."]
    #[doc = "! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED"]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED            Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_ERROR"]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_SetConvergence(
        stereoHandle: StereoHandle,
        newConvergence: f32,
    ) -> NvAPI_Status;
}
pub const _NV_StereoActiveEye_NVAPI_STEREO_EYE_RIGHT: _NV_StereoActiveEye = 1;
pub const _NV_StereoActiveEye_NVAPI_STEREO_EYE_LEFT: _NV_StereoActiveEye = 2;
pub const _NV_StereoActiveEye_NVAPI_STEREO_EYE_MONO: _NV_StereoActiveEye = 3;
#[doc = "! \\ingroup stereoapi"]
pub type _NV_StereoActiveEye = ::std::os::raw::c_int;
#[doc = "! \\ingroup stereoapi"]
pub use self::_NV_StereoActiveEye as NV_STEREO_ACTIVE_EYE;
extern "C" {
    #[doc = "! \\ingroup stereoapi"]
    pub fn NvAPI_Stereo_SetActiveEye(
        hStereoHandle: StereoHandle,
        StereoEye: NV_STEREO_ACTIVE_EYE,
    ) -> NvAPI_Status;
}
pub const _NV_StereoDriverMode_NVAPI_STEREO_DRIVER_MODE_AUTOMATIC: _NV_StereoDriverMode = 0;
pub const _NV_StereoDriverMode_NVAPI_STEREO_DRIVER_MODE_DIRECT: _NV_StereoDriverMode = 2;
#[doc = "! \\ingroup stereoapi"]
pub type _NV_StereoDriverMode = ::std::os::raw::c_int;
#[doc = "! \\ingroup stereoapi"]
pub use self::_NV_StereoDriverMode as NV_STEREO_DRIVER_MODE;
extern "C" {
    #[doc = "! \\ingroup stereoapi"]
    pub fn NvAPI_Stereo_SetDriverMode(mode: NV_STEREO_DRIVER_MODE) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API returns eye separation as a ratio of <between eye distance>/<physical screen width>."]
    #[doc = "!"]
    #[doc = "! HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate API. Applies only to DirectX 9 and up."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]   stereoHandle  Stereo handle that corresponds to the device interface."]
    #[doc = "! \\param [out]  pSeparation   Eye separation."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                               Active eye is set."]
    #[doc = "! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED               NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_ERROR  (generic error)."]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_GetEyeSeparation(
        hStereoHandle: StereoHandle,
        pSeparation: *mut f32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API returns availability of windowed mode stereo"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [out] bSupported(OUT)    != 0  - supported,  \\n"]
    #[doc = "!                                 == 0  - is not supported"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                      Retrieval of frustum adjust mode was successfull."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED      NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED  Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_ERROR                   Something is wrong (generic error)."]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_IsWindowedModeSupported(bSupported: *mut NvU8) -> NvAPI_Status;
}
#[doc = "!< Use driver registry profile settings for surface creation mode."]
pub const _NVAPI_STEREO_SURFACECREATEMODE_NVAPI_STEREO_SURFACECREATEMODE_AUTO:
    _NVAPI_STEREO_SURFACECREATEMODE = 0;
#[doc = "!< Always create stereo surfaces."]
pub const _NVAPI_STEREO_SURFACECREATEMODE_NVAPI_STEREO_SURFACECREATEMODE_FORCESTEREO:
    _NVAPI_STEREO_SURFACECREATEMODE = 1;
#[doc = "!< Always create mono surfaces."]
pub const _NVAPI_STEREO_SURFACECREATEMODE_NVAPI_STEREO_SURFACECREATEMODE_FORCEMONO:
    _NVAPI_STEREO_SURFACECREATEMODE = 2;
#[doc = "! \\ingroup stereoapi"]
pub type _NVAPI_STEREO_SURFACECREATEMODE = ::std::os::raw::c_int;
#[doc = "! \\ingroup stereoapi"]
pub use self::_NVAPI_STEREO_SURFACECREATEMODE as NVAPI_STEREO_SURFACECREATEMODE;
extern "C" {
    #[doc = "! \\ingroup stereoapi"]
    pub fn NvAPI_Stereo_SetSurfaceCreationMode(
        hStereoHandle: StereoHandle,
        creationMode: NVAPI_STEREO_SURFACECREATEMODE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! \\ingroup stereoapi"]
    pub fn NvAPI_Stereo_GetSurfaceCreationMode(
        hStereoHandle: StereoHandle,
        pCreationMode: *mut NVAPI_STEREO_SURFACECREATEMODE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! \\param [in]  hStereoHandle    Stereo handle that corresponds to the device interface."]
    #[doc = "! \\param [out] pWasStereoized   Address where result of the inquiry will be placed."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! DESCRIPTION: This API checks if the last draw call was stereoized. It is a very expensive to call and should be used for debugging purpose *only*."]
    #[doc = "!"]
    #[doc = "! WHEN TO USE: After the stereo handle for device interface is created via successful call to appropriate NvAPI_Stereo_CreateHandleFrom function."]
    #[doc = "!"]
    #[doc = "! \\return      This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!              There are no return error codes with specific meaning for this API."]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_Debug_WasLastDrawStereoized(
        hStereoHandle: StereoHandle,
        pWasStereoized: *mut NvU8,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! DESCRIPTION: This API defines the stereo profile used by the driver in case the application has no associated profile."]
    #[doc = "!"]
    #[doc = "! WHEN TO USE: To take effect, this API must be called before D3D device is created. Calling once a device has been created will not affect the current device."]
    #[doc = "!"]
    #[doc = "! \\param [in]  szProfileName        Default profile name."]
    #[doc = "!"]
    #[doc = "! \\return      This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!              Error codes specific to this API are described below."]
    #[doc = "!"]
    #[doc = "! \\retval      NVAPI_SUCCESS                               - Default stereo profile name has been copied into szProfileName."]
    #[doc = "! \\retval      NVAPI_INVALID_ARGUMENT                      - szProfileName == NULL."]
    #[doc = "! \\retval      NVAPI_DEFAULT_STEREO_PROFILE_DOES_NOT_EXIST - Default stereo profile does not exist"]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_SetDefaultProfile(
        szProfileName: *const ::std::os::raw::c_char,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! DESCRIPTION: This API retrieves the current default stereo profile."]
    #[doc = "!"]
    #[doc = "!              After call cbSizeOut contain 0 if default profile is not set required buffer size cbSizeOut."]
    #[doc = "!              To get needed buffer size this function can be called with szProfileName==0 and cbSizeIn == 0."]
    #[doc = "!"]
    #[doc = "! WHEN TO USE: This API can be called at any time."]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]   cbSizeIn             Size of buffer allocated for default stereo profile name."]
    #[doc = "! \\param [out]  szProfileName        Default stereo profile name."]
    #[doc = "! \\param [out]  pcbSizeOut           Required buffer size."]
    #[doc = "!                     # ==0 - there is no default stereo profile name currently set"]
    #[doc = "!                     # !=0 - size of buffer required for currently set default stereo profile name including trailing '0'."]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\return      This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!              Error codes specific to this API are described below."]
    #[doc = "!"]
    #[doc = "! \\retval      NVAPI_SUCCESS                                - Default stereo profile name has been copied into szProfileName."]
    #[doc = "! \\retval      NVAPI_DEFAULT_STEREO_PROFILE_IS_NOT_DEFINED  - There is no default stereo profile set at this time."]
    #[doc = "! \\retval      NVAPI_INVALID_ARGUMENT                       - pcbSizeOut == 0 or cbSizeIn >= *pcbSizeOut && szProfileName == 0"]
    #[doc = "! \\retval      NVAPI_INSUFFICIENT_BUFFER                    - cbSizeIn < *pcbSizeOut"]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_GetDefaultProfile(
        cbSizeIn: NvU32,
        szProfileName: *mut ::std::os::raw::c_char,
        pcbSizeOut: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function initializes the NvAPI library (if not already initialized) but always increments the ref-counter."]
    #[doc = "! This must be called before calling other NvAPI_ functions."]
    #[doc = "! Note: It is now mandatory to call NvAPI_Initialize before calling any other NvAPI."]
    #[doc = "! NvAPI_Unload should be called to unload the NVAPI Library."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "! \\return      This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with"]
    #[doc = "!              specific meaning for this API, they are listed below."]
    #[doc = "! \\retval      NVAPI_LIBRARY_NOT_FOUND  Failed to load the NVAPI support library"]
    #[doc = "! \\sa nvapistatus"]
    #[doc = "! \\ingroup nvapifunctions"]
    #[doc = ""]
    pub fn NvAPI_Initialize() -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: Decrements the ref-counter and when it reaches ZERO, unloads NVAPI library."]
    #[doc = "!                This must be called in pairs with NvAPI_Initialize."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "!        If the client wants unload functionality, it is recommended to always call NvAPI_Initialize and NvAPI_Unload in pairs."]
    #[doc = "!"]
    #[doc = "!  Unloading NvAPI library is not supported when the library is in a resource locked state."]
    #[doc = "!  Some functions in the NvAPI library initiates an operation or allocates certain resources"]
    #[doc = "!  and there are corresponding functions available, to complete the operation or free the"]
    #[doc = "!  allocated resources. All such function pairs are designed to prevent unloading NvAPI library."]
    #[doc = "!"]
    #[doc = "!  For example, if NvAPI_Unload is called after NvAPI_XXX which locks a resource, it fails with"]
    #[doc = "!  NVAPI_ERROR. Developers need to call the corresponding NvAPI_YYY to unlock the resources,"]
    #[doc = "!  before calling NvAPI_Unload again."]
    #[doc = "!"]
    #[doc = "! \\return      This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with"]
    #[doc = "!              specific meaning for this API, they are listed below."]
    #[doc = "! \\retval      NVAPI_API_IN_USE       Atleast an API is still being called hence cannot unload requested driver."]
    #[doc = "!"]
    #[doc = "! \\ingroup nvapifunctions"]
    #[doc = ""]
    pub fn NvAPI_Unload() -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function converts an NvAPI error code into a null terminated string."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "! \\param nr      The error code to convert"]
    #[doc = "! \\param szDesc  The string corresponding to the error code"]
    #[doc = "!"]
    #[doc = "! \\return NULL terminated string (always, never NULL)"]
    #[doc = "! \\ingroup nvapifunctions"]
    #[doc = ""]
    pub fn NvAPI_GetErrorMessage(
        nr: NvAPI_Status,
        szDesc: *mut ::std::os::raw::c_char,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns a string describing the version of the NvAPI library."]
    #[doc = "!               The contents of the string are human readable.  Do not assume a fixed"]
    #[doc = "!                format."]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "! \\param  szDesc User readable string giving NvAPI version information"]
    #[doc = "!"]
    #[doc = "! \\return See \\ref nvapistatus for the list of possible return values."]
    #[doc = "! \\ingroup nvapifunctions"]
    #[doc = ""]
    pub fn NvAPI_GetInterfaceVersionString(szDesc: *mut ::std::os::raw::c_char) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns a string describing the version of the NvAPI library."]
    #[doc = "!               The contents of the string are human readable.  Do not assume a fixed  format."]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 450"]
    #[doc = "!"]
    #[doc = "! \\param  szDesc User readable string giving NvAPI version information"]
    #[doc = "!"]
    #[doc = "! \\return See \\ref nvapistatus for the list of possible return values."]
    #[doc = "! \\ingroup nvapifunctions"]
    #[doc = ""]
    pub fn NvAPI_GetInterfaceVersionStringEx(szDesc: *mut ::std::os::raw::c_char) -> NvAPI_Status;
}
pub const _NV_DP_LINK_RATE_NV_DP_1_62GBPS: _NV_DP_LINK_RATE = 6;
pub const _NV_DP_LINK_RATE_NV_DP_2_70GBPS: _NV_DP_LINK_RATE = 10;
pub const _NV_DP_LINK_RATE_NV_DP_5_40GBPS: _NV_DP_LINK_RATE = 20;
pub const _NV_DP_LINK_RATE_NV_DP_8_10GBPS: _NV_DP_LINK_RATE = 30;
pub const _NV_DP_LINK_RATE_NV_EDP_2_16GBPS: _NV_DP_LINK_RATE = 8;
pub const _NV_DP_LINK_RATE_NV_EDP_2_43GBPS: _NV_DP_LINK_RATE = 9;
pub const _NV_DP_LINK_RATE_NV_EDP_3_24GBPS: _NV_DP_LINK_RATE = 12;
pub const _NV_DP_LINK_RATE_NV_EDP_4_32GBPS: _NV_DP_LINK_RATE = 16;
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NV_DISPLAY_PORT_INFO."]
pub type _NV_DP_LINK_RATE = ::std::os::raw::c_int;
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NV_DISPLAY_PORT_INFO."]
pub use self::_NV_DP_LINK_RATE as NV_DP_LINK_RATE;
pub const _NV_DP_LANE_COUNT_NV_DP_1_LANE: _NV_DP_LANE_COUNT = 1;
pub const _NV_DP_LANE_COUNT_NV_DP_2_LANE: _NV_DP_LANE_COUNT = 2;
pub const _NV_DP_LANE_COUNT_NV_DP_4_LANE: _NV_DP_LANE_COUNT = 4;
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NV_DISPLAY_PORT_INFO."]
pub type _NV_DP_LANE_COUNT = ::std::os::raw::c_int;
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NV_DISPLAY_PORT_INFO."]
pub use self::_NV_DP_LANE_COUNT as NV_DP_LANE_COUNT;
pub const _NV_DP_COLOR_FORMAT_NV_DP_COLOR_FORMAT_RGB: _NV_DP_COLOR_FORMAT = 0;
pub const _NV_DP_COLOR_FORMAT_NV_DP_COLOR_FORMAT_YCbCr422: _NV_DP_COLOR_FORMAT = 1;
pub const _NV_DP_COLOR_FORMAT_NV_DP_COLOR_FORMAT_YCbCr444: _NV_DP_COLOR_FORMAT = 2;
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NV_DISPLAY_PORT_INFO."]
pub type _NV_DP_COLOR_FORMAT = ::std::os::raw::c_int;
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NV_DISPLAY_PORT_INFO."]
pub use self::_NV_DP_COLOR_FORMAT as NV_DP_COLOR_FORMAT;
pub const _NV_DP_COLORIMETRY_NV_DP_COLORIMETRY_RGB: _NV_DP_COLORIMETRY = 0;
pub const _NV_DP_COLORIMETRY_NV_DP_COLORIMETRY_YCbCr_ITU601: _NV_DP_COLORIMETRY = 1;
pub const _NV_DP_COLORIMETRY_NV_DP_COLORIMETRY_YCbCr_ITU709: _NV_DP_COLORIMETRY = 2;
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NV_DISPLAY_PORT_INFO."]
pub type _NV_DP_COLORIMETRY = ::std::os::raw::c_int;
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NV_DISPLAY_PORT_INFO."]
pub use self::_NV_DP_COLORIMETRY as NV_DP_COLORIMETRY;
pub const _NV_DP_DYNAMIC_RANGE_NV_DP_DYNAMIC_RANGE_VESA: _NV_DP_DYNAMIC_RANGE = 0;
pub const _NV_DP_DYNAMIC_RANGE_NV_DP_DYNAMIC_RANGE_CEA: _NV_DP_DYNAMIC_RANGE = 1;
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NV_DISPLAY_PORT_INFO."]
pub type _NV_DP_DYNAMIC_RANGE = ::std::os::raw::c_int;
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NV_DISPLAY_PORT_INFO."]
pub use self::_NV_DP_DYNAMIC_RANGE as NV_DP_DYNAMIC_RANGE;
pub const _NV_DP_BPC_NV_DP_BPC_DEFAULT: _NV_DP_BPC = 0;
pub const _NV_DP_BPC_NV_DP_BPC_6: _NV_DP_BPC = 1;
pub const _NV_DP_BPC_NV_DP_BPC_8: _NV_DP_BPC = 2;
pub const _NV_DP_BPC_NV_DP_BPC_10: _NV_DP_BPC = 3;
pub const _NV_DP_BPC_NV_DP_BPC_12: _NV_DP_BPC = 4;
pub const _NV_DP_BPC_NV_DP_BPC_16: _NV_DP_BPC = 5;
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NV_DISPLAY_PORT_INFO."]
pub type _NV_DP_BPC = ::std::os::raw::c_int;
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NV_DISPLAY_PORT_INFO."]
pub use self::_NV_DP_BPC as NV_DP_BPC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_EDID_V1 {
    pub version: NvU32,
    pub EDID_Data: [NvU8; 256usize],
}
#[test]
fn bindgen_test_layout_NV_EDID_V1() {
    assert_eq!(
        ::std::mem::size_of::<NV_EDID_V1>(),
        260usize,
        concat!("Size of: ", stringify!(NV_EDID_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_EDID_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_EDID_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_EDID_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_EDID_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_EDID_Data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_EDID_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).EDID_Data) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_EDID_V1),
                "::",
                stringify!(EDID_Data)
            )
        );
    }
    test_field_EDID_Data();
}
impl Default for NV_EDID_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Used in NvAPI_GPU_GetEDID()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_EDID_V2 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    pub EDID_Data: [NvU8; 256usize],
    pub sizeofEDID: NvU32,
}
#[test]
fn bindgen_test_layout_NV_EDID_V2() {
    assert_eq!(
        ::std::mem::size_of::<NV_EDID_V2>(),
        264usize,
        concat!("Size of: ", stringify!(NV_EDID_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_EDID_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_EDID_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_EDID_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_EDID_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_EDID_Data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_EDID_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).EDID_Data) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_EDID_V2),
                "::",
                stringify!(EDID_Data)
            )
        );
    }
    test_field_EDID_Data();
    fn test_field_sizeofEDID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_EDID_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sizeofEDID) as usize - ptr as usize
            },
            260usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_EDID_V2),
                "::",
                stringify!(sizeofEDID)
            )
        );
    }
    test_field_sizeofEDID();
}
impl Default for NV_EDID_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Used in NvAPI_GPU_GetEDID()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_EDID_V3 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    pub EDID_Data: [NvU8; 256usize],
    pub sizeofEDID: NvU32,
    #[doc = "!< ID which always returned in a monotonically increasing counter."]
    #[doc = "!< Across a split-EDID read we need to verify that all calls returned the same edidId."]
    #[doc = "!< This counter is incremented if we get the updated EDID."]
    pub edidId: NvU32,
    #[doc = "!< Which 256-byte page of the EDID we want to read. Start at 0."]
    #[doc = "!< If the read succeeds with edidSize > NV_EDID_DATA_SIZE,"]
    #[doc = "!< call back again with offset+256 until we have read the entire buffer"]
    pub offset: NvU32,
}
#[test]
fn bindgen_test_layout_NV_EDID_V3() {
    assert_eq!(
        ::std::mem::size_of::<NV_EDID_V3>(),
        272usize,
        concat!("Size of: ", stringify!(NV_EDID_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_EDID_V3>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_EDID_V3))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_EDID_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_EDID_V3),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_EDID_Data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_EDID_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).EDID_Data) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_EDID_V3),
                "::",
                stringify!(EDID_Data)
            )
        );
    }
    test_field_EDID_Data();
    fn test_field_sizeofEDID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_EDID_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sizeofEDID) as usize - ptr as usize
            },
            260usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_EDID_V3),
                "::",
                stringify!(sizeofEDID)
            )
        );
    }
    test_field_sizeofEDID();
    fn test_field_edidId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_EDID_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).edidId) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_EDID_V3),
                "::",
                stringify!(edidId)
            )
        );
    }
    test_field_edidId();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_EDID_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            268usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_EDID_V3),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
}
impl Default for NV_EDID_V3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Used in NvAPI_GPU_GetEDID()"]
pub type NV_EDID = NV_EDID_V3;
extern "C" {
    #[doc = "! \\ingroup gpu"]
    pub fn NvAPI_GPU_GetEDID(
        hPhysicalGpu: NvPhysicalGpuHandle,
        displayOutputId: NvU32,
        pEDID: *mut NV_EDID,
    ) -> NvAPI_Status;
}
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_VGA_15_PIN: _NV_GPU_CONNECTOR_TYPE = 0;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_TV_COMPOSITE: _NV_GPU_CONNECTOR_TYPE = 16;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_TV_SVIDEO: _NV_GPU_CONNECTOR_TYPE = 17;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_TV_HDTV_COMPONENT: _NV_GPU_CONNECTOR_TYPE = 19;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_TV_SCART: _NV_GPU_CONNECTOR_TYPE = 20;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_TV_COMPOSITE_SCART_ON_EIAJ4120:
    _NV_GPU_CONNECTOR_TYPE = 22;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_TV_HDTV_EIAJ4120: _NV_GPU_CONNECTOR_TYPE = 23;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_PC_POD_HDTV_YPRPB: _NV_GPU_CONNECTOR_TYPE = 24;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_PC_POD_SVIDEO: _NV_GPU_CONNECTOR_TYPE = 25;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_PC_POD_COMPOSITE: _NV_GPU_CONNECTOR_TYPE = 26;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_DVI_I_TV_SVIDEO: _NV_GPU_CONNECTOR_TYPE = 32;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_DVI_I_TV_COMPOSITE: _NV_GPU_CONNECTOR_TYPE =
    33;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_DVI_I: _NV_GPU_CONNECTOR_TYPE = 48;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_DVI_D: _NV_GPU_CONNECTOR_TYPE = 49;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_ADC: _NV_GPU_CONNECTOR_TYPE = 50;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_LFH_DVI_I_1: _NV_GPU_CONNECTOR_TYPE = 56;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_LFH_DVI_I_2: _NV_GPU_CONNECTOR_TYPE = 57;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_SPWG: _NV_GPU_CONNECTOR_TYPE = 64;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_OEM: _NV_GPU_CONNECTOR_TYPE = 65;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_DISPLAYPORT_EXTERNAL: _NV_GPU_CONNECTOR_TYPE =
    70;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_DISPLAYPORT_INTERNAL: _NV_GPU_CONNECTOR_TYPE =
    71;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_DISPLAYPORT_MINI_EXT: _NV_GPU_CONNECTOR_TYPE =
    72;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_HDMI_A: _NV_GPU_CONNECTOR_TYPE = 97;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_HDMI_C_MINI: _NV_GPU_CONNECTOR_TYPE = 99;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_LFH_DISPLAYPORT_1: _NV_GPU_CONNECTOR_TYPE =
    100;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_LFH_DISPLAYPORT_2: _NV_GPU_CONNECTOR_TYPE =
    101;
#[doc = "!< Deprecated."]
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_VIRTUAL_WFD: _NV_GPU_CONNECTOR_TYPE = 112;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_USB_C: _NV_GPU_CONNECTOR_TYPE = 113;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_UNKNOWN: _NV_GPU_CONNECTOR_TYPE = -1;
#[doc = "! \\ingroup gpu"]
#[doc = "! Used in NV_GPU_CONNECTOR_DATA"]
pub type _NV_GPU_CONNECTOR_TYPE = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpu"]
#[doc = "! Used in NV_GPU_CONNECTOR_DATA"]
pub use self::_NV_GPU_CONNECTOR_TYPE as NV_GPU_CONNECTOR_TYPE;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_NONE: _NV_DISPLAY_TV_FORMAT = 0;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_SD_NTSCM: _NV_DISPLAY_TV_FORMAT = 1;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_SD_NTSCJ: _NV_DISPLAY_TV_FORMAT = 2;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_SD_PALM: _NV_DISPLAY_TV_FORMAT = 4;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_SD_PALBDGH: _NV_DISPLAY_TV_FORMAT = 8;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_SD_PALN: _NV_DISPLAY_TV_FORMAT = 16;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_SD_PALNC: _NV_DISPLAY_TV_FORMAT = 32;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_SD_576i: _NV_DISPLAY_TV_FORMAT = 256;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_SD_480i: _NV_DISPLAY_TV_FORMAT = 512;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_ED_480p: _NV_DISPLAY_TV_FORMAT = 1024;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_ED_576p: _NV_DISPLAY_TV_FORMAT = 2048;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_HD_720p: _NV_DISPLAY_TV_FORMAT = 4096;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_HD_1080i: _NV_DISPLAY_TV_FORMAT = 8192;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_HD_1080p: _NV_DISPLAY_TV_FORMAT = 16384;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_HD_720p50: _NV_DISPLAY_TV_FORMAT = 32768;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_HD_1080p24: _NV_DISPLAY_TV_FORMAT = 65536;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_HD_1080i50: _NV_DISPLAY_TV_FORMAT = 131072;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_HD_1080p50: _NV_DISPLAY_TV_FORMAT = 262144;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp30: _NV_DISPLAY_TV_FORMAT = 524288;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp30_3840: _NV_DISPLAY_TV_FORMAT = 524288;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp25: _NV_DISPLAY_TV_FORMAT = 1048576;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp25_3840: _NV_DISPLAY_TV_FORMAT =
    1048576;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp24: _NV_DISPLAY_TV_FORMAT = 2097152;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp24_3840: _NV_DISPLAY_TV_FORMAT =
    2097152;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp24_SMPTE: _NV_DISPLAY_TV_FORMAT =
    4194304;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp50_3840: _NV_DISPLAY_TV_FORMAT =
    8388608;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp60_3840: _NV_DISPLAY_TV_FORMAT =
    9437184;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp30_4096: _NV_DISPLAY_TV_FORMAT =
    10485760;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp25_4096: _NV_DISPLAY_TV_FORMAT =
    11534336;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp24_4096: _NV_DISPLAY_TV_FORMAT =
    12582912;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp50_4096: _NV_DISPLAY_TV_FORMAT =
    13631488;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp60_4096: _NV_DISPLAY_TV_FORMAT =
    14680064;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_8Kp24_7680: _NV_DISPLAY_TV_FORMAT =
    16777216;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_8Kp25_7680: _NV_DISPLAY_TV_FORMAT =
    33554432;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_8Kp30_7680: _NV_DISPLAY_TV_FORMAT =
    67108864;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_8Kp48_7680: _NV_DISPLAY_TV_FORMAT =
    134217728;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_8Kp50_7680: _NV_DISPLAY_TV_FORMAT =
    150994944;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_8Kp60_7680: _NV_DISPLAY_TV_FORMAT =
    167772160;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_8Kp100_7680: _NV_DISPLAY_TV_FORMAT =
    184549376;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_8Kp120_7680: _NV_DISPLAY_TV_FORMAT =
    201326592;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp48_3840: _NV_DISPLAY_TV_FORMAT =
    218103808;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp48_4096: _NV_DISPLAY_TV_FORMAT =
    234881024;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp100_4096: _NV_DISPLAY_TV_FORMAT =
    251658240;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp100_3840: _NV_DISPLAY_TV_FORMAT =
    268435456;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp120_4096: _NV_DISPLAY_TV_FORMAT =
    285212672;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp120_3840: _NV_DISPLAY_TV_FORMAT =
    301989888;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp100_5120: _NV_DISPLAY_TV_FORMAT =
    318767104;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp120_5120: _NV_DISPLAY_TV_FORMAT =
    335544320;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp24_5120: _NV_DISPLAY_TV_FORMAT =
    352321536;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp25_5120: _NV_DISPLAY_TV_FORMAT =
    369098752;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp30_5120: _NV_DISPLAY_TV_FORMAT =
    385875968;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp48_5120: _NV_DISPLAY_TV_FORMAT =
    402653184;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp50_5120: _NV_DISPLAY_TV_FORMAT =
    419430400;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp60_5120: _NV_DISPLAY_TV_FORMAT =
    536870912;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_10Kp24_10240: _NV_DISPLAY_TV_FORMAT =
    553648128;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_10Kp25_10240: _NV_DISPLAY_TV_FORMAT =
    570425344;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_10Kp30_10240: _NV_DISPLAY_TV_FORMAT =
    587202560;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_10Kp48_10240: _NV_DISPLAY_TV_FORMAT =
    603979776;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_10Kp50_10240: _NV_DISPLAY_TV_FORMAT =
    620756992;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_10Kp60_10240: _NV_DISPLAY_TV_FORMAT =
    637534208;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_10Kp100_10240: _NV_DISPLAY_TV_FORMAT =
    654311424;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_10Kp120_10240: _NV_DISPLAY_TV_FORMAT =
    671088640;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_SD_OTHER: _NV_DISPLAY_TV_FORMAT = 805306368;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_ED_OTHER: _NV_DISPLAY_TV_FORMAT = 1073741824;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_HD_OTHER: _NV_DISPLAY_TV_FORMAT = 1342177280;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_ANY: _NV_DISPLAY_TV_FORMAT = -2147483648;
#[doc = "! \\ingroup tvapi"]
#[doc = "! Used in NV_DISPLAY_TV_OUTPUT_INFO"]
pub type _NV_DISPLAY_TV_FORMAT = ::std::os::raw::c_int;
#[doc = "! \\ingroup tvapi"]
#[doc = "! Used in NV_DISPLAY_TV_OUTPUT_INFO"]
pub use self::_NV_DISPLAY_TV_FORMAT as NV_DISPLAY_TV_FORMAT;
pub const _NV_TARGET_VIEW_MODE_NV_VIEW_MODE_STANDARD: _NV_TARGET_VIEW_MODE = 0;
pub const _NV_TARGET_VIEW_MODE_NV_VIEW_MODE_CLONE: _NV_TARGET_VIEW_MODE = 1;
pub const _NV_TARGET_VIEW_MODE_NV_VIEW_MODE_HSPAN: _NV_TARGET_VIEW_MODE = 2;
pub const _NV_TARGET_VIEW_MODE_NV_VIEW_MODE_VSPAN: _NV_TARGET_VIEW_MODE = 3;
pub const _NV_TARGET_VIEW_MODE_NV_VIEW_MODE_DUALVIEW: _NV_TARGET_VIEW_MODE = 4;
pub const _NV_TARGET_VIEW_MODE_NV_VIEW_MODE_MULTIVIEW: _NV_TARGET_VIEW_MODE = 5;
#[doc = "! Used in NvAPI_SetView()."]
pub type _NV_TARGET_VIEW_MODE = ::std::os::raw::c_int;
#[doc = "! Used in NvAPI_SetView()."]
pub use self::_NV_TARGET_VIEW_MODE as NV_TARGET_VIEW_MODE;
#[doc = "!< No change"]
pub const _NV_SCALING_NV_SCALING_DEFAULT: _NV_SCALING = 0;
#[doc = "!< Balanced  - Full Screen"]
pub const _NV_SCALING_NV_SCALING_GPU_SCALING_TO_CLOSEST: _NV_SCALING = 1;
#[doc = "!< Force GPU - Full Screen"]
pub const _NV_SCALING_NV_SCALING_GPU_SCALING_TO_NATIVE: _NV_SCALING = 2;
#[doc = "!< Force GPU - Centered\\No Scaling"]
pub const _NV_SCALING_NV_SCALING_GPU_SCANOUT_TO_NATIVE: _NV_SCALING = 3;
#[doc = "!< Force GPU - Aspect Ratio"]
pub const _NV_SCALING_NV_SCALING_GPU_SCALING_TO_ASPECT_SCANOUT_TO_NATIVE: _NV_SCALING = 5;
#[doc = "!< Balanced  - Aspect Ratio"]
pub const _NV_SCALING_NV_SCALING_GPU_SCALING_TO_ASPECT_SCANOUT_TO_CLOSEST: _NV_SCALING = 6;
#[doc = "!< Balanced  - Centered\\No Scaling"]
pub const _NV_SCALING_NV_SCALING_GPU_SCANOUT_TO_CLOSEST: _NV_SCALING = 7;
#[doc = "!< Force GPU - Integer Scaling"]
pub const _NV_SCALING_NV_SCALING_GPU_INTEGER_ASPECT_SCALING: _NV_SCALING = 8;
pub const _NV_SCALING_NV_SCALING_MONITOR_SCALING: _NV_SCALING = 1;
pub const _NV_SCALING_NV_SCALING_ADAPTER_SCALING: _NV_SCALING = 2;
pub const _NV_SCALING_NV_SCALING_CENTERED: _NV_SCALING = 3;
pub const _NV_SCALING_NV_SCALING_ASPECT_SCALING: _NV_SCALING = 5;
#[doc = "!< For future use"]
pub const _NV_SCALING_NV_SCALING_CUSTOMIZED: _NV_SCALING = 255;
#[doc = "! Scaling modes - used in NvAPI_SetViewEx()."]
#[doc = "! \\ingroup dispcontrol"]
pub type _NV_SCALING = ::std::os::raw::c_int;
#[doc = "! Scaling modes - used in NvAPI_SetViewEx()."]
#[doc = "! \\ingroup dispcontrol"]
pub use self::_NV_SCALING as NV_SCALING;
pub const _NV_ROTATE_NV_ROTATE_0: _NV_ROTATE = 0;
pub const _NV_ROTATE_NV_ROTATE_90: _NV_ROTATE = 1;
pub const _NV_ROTATE_NV_ROTATE_180: _NV_ROTATE = 2;
pub const _NV_ROTATE_NV_ROTATE_270: _NV_ROTATE = 3;
pub const _NV_ROTATE_NV_ROTATE_IGNORED: _NV_ROTATE = 4;
#[doc = "! \\ingroup dispcontrol"]
pub type _NV_ROTATE = ::std::os::raw::c_int;
#[doc = "! \\ingroup dispcontrol"]
pub use self::_NV_ROTATE as NV_ROTATE;
#[doc = "!< unknown. Driver will choose one as following value."]
pub const _NV_FORMAT_NV_FORMAT_UNKNOWN: _NV_FORMAT = 0;
#[doc = "!< for 8bpp mode"]
pub const _NV_FORMAT_NV_FORMAT_P8: _NV_FORMAT = 41;
#[doc = "!< for 16bpp mode"]
pub const _NV_FORMAT_NV_FORMAT_R5G6B5: _NV_FORMAT = 23;
#[doc = "!< for 32bpp mode"]
pub const _NV_FORMAT_NV_FORMAT_A8R8G8B8: _NV_FORMAT = 21;
#[doc = "!< for 64bpp(floating point) mode."]
pub const _NV_FORMAT_NV_FORMAT_A16B16G16R16F: _NV_FORMAT = 113;
#[doc = "! Color formats- used in NvAPI_SetViewEx()."]
#[doc = "! \\ingroup dispcontrol"]
pub type _NV_FORMAT = ::std::os::raw::c_int;
#[doc = "! Color formats- used in NvAPI_SetViewEx()."]
#[doc = "! \\ingroup dispcontrol"]
pub use self::_NV_FORMAT as NV_FORMAT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_VIEWPORTF {
    #[doc = "!<  x-coordinate of the viewport top-left point"]
    pub x: f32,
    #[doc = "!<  y-coordinate of the viewport top-left point"]
    pub y: f32,
    #[doc = "!<  Width of the viewport"]
    pub w: f32,
    #[doc = "!<  Height of the viewport"]
    pub h: f32,
}
#[test]
fn bindgen_test_layout_NV_VIEWPORTF() {
    assert_eq!(
        ::std::mem::size_of::<NV_VIEWPORTF>(),
        16usize,
        concat!("Size of: ", stringify!(NV_VIEWPORTF))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_VIEWPORTF>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_VIEWPORTF))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_VIEWPORTF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_VIEWPORTF),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_VIEWPORTF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_VIEWPORTF),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_VIEWPORTF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_VIEWPORTF),
                "::",
                stringify!(w)
            )
        );
    }
    test_field_w();
    fn test_field_h() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_VIEWPORTF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_VIEWPORTF),
                "::",
                stringify!(h)
            )
        );
    }
    test_field_h();
}
#[doc = "!< get the current timing"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_CURRENT: _NV_TIMING_OVERRIDE = 0;
#[doc = "!< the timing the driver will use based the current policy"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_AUTO: _NV_TIMING_OVERRIDE = 1;
#[doc = "!< EDID timing"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_EDID: _NV_TIMING_OVERRIDE = 2;
#[doc = "!< VESA DMT timing"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_DMT: _NV_TIMING_OVERRIDE = 3;
#[doc = "!< VESA DMT timing with reduced blanking"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_DMT_RB: _NV_TIMING_OVERRIDE = 4;
#[doc = "!< VESA CVT timing"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_CVT: _NV_TIMING_OVERRIDE = 5;
#[doc = "!< VESA CVT timing with reduced blanking"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_CVT_RB: _NV_TIMING_OVERRIDE = 6;
#[doc = "!< VESA GTF timing"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_GTF: _NV_TIMING_OVERRIDE = 7;
#[doc = "!< EIA 861x pre-defined timing"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_EIA861: _NV_TIMING_OVERRIDE = 8;
#[doc = "!< analog SD/HDTV timing"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_ANALOG_TV: _NV_TIMING_OVERRIDE = 9;
#[doc = "!< NV custom timings"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_CUST: _NV_TIMING_OVERRIDE = 10;
#[doc = "!< NV pre-defined timing (basically the PsF timings)"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_NV_PREDEFINED: _NV_TIMING_OVERRIDE = 11;
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_NV_PSF: _NV_TIMING_OVERRIDE = 11;
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_NV_ASPR: _NV_TIMING_OVERRIDE = 12;
#[doc = "!< Override for SDI timing"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_SDI: _NV_TIMING_OVERRIDE = 13;
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVRRIDE_MAX: _NV_TIMING_OVERRIDE = 14;
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! The timing override is not supported yet; must be set to _AUTO. \\n"]
pub type _NV_TIMING_OVERRIDE = ::std::os::raw::c_int;
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! The timing override is not supported yet; must be set to _AUTO. \\n"]
pub use self::_NV_TIMING_OVERRIDE as NV_TIMING_OVERRIDE;
#[doc = "! \\ingroup dispcontrol"]
#[doc = "!  NVIDIA-specific timing extras \\n"]
#[doc = "! Used in NV_TIMING."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagNV_TIMINGEXT {
    #[doc = "!< Reserved for NVIDIA hardware-based enhancement, such as double-scan."]
    pub flag: NvU32,
    #[doc = "!< Logical refresh rate to present"]
    pub rr: NvU16,
    #[doc = "!< Physical vertical refresh rate in 0.001Hz"]
    pub rrx1k: NvU32,
    #[doc = "!< Display aspect ratio Hi(aspect):horizontal-aspect, Low(aspect):vertical-aspect"]
    pub aspect: NvU32,
    #[doc = "!< Bit-wise pixel repetition factor: 0x1:no pixel repetition; 0x2:each pixel repeats twice horizontally,.."]
    pub rep: NvU16,
    #[doc = "!< Timing standard"]
    pub status: NvU32,
    #[doc = "!< Timing name"]
    pub name: [NvU8; 40usize],
}
#[test]
fn bindgen_test_layout_tagNV_TIMINGEXT() {
    assert_eq!(
        ::std::mem::size_of::<tagNV_TIMINGEXT>(),
        64usize,
        concat!("Size of: ", stringify!(tagNV_TIMINGEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<tagNV_TIMINGEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(tagNV_TIMINGEXT))
    );
    fn test_field_flag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tagNV_TIMINGEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flag) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tagNV_TIMINGEXT),
                "::",
                stringify!(flag)
            )
        );
    }
    test_field_flag();
    fn test_field_rr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tagNV_TIMINGEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rr) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(tagNV_TIMINGEXT),
                "::",
                stringify!(rr)
            )
        );
    }
    test_field_rr();
    fn test_field_rrx1k() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tagNV_TIMINGEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rrx1k) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tagNV_TIMINGEXT),
                "::",
                stringify!(rrx1k)
            )
        );
    }
    test_field_rrx1k();
    fn test_field_aspect() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tagNV_TIMINGEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aspect) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(tagNV_TIMINGEXT),
                "::",
                stringify!(aspect)
            )
        );
    }
    test_field_aspect();
    fn test_field_rep() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tagNV_TIMINGEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rep) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(tagNV_TIMINGEXT),
                "::",
                stringify!(rep)
            )
        );
    }
    test_field_rep();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tagNV_TIMINGEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(tagNV_TIMINGEXT),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tagNV_TIMINGEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(tagNV_TIMINGEXT),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
impl Default for tagNV_TIMINGEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup dispcontrol"]
#[doc = "!  NVIDIA-specific timing extras \\n"]
#[doc = "! Used in NV_TIMING."]
pub type NV_TIMINGEXT = tagNV_TIMINGEXT;
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! The very basic timing structure based on the VESA standard:"]
#[doc = "! \\code"]
#[doc = "!            |<----------------------------htotal--------------------------->|"]
#[doc = "!             ---------\"active\" video-------->|<-------blanking------>|<-----"]
#[doc = "!            |<-------hvisible-------->|<-hb->|<-hfp->|<-hsw->|<-hbp->|<-hb->|"]
#[doc = "! --------- -+-------------------------+      |       |       |       |      |"]
#[doc = "!   A      A |                         |      |       |       |       |      |"]
#[doc = "!   :      : |                         |      |       |       |       |      |"]
#[doc = "!   :      : |                         |      |       |       |       |      |"]
#[doc = "!   :vertical|    addressable video    |      |       |       |       |      |"]
#[doc = "!   : visible|                         |      |       |       |       |      |"]
#[doc = "!   :      : |                         |      |       |       |       |      |"]
#[doc = "!   :      : |                         |      |       |       |       |      |"]
#[doc = "! vertical V |                         |      |       |       |       |      |"]
#[doc = "!  total   --+-------------------------+      |       |       |       |      |"]
#[doc = "!   :      vb         border                  |       |       |       |      |"]
#[doc = "!   :      -----------------------------------+       |       |       |      |"]
#[doc = "!   :      vfp        front porch                     |       |       |      |"]
#[doc = "!   :      -------------------------------------------+       |       |      |"]
#[doc = "!   :      vsw        sync width                              |       |      |"]
#[doc = "!   :      ---------------------------------------------------+       |      |"]
#[doc = "!   :      vbp        back porch                                      |      |"]
#[doc = "!   :      -----------------------------------------------------------+      |"]
#[doc = "!   V      vb         border                                                 |"]
#[doc = "! ---------------------------------------------------------------------------+"]
#[doc = "! \\endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_TIMING {
    #[doc = "!< horizontal visible"]
    pub HVisible: NvU16,
    #[doc = "!< horizontal border"]
    pub HBorder: NvU16,
    #[doc = "!< horizontal front porch"]
    pub HFrontPorch: NvU16,
    #[doc = "!< horizontal sync width"]
    pub HSyncWidth: NvU16,
    #[doc = "!< horizontal total"]
    pub HTotal: NvU16,
    #[doc = "!< horizontal sync polarity: 1-negative, 0-positive"]
    pub HSyncPol: NvU8,
    #[doc = "!< vertical visible"]
    pub VVisible: NvU16,
    #[doc = "!< vertical border"]
    pub VBorder: NvU16,
    #[doc = "!< vertical front porch"]
    pub VFrontPorch: NvU16,
    #[doc = "!< vertical sync width"]
    pub VSyncWidth: NvU16,
    #[doc = "!< vertical total"]
    pub VTotal: NvU16,
    #[doc = "!< vertical sync polarity: 1-negative, 0-positive"]
    pub VSyncPol: NvU8,
    #[doc = "!< 1-interlaced, 0-progressive"]
    pub interlaced: NvU16,
    #[doc = "!< pixel clock in 10 kHz"]
    pub pclk: NvU32,
    pub etc: NV_TIMINGEXT,
}
#[test]
fn bindgen_test_layout__NV_TIMING() {
    assert_eq!(
        ::std::mem::size_of::<_NV_TIMING>(),
        96usize,
        concat!("Size of: ", stringify!(_NV_TIMING))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_TIMING>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_TIMING))
    );
    fn test_field_HVisible() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_TIMING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).HVisible) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_TIMING),
                "::",
                stringify!(HVisible)
            )
        );
    }
    test_field_HVisible();
    fn test_field_HBorder() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_TIMING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).HBorder) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_TIMING),
                "::",
                stringify!(HBorder)
            )
        );
    }
    test_field_HBorder();
    fn test_field_HFrontPorch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_TIMING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).HFrontPorch) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_TIMING),
                "::",
                stringify!(HFrontPorch)
            )
        );
    }
    test_field_HFrontPorch();
    fn test_field_HSyncWidth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_TIMING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).HSyncWidth) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_TIMING),
                "::",
                stringify!(HSyncWidth)
            )
        );
    }
    test_field_HSyncWidth();
    fn test_field_HTotal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_TIMING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).HTotal) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_TIMING),
                "::",
                stringify!(HTotal)
            )
        );
    }
    test_field_HTotal();
    fn test_field_HSyncPol() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_TIMING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).HSyncPol) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_TIMING),
                "::",
                stringify!(HSyncPol)
            )
        );
    }
    test_field_HSyncPol();
    fn test_field_VVisible() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_TIMING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).VVisible) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_TIMING),
                "::",
                stringify!(VVisible)
            )
        );
    }
    test_field_VVisible();
    fn test_field_VBorder() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_TIMING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).VBorder) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_TIMING),
                "::",
                stringify!(VBorder)
            )
        );
    }
    test_field_VBorder();
    fn test_field_VFrontPorch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_TIMING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).VFrontPorch) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_TIMING),
                "::",
                stringify!(VFrontPorch)
            )
        );
    }
    test_field_VFrontPorch();
    fn test_field_VSyncWidth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_TIMING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).VSyncWidth) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_TIMING),
                "::",
                stringify!(VSyncWidth)
            )
        );
    }
    test_field_VSyncWidth();
    fn test_field_VTotal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_TIMING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).VTotal) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_TIMING),
                "::",
                stringify!(VTotal)
            )
        );
    }
    test_field_VTotal();
    fn test_field_VSyncPol() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_TIMING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).VSyncPol) as usize - ptr as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_TIMING),
                "::",
                stringify!(VSyncPol)
            )
        );
    }
    test_field_VSyncPol();
    fn test_field_interlaced() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_TIMING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).interlaced) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_TIMING),
                "::",
                stringify!(interlaced)
            )
        );
    }
    test_field_interlaced();
    fn test_field_pclk() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_TIMING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pclk) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_TIMING),
                "::",
                stringify!(pclk)
            )
        );
    }
    test_field_pclk();
    fn test_field_etc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_TIMING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).etc) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_TIMING),
                "::",
                stringify!(etc)
            )
        );
    }
    test_field_etc();
}
impl Default for _NV_TIMING {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! The very basic timing structure based on the VESA standard:"]
#[doc = "! \\code"]
#[doc = "!            |<----------------------------htotal--------------------------->|"]
#[doc = "!             ---------\"active\" video-------->|<-------blanking------>|<-----"]
#[doc = "!            |<-------hvisible-------->|<-hb->|<-hfp->|<-hsw->|<-hbp->|<-hb->|"]
#[doc = "! --------- -+-------------------------+      |       |       |       |      |"]
#[doc = "!   A      A |                         |      |       |       |       |      |"]
#[doc = "!   :      : |                         |      |       |       |       |      |"]
#[doc = "!   :      : |                         |      |       |       |       |      |"]
#[doc = "!   :vertical|    addressable video    |      |       |       |       |      |"]
#[doc = "!   : visible|                         |      |       |       |       |      |"]
#[doc = "!   :      : |                         |      |       |       |       |      |"]
#[doc = "!   :      : |                         |      |       |       |       |      |"]
#[doc = "! vertical V |                         |      |       |       |       |      |"]
#[doc = "!  total   --+-------------------------+      |       |       |       |      |"]
#[doc = "!   :      vb         border                  |       |       |       |      |"]
#[doc = "!   :      -----------------------------------+       |       |       |      |"]
#[doc = "!   :      vfp        front porch                     |       |       |      |"]
#[doc = "!   :      -------------------------------------------+       |       |      |"]
#[doc = "!   :      vsw        sync width                              |       |      |"]
#[doc = "!   :      ---------------------------------------------------+       |      |"]
#[doc = "!   :      vbp        back porch                                      |      |"]
#[doc = "!   :      -----------------------------------------------------------+      |"]
#[doc = "!   V      vb         border                                                 |"]
#[doc = "! ---------------------------------------------------------------------------+"]
#[doc = "! \\endcode"]
pub type NV_TIMING = _NV_TIMING;
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NvAPI_SetView() and NvAPI_GetView()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_VIEW_TARGET_INFO {
    #[doc = "!< (IN) structure version"]
    pub version: NvU32,
    #[doc = "!< (IN) target count"]
    pub count: NvU32,
    pub target: [NV_VIEW_TARGET_INFO__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_VIEW_TARGET_INFO__bindgen_ty_1 {
    #[doc = "!< (IN/OUT) Device mask"]
    pub deviceMask: NvU32,
    #[doc = "!< (IN/OUT) Source ID - values will be based on the number of heads exposed per GPU."]
    pub sourceId: NvU32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_NV_VIEW_TARGET_INFO__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_VIEW_TARGET_INFO__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(NV_VIEW_TARGET_INFO__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_VIEW_TARGET_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_VIEW_TARGET_INFO__bindgen_ty_1)
        )
    );
    fn test_field_deviceMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_VIEW_TARGET_INFO__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceMask) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_VIEW_TARGET_INFO__bindgen_ty_1),
                "::",
                stringify!(deviceMask)
            )
        );
    }
    test_field_deviceMask();
    fn test_field_sourceId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_VIEW_TARGET_INFO__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sourceId) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_VIEW_TARGET_INFO__bindgen_ty_1),
                "::",
                stringify!(sourceId)
            )
        );
    }
    test_field_sourceId();
}
impl NV_VIEW_TARGET_INFO__bindgen_ty_1 {
    #[inline]
    pub fn bPrimary(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bPrimary(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bInterlaced(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bInterlaced(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bGDIPrimary(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bGDIPrimary(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bForceModeSet(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bForceModeSet(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bPrimary: NvU32,
        bInterlaced: NvU32,
        bGDIPrimary: NvU32,
        bForceModeSet: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bPrimary: u32 = unsafe { ::std::mem::transmute(bPrimary) };
            bPrimary as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bInterlaced: u32 = unsafe { ::std::mem::transmute(bInterlaced) };
            bInterlaced as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bGDIPrimary: u32 = unsafe { ::std::mem::transmute(bGDIPrimary) };
            bGDIPrimary as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bForceModeSet: u32 = unsafe { ::std::mem::transmute(bForceModeSet) };
            bForceModeSet as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NV_VIEW_TARGET_INFO() {
    assert_eq!(
        ::std::mem::size_of::<NV_VIEW_TARGET_INFO>(),
        32usize,
        concat!("Size of: ", stringify!(NV_VIEW_TARGET_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_VIEW_TARGET_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_VIEW_TARGET_INFO))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_VIEW_TARGET_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_VIEW_TARGET_INFO),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_VIEW_TARGET_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_VIEW_TARGET_INFO),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_target() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_VIEW_TARGET_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_VIEW_TARGET_INFO),
                "::",
                stringify!(target)
            )
        );
    }
    test_field_target();
}
extern "C" {
    #[doc = "! \\ingroup dispcontrol"]
    pub fn NvAPI_SetView(
        hNvDisplay: NvDisplayHandle,
        pTargetInfo: *mut NV_VIEW_TARGET_INFO,
        targetView: NV_TARGET_VIEW_MODE,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NV_DISPLAY_PATH_INFO."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_DISPLAY_PATH {
    #[doc = "!< (IN) Device mask"]
    pub deviceMask: NvU32,
    #[doc = "!< (IN) Values will be based on the number of heads exposed per GPU(0, 1?)"]
    pub sourceId: NvU32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "!< (IN) Specify connector type. For TV only."]
    pub connector: NV_GPU_CONNECTOR_TYPE,
    #[doc = "!< (IN) Width of the mode"]
    pub width: NvU32,
    #[doc = "!< (IN) Height of the mode"]
    pub height: NvU32,
    #[doc = "!< (IN) Depth of the mode"]
    pub depth: NvU32,
    #[doc = "!<      Color format if it needs to be specified. Not used now."]
    pub colorFormat: NV_FORMAT,
    #[doc = "!< (IN) Rotation setting."]
    pub rotation: NV_ROTATE,
    #[doc = "!< (IN) Scaling setting"]
    pub scaling: NV_SCALING,
    #[doc = "!< (IN) Refresh rate of the mode"]
    pub refreshRate: NvU32,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "!< (IN) To choose the last TV format set this value to NV_DISPLAY_TV_FORMAT_NONE"]
    pub tvFormat: NV_DISPLAY_TV_FORMAT,
    #[doc = "!< (IN/OUT) X-offset of this display on the Windows desktop"]
    pub posx: NvU32,
    #[doc = "!< (IN/OUT) Y-offset of this display on the Windows desktop"]
    pub posy: NvU32,
    pub _bitfield_align_3: [u32; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_NV_DISPLAY_PATH() {
    assert_eq!(
        ::std::mem::size_of::<NV_DISPLAY_PATH>(),
        64usize,
        concat!("Size of: ", stringify!(NV_DISPLAY_PATH))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_DISPLAY_PATH>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_DISPLAY_PATH))
    );
    fn test_field_deviceMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PATH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceMask) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PATH),
                "::",
                stringify!(deviceMask)
            )
        );
    }
    test_field_deviceMask();
    fn test_field_sourceId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PATH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sourceId) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PATH),
                "::",
                stringify!(sourceId)
            )
        );
    }
    test_field_sourceId();
    fn test_field_connector() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PATH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).connector) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PATH),
                "::",
                stringify!(connector)
            )
        );
    }
    test_field_connector();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PATH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PATH),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PATH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PATH),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PATH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PATH),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
    fn test_field_colorFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PATH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PATH),
                "::",
                stringify!(colorFormat)
            )
        );
    }
    test_field_colorFormat();
    fn test_field_rotation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PATH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rotation) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PATH),
                "::",
                stringify!(rotation)
            )
        );
    }
    test_field_rotation();
    fn test_field_scaling() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PATH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scaling) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PATH),
                "::",
                stringify!(scaling)
            )
        );
    }
    test_field_scaling();
    fn test_field_refreshRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PATH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).refreshRate) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PATH),
                "::",
                stringify!(refreshRate)
            )
        );
    }
    test_field_refreshRate();
    fn test_field_tvFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PATH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tvFormat) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PATH),
                "::",
                stringify!(tvFormat)
            )
        );
    }
    test_field_tvFormat();
    fn test_field_posx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PATH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).posx) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PATH),
                "::",
                stringify!(posx)
            )
        );
    }
    test_field_posx();
    fn test_field_posy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PATH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).posy) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PATH),
                "::",
                stringify!(posy)
            )
        );
    }
    test_field_posy();
}
impl Default for NV_DISPLAY_PATH {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl NV_DISPLAY_PATH {
    #[inline]
    pub fn bPrimary(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bPrimary(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(bPrimary: NvU32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bPrimary: u32 = unsafe { ::std::mem::transmute(bPrimary) };
            bPrimary as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn interlaced(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interlaced(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(interlaced: NvU32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interlaced: u32 = unsafe { ::std::mem::transmute(interlaced) };
            interlaced as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn bGDIPrimary(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bGDIPrimary(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bForceModeSet(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bForceModeSet(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bFocusDisplay(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bFocusDisplay(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpuId(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(3usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_gpuId(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(3usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        bGDIPrimary: NvU32,
        bForceModeSet: NvU32,
        bFocusDisplay: NvU32,
        gpuId: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bGDIPrimary: u32 = unsafe { ::std::mem::transmute(bGDIPrimary) };
            bGDIPrimary as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bForceModeSet: u32 = unsafe { ::std::mem::transmute(bForceModeSet) };
            bForceModeSet as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bFocusDisplay: u32 = unsafe { ::std::mem::transmute(bFocusDisplay) };
            bFocusDisplay as u64
        });
        __bindgen_bitfield_unit.set(3usize, 24u8, {
            let gpuId: u32 = unsafe { ::std::mem::transmute(gpuId) };
            gpuId as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NvAPI_SetViewEx() and NvAPI_GetViewEx()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_DISPLAY_PATH_INFO_V3 {
    #[doc = "!< (IN) Structure version"]
    pub version: NvU32,
    #[doc = "!< (IN) Path count"]
    pub count: NvU32,
    pub path: [NV_DISPLAY_PATH; 2usize],
}
#[test]
fn bindgen_test_layout_NV_DISPLAY_PATH_INFO_V3() {
    assert_eq!(
        ::std::mem::size_of::<NV_DISPLAY_PATH_INFO_V3>(),
        136usize,
        concat!("Size of: ", stringify!(NV_DISPLAY_PATH_INFO_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_DISPLAY_PATH_INFO_V3>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_DISPLAY_PATH_INFO_V3))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PATH_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PATH_INFO_V3),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PATH_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PATH_INFO_V3),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PATH_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PATH_INFO_V3),
                "::",
                stringify!(path)
            )
        );
    }
    test_field_path();
}
impl Default for NV_DISPLAY_PATH_INFO_V3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NvAPI_SetViewEx() and NvAPI_GetViewEx()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_DISPLAY_PATH_INFO {
    #[doc = "!< (IN) Structure version"]
    pub version: NvU32,
    #[doc = "!< (IN) Path count"]
    pub count: NvU32,
    pub path: [NV_DISPLAY_PATH; 4usize],
}
#[test]
fn bindgen_test_layout_NV_DISPLAY_PATH_INFO() {
    assert_eq!(
        ::std::mem::size_of::<NV_DISPLAY_PATH_INFO>(),
        264usize,
        concat!("Size of: ", stringify!(NV_DISPLAY_PATH_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_DISPLAY_PATH_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_DISPLAY_PATH_INFO))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PATH_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PATH_INFO),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PATH_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PATH_INFO),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PATH_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PATH_INFO),
                "::",
                stringify!(path)
            )
        );
    }
    test_field_path();
}
impl Default for NV_DISPLAY_PATH_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "! \\ingroup dispcontrol"]
    pub fn NvAPI_SetViewEx(
        hNvDisplay: NvDisplayHandle,
        pPathInfo: *mut NV_DISPLAY_PATH_INFO,
        displayView: NV_TARGET_VIEW_MODE,
    ) -> NvAPI_Status;
}
#[doc = ""]
#[doc = "! \\ingroup dispcontrol"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_POSITION {
    pub x: NvS32,
    pub y: NvS32,
}
#[test]
fn bindgen_test_layout__NV_POSITION() {
    assert_eq!(
        ::std::mem::size_of::<_NV_POSITION>(),
        8usize,
        concat!("Size of: ", stringify!(_NV_POSITION))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_POSITION>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_POSITION))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_POSITION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_POSITION),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_POSITION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_POSITION),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
}
#[doc = ""]
#[doc = "! \\ingroup dispcontrol"]
pub type NV_POSITION = _NV_POSITION;
#[doc = "! \\ingroup dispcontrol"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_RESOLUTION {
    pub width: NvU32,
    pub height: NvU32,
    pub colorDepth: NvU32,
}
#[test]
fn bindgen_test_layout__NV_RESOLUTION() {
    assert_eq!(
        ::std::mem::size_of::<_NV_RESOLUTION>(),
        12usize,
        concat!("Size of: ", stringify!(_NV_RESOLUTION))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_RESOLUTION>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_RESOLUTION))
    );
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_RESOLUTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_RESOLUTION),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_RESOLUTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_RESOLUTION),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_colorDepth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_RESOLUTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorDepth) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_RESOLUTION),
                "::",
                stringify!(colorDepth)
            )
        );
    }
    test_field_colorDepth();
}
#[doc = "! \\ingroup dispcontrol"]
pub type NV_RESOLUTION = _NV_RESOLUTION;
#[doc = "! \\ingroup dispcontrol"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1 {
    pub version: NvU32,
    #[doc = "!< (IN) rotation setting."]
    pub rotation: NV_ROTATE,
    #[doc = "!< (IN) scaling setting."]
    pub scaling: NV_SCALING,
    #[doc = "!< (IN) Non-interlaced Refresh Rate of the mode, multiplied by 1000, 0 = ignored"]
    #[doc = "!< This is the value which driver reports to the OS."]
    pub refreshRate1K: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Specify connector type. For TV only, ignored if tvFormat == NV_DISPLAY_TV_FORMAT_NONE"]
    pub connector: NV_GPU_CONNECTOR_TYPE,
    #[doc = "!< (IN) to choose the last TV format set this value to NV_DISPLAY_TV_FORMAT_NONE"]
    #[doc = "!< In case of NvAPI_DISP_GetDisplayConfig(), this field will indicate the currently applied TV format;"]
    #[doc = "!< if no TV format is applied, this field will have NV_DISPLAY_TV_FORMAT_NONE value."]
    #[doc = "!< In case of NvAPI_DISP_SetDisplayConfig(), this field should only be set in case of TVs;"]
    #[doc = "!< for other displays this field will be ignored and resolution & refresh rate specified in input will be used to apply the TV format."]
    pub tvFormat: NV_DISPLAY_TV_FORMAT,
    #[doc = "!< Ignored if timingOverride == NV_TIMING_OVERRIDE_CURRENT"]
    pub timingOverride: NV_TIMING_OVERRIDE,
    #[doc = "!< Scan out timing, valid only if timingOverride == NV_TIMING_OVERRIDE_CUST"]
    #[doc = "!< The value NV_TIMING::NV_TIMINGEXT::rrx1k is obtained from the EDID. The driver may"]
    #[doc = "!< tweak this value for HDTV, stereo, etc., before reporting it to the OS."]
    pub timing: NV_TIMING,
}
#[test]
fn bindgen_test_layout__NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_rotation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rotation) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1),
                "::",
                stringify!(rotation)
            )
        );
    }
    test_field_rotation();
    fn test_field_scaling() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scaling) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1),
                "::",
                stringify!(scaling)
            )
        );
    }
    test_field_scaling();
    fn test_field_refreshRate1K() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).refreshRate1K) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1),
                "::",
                stringify!(refreshRate1K)
            )
        );
    }
    test_field_refreshRate1K();
    fn test_field_connector() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).connector) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1),
                "::",
                stringify!(connector)
            )
        );
    }
    test_field_connector();
    fn test_field_tvFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tvFormat) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1),
                "::",
                stringify!(tvFormat)
            )
        );
    }
    test_field_tvFormat();
    fn test_field_timingOverride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timingOverride) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1),
                "::",
                stringify!(timingOverride)
            )
        );
    }
    test_field_timingOverride();
    fn test_field_timing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timing) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1),
                "::",
                stringify!(timing)
            )
        );
    }
    test_field_timing();
}
impl Default for _NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1 {
    #[inline]
    pub fn interlaced(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interlaced(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn primary(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_primary(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBit1(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBit1(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableVirtualModeSupport(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableVirtualModeSupport(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isPreferredUnscaledTarget(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isPreferredUnscaledTarget(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        interlaced: NvU32,
        primary: NvU32,
        reservedBit1: NvU32,
        disableVirtualModeSupport: NvU32,
        isPreferredUnscaledTarget: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interlaced: u32 = unsafe { ::std::mem::transmute(interlaced) };
            interlaced as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let primary: u32 = unsafe { ::std::mem::transmute(primary) };
            primary as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let reservedBit1: u32 = unsafe { ::std::mem::transmute(reservedBit1) };
            reservedBit1 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let disableVirtualModeSupport: u32 =
                unsafe { ::std::mem::transmute(disableVirtualModeSupport) };
            disableVirtualModeSupport as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isPreferredUnscaledTarget: u32 =
                unsafe { ::std::mem::transmute(isPreferredUnscaledTarget) };
            isPreferredUnscaledTarget as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! \\ingroup dispcontrol"]
pub type NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1 =
    _NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1;
#[doc = "! \\ingroup dispcontrol"]
pub type NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO = NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1;
#[doc = "! \\ingroup dispcontrol"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1 {
    #[doc = "!< Display ID"]
    pub displayId: NvU32,
    #[doc = "!< May be NULL if no advanced settings are required. NULL for Non-NVIDIA Display."]
    pub details: *mut NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO,
}
#[test]
fn bindgen_test_layout__NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1)
        )
    );
    fn test_field_displayId() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayId) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1),
                "::",
                stringify!(displayId)
            )
        );
    }
    test_field_displayId();
    fn test_field_details() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).details) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1),
                "::",
                stringify!(details)
            )
        );
    }
    test_field_details();
}
impl Default for _NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup dispcontrol"]
pub type NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1 = _NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1;
#[doc = "! \\ingroup dispcontrol"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2 {
    #[doc = "!< Display ID"]
    pub displayId: NvU32,
    #[doc = "!< May be NULL if no advanced settings are required"]
    pub details: *mut NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO,
    #[doc = "!< Windows CCD target ID. Must be present only for non-NVIDIA adapter, for NVIDIA adapter this parameter is ignored."]
    pub targetId: NvU32,
}
#[test]
fn bindgen_test_layout__NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2() {
    assert_eq!(
        ::std::mem::size_of::<_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2)
        )
    );
    fn test_field_displayId() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayId) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2),
                "::",
                stringify!(displayId)
            )
        );
    }
    test_field_displayId();
    fn test_field_details() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).details) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2),
                "::",
                stringify!(details)
            )
        );
    }
    test_field_details();
    fn test_field_targetId() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).targetId) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2),
                "::",
                stringify!(targetId)
            )
        );
    }
    test_field_targetId();
}
impl Default for _NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup dispcontrol"]
pub type NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2 = _NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2;
#[doc = "! \\ingroup dispcontrol"]
pub type NV_DISPLAYCONFIG_PATH_TARGET_INFO = NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2;
pub const _NV_DISPLAYCONFIG_SPANNING_ORIENTATION_NV_DISPLAYCONFIG_SPAN_NONE:
    _NV_DISPLAYCONFIG_SPANNING_ORIENTATION = 0;
pub const _NV_DISPLAYCONFIG_SPANNING_ORIENTATION_NV_DISPLAYCONFIG_SPAN_HORIZONTAL:
    _NV_DISPLAYCONFIG_SPANNING_ORIENTATION = 1;
pub const _NV_DISPLAYCONFIG_SPANNING_ORIENTATION_NV_DISPLAYCONFIG_SPAN_VERTICAL:
    _NV_DISPLAYCONFIG_SPANNING_ORIENTATION = 2;
#[doc = "! \\ingroup dispcontrol"]
pub type _NV_DISPLAYCONFIG_SPANNING_ORIENTATION = ::std::os::raw::c_int;
#[doc = "! \\ingroup dispcontrol"]
pub use self::_NV_DISPLAYCONFIG_SPANNING_ORIENTATION as NV_DISPLAYCONFIG_SPANNING_ORIENTATION;
#[doc = "! \\ingroup dispcontrol"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1 {
    pub resolution: NV_RESOLUTION,
    #[doc = "!< Ignored at present, must be NV_FORMAT_UNKNOWN (0)"]
    pub colorFormat: NV_FORMAT,
    #[doc = "!< Is all positions are 0 or invalid, displays will be automatically"]
    #[doc = "!< positioned from left to right with GDI Primary at 0,0, and all"]
    #[doc = "!< other displays in the order of the path array."]
    pub position: NV_POSITION,
    #[doc = "!< Spanning is only supported on XP"]
    pub spanningOrientation: NV_DISPLAYCONFIG_SPANNING_ORIENTATION,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1)
        )
    );
    fn test_field_resolution() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resolution) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1),
                "::",
                stringify!(resolution)
            )
        );
    }
    test_field_resolution();
    fn test_field_colorFormat() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1),
                "::",
                stringify!(colorFormat)
            )
        );
    }
    test_field_colorFormat();
    fn test_field_position() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1),
                "::",
                stringify!(position)
            )
        );
    }
    test_field_position();
    fn test_field_spanningOrientation() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).spanningOrientation) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1),
                "::",
                stringify!(spanningOrientation)
            )
        );
    }
    test_field_spanningOrientation();
}
impl Default for _NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1 {
    #[inline]
    pub fn bGDIPrimary(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bGDIPrimary(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bSLIFocus(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bSLIFocus(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bGDIPrimary: NvU32,
        bSLIFocus: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bGDIPrimary: u32 = unsafe { ::std::mem::transmute(bGDIPrimary) };
            bGDIPrimary as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bSLIFocus: u32 = unsafe { ::std::mem::transmute(bSLIFocus) };
            bSLIFocus as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! \\ingroup dispcontrol"]
pub type NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1 = _NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1;
#[doc = "! \\ingroup dispcontrol"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_DISPLAYCONFIG_PATH_INFO_V1 {
    pub version: NvU32,
    #[doc = "!< This field is reserved. There is ongoing debate if we need this field."]
    #[doc = "!< Identifies sourceIds used by Windows. If all sourceIds are 0,"]
    #[doc = "!< these will be computed automatically."]
    pub reserved_sourceId: NvU32,
    #[doc = "!< Number of elements in targetInfo array"]
    pub targetInfoCount: NvU32,
    pub targetInfo: *mut NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1,
    #[doc = "!< May be NULL if mode info is not important"]
    pub sourceModeInfo: *mut NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1,
}
#[test]
fn bindgen_test_layout__NV_DISPLAYCONFIG_PATH_INFO_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_DISPLAYCONFIG_PATH_INFO_V1>(),
        32usize,
        concat!("Size of: ", stringify!(_NV_DISPLAYCONFIG_PATH_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_DISPLAYCONFIG_PATH_INFO_V1>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_DISPLAYCONFIG_PATH_INFO_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAYCONFIG_PATH_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_INFO_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_reserved_sourceId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAYCONFIG_PATH_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved_sourceId) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_INFO_V1),
                "::",
                stringify!(reserved_sourceId)
            )
        );
    }
    test_field_reserved_sourceId();
    fn test_field_targetInfoCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAYCONFIG_PATH_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).targetInfoCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_INFO_V1),
                "::",
                stringify!(targetInfoCount)
            )
        );
    }
    test_field_targetInfoCount();
    fn test_field_targetInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAYCONFIG_PATH_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).targetInfo) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_INFO_V1),
                "::",
                stringify!(targetInfo)
            )
        );
    }
    test_field_targetInfo();
    fn test_field_sourceModeInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAYCONFIG_PATH_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sourceModeInfo) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_INFO_V1),
                "::",
                stringify!(sourceModeInfo)
            )
        );
    }
    test_field_sourceModeInfo();
}
impl Default for _NV_DISPLAYCONFIG_PATH_INFO_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup dispcontrol"]
pub type NV_DISPLAYCONFIG_PATH_INFO_V1 = _NV_DISPLAYCONFIG_PATH_INFO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_DISPLAYCONFIG_PATH_INFO {
    pub version: NvU32,
    pub __bindgen_anon_1: _NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1,
    #[doc = "!< Number of elements in targetInfo array"]
    pub targetInfoCount: NvU32,
    pub targetInfo: *mut NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2,
    #[doc = "!< May be NULL if mode info is not important"]
    pub sourceModeInfo: *mut NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Used by Non-NVIDIA adapter for pointer to OS Adapter of LUID"]
    #[doc = "!< type, type casted to void *."]
    pub pOSAdapterID: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1 {
    #[doc = "!< Identifies sourceId used by Windows CCD. This can be optionally set."]
    pub sourceId: NvU32,
    #[doc = "!< Only for compatibility"]
    pub reserved_sourceId: NvU32,
}
#[test]
fn bindgen_test_layout__NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1)
        )
    );
    fn test_field_sourceId() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sourceId) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1),
                "::",
                stringify!(sourceId)
            )
        );
    }
    test_field_sourceId();
    fn test_field_reserved_sourceId() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved_sourceId) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1),
                "::",
                stringify!(reserved_sourceId)
            )
        );
    }
    test_field_reserved_sourceId();
}
impl Default for _NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__NV_DISPLAYCONFIG_PATH_INFO() {
    assert_eq!(
        ::std::mem::size_of::<_NV_DISPLAYCONFIG_PATH_INFO>(),
        48usize,
        concat!("Size of: ", stringify!(_NV_DISPLAYCONFIG_PATH_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_DISPLAYCONFIG_PATH_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_DISPLAYCONFIG_PATH_INFO))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAYCONFIG_PATH_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_INFO),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_targetInfoCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAYCONFIG_PATH_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).targetInfoCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_INFO),
                "::",
                stringify!(targetInfoCount)
            )
        );
    }
    test_field_targetInfoCount();
    fn test_field_targetInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAYCONFIG_PATH_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).targetInfo) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_INFO),
                "::",
                stringify!(targetInfo)
            )
        );
    }
    test_field_targetInfo();
    fn test_field_sourceModeInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAYCONFIG_PATH_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sourceModeInfo) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_INFO),
                "::",
                stringify!(sourceModeInfo)
            )
        );
    }
    test_field_sourceModeInfo();
    fn test_field_pOSAdapterID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAYCONFIG_PATH_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pOSAdapterID) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAYCONFIG_PATH_INFO),
                "::",
                stringify!(pOSAdapterID)
            )
        );
    }
    test_field_pOSAdapterID();
}
impl Default for _NV_DISPLAYCONFIG_PATH_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_DISPLAYCONFIG_PATH_INFO {
    #[inline]
    pub fn IsNonNVIDIAAdapter(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsNonNVIDIAAdapter(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IsNonNVIDIAAdapter: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IsNonNVIDIAAdapter: u32 = unsafe { ::std::mem::transmute(IsNonNVIDIAAdapter) };
            IsNonNVIDIAAdapter as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! \\ingroup dispcontrol"]
pub type NV_DISPLAYCONFIG_PATH_INFO_V2 = _NV_DISPLAYCONFIG_PATH_INFO;
pub type NV_DISPLAYCONFIG_PATH_INFO = NV_DISPLAYCONFIG_PATH_INFO_V2;
#[doc = "! \\ingroup dispcontrol"]
pub type NV_DISPLAYCONFIG_SOURCE_MODE_INFO = NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1;
pub const _NV_DISPLAYCONFIG_FLAGS_NV_DISPLAYCONFIG_VALIDATE_ONLY: _NV_DISPLAYCONFIG_FLAGS = 1;
pub const _NV_DISPLAYCONFIG_FLAGS_NV_DISPLAYCONFIG_SAVE_TO_PERSISTENCE: _NV_DISPLAYCONFIG_FLAGS = 2;
#[doc = "!< Driver reload is permitted if necessary"]
pub const _NV_DISPLAYCONFIG_FLAGS_NV_DISPLAYCONFIG_DRIVER_RELOAD_ALLOWED: _NV_DISPLAYCONFIG_FLAGS =
    4;
#[doc = "!< Refresh OS mode list."]
pub const _NV_DISPLAYCONFIG_FLAGS_NV_DISPLAYCONFIG_FORCE_MODE_ENUMERATION: _NV_DISPLAYCONFIG_FLAGS =
    8;
#[doc = "!< Tell OS to avoid optimizing CommitVidPn call during a modeset"]
pub const _NV_DISPLAYCONFIG_FLAGS_NV_FORCE_COMMIT_VIDPN: _NV_DISPLAYCONFIG_FLAGS = 16;
#[doc = "! \\ingroup dispcontrol"]
pub type _NV_DISPLAYCONFIG_FLAGS = ::std::os::raw::c_int;
#[doc = "! \\ingroup dispcontrol"]
pub use self::_NV_DISPLAYCONFIG_FLAGS as NV_DISPLAYCONFIG_FLAGS;
pub type NvAPI_UnicodeString = [NvU16; 2048usize];
pub type NvAPI_LPCWSTR = *const NvU16;
pub const _NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID_NVAPI_GPU_PERF_VOLTAGE_INFO_DOMAIN_CORE:
    _NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID = 0;
pub const _NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID_NVAPI_GPU_PERF_VOLTAGE_INFO_DOMAIN_UNDEFINED:
    _NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID = 16;
#[doc = "! \\ingroup gpuclock"]
pub type _NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpuclock"]
pub use self::_NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID as NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID;
pub const _NV_GPU_PUBLIC_CLOCK_ID_NVAPI_GPU_PUBLIC_CLOCK_GRAPHICS: _NV_GPU_PUBLIC_CLOCK_ID = 0;
pub const _NV_GPU_PUBLIC_CLOCK_ID_NVAPI_GPU_PUBLIC_CLOCK_MEMORY: _NV_GPU_PUBLIC_CLOCK_ID = 4;
pub const _NV_GPU_PUBLIC_CLOCK_ID_NVAPI_GPU_PUBLIC_CLOCK_PROCESSOR: _NV_GPU_PUBLIC_CLOCK_ID = 7;
pub const _NV_GPU_PUBLIC_CLOCK_ID_NVAPI_GPU_PUBLIC_CLOCK_VIDEO: _NV_GPU_PUBLIC_CLOCK_ID = 8;
pub const _NV_GPU_PUBLIC_CLOCK_ID_NVAPI_GPU_PUBLIC_CLOCK_UNDEFINED: _NV_GPU_PUBLIC_CLOCK_ID = 32;
#[doc = "! \\ingroup gpuclock"]
pub type _NV_GPU_PUBLIC_CLOCK_ID = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpuclock"]
pub use self::_NV_GPU_PUBLIC_CLOCK_ID as NV_GPU_PUBLIC_CLOCK_ID;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P0: _NV_GPU_PERF_PSTATE_ID = 0;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P1: _NV_GPU_PERF_PSTATE_ID = 1;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P2: _NV_GPU_PERF_PSTATE_ID = 2;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P3: _NV_GPU_PERF_PSTATE_ID = 3;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P4: _NV_GPU_PERF_PSTATE_ID = 4;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P5: _NV_GPU_PERF_PSTATE_ID = 5;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P6: _NV_GPU_PERF_PSTATE_ID = 6;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P7: _NV_GPU_PERF_PSTATE_ID = 7;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P8: _NV_GPU_PERF_PSTATE_ID = 8;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P9: _NV_GPU_PERF_PSTATE_ID = 9;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P10: _NV_GPU_PERF_PSTATE_ID = 10;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P11: _NV_GPU_PERF_PSTATE_ID = 11;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P12: _NV_GPU_PERF_PSTATE_ID = 12;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P13: _NV_GPU_PERF_PSTATE_ID = 13;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P14: _NV_GPU_PERF_PSTATE_ID = 14;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P15: _NV_GPU_PERF_PSTATE_ID = 15;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_UNDEFINED: _NV_GPU_PERF_PSTATE_ID = 16;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_ALL: _NV_GPU_PERF_PSTATE_ID = 17;
#[doc = "! \\addtogroup gpupstate"]
#[doc = "! @{"]
pub type _NV_GPU_PERF_PSTATE_ID = ::std::os::raw::c_int;
#[doc = "! \\addtogroup gpupstate"]
#[doc = "! @{"]
pub use self::_NV_GPU_PERF_PSTATE_ID as NV_GPU_PERF_PSTATE_ID;
#[doc = "! Clock domains that use single frequency value within given pstate"]
pub const NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID_NVAPI_GPU_PERF_PSTATE20_CLOCK_TYPE_SINGLE:
    NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID = 0;
#[doc = "! Clock domains that allow range of frequency values within given pstate"]
pub const NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID_NVAPI_GPU_PERF_PSTATE20_CLOCK_TYPE_RANGE:
    NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID = 1;
#[doc = "! Used to identify clock type"]
pub type NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID = ::std::os::raw::c_int;
#[doc = "! Used to describe both voltage and frequency deltas"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES20_PARAM_DELTA {
    #[doc = "! Value of parameter delta (in respective units [kHz, uV])"]
    pub value: NvS32,
    pub valueRange: NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1 {
    #[doc = "! Min value allowed for parameter delta (in respective units [kHz, uV])"]
    pub min: NvS32,
    #[doc = "! Max value allowed for parameter delta (in respective units [kHz, uV])"]
    pub max: NvS32,
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1)
        )
    );
    fn test_field_min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1),
                "::",
                stringify!(min)
            )
        );
    }
    test_field_min();
    fn test_field_max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1),
                "::",
                stringify!(max)
            )
        );
    }
    test_field_max();
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES20_PARAM_DELTA() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES20_PARAM_DELTA>(),
        12usize,
        concat!("Size of: ", stringify!(NV_GPU_PERF_PSTATES20_PARAM_DELTA))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES20_PARAM_DELTA>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PERF_PSTATES20_PARAM_DELTA)
        )
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES20_PARAM_DELTA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES20_PARAM_DELTA),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_valueRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES20_PARAM_DELTA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).valueRange) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES20_PARAM_DELTA),
                "::",
                stringify!(valueRange)
            )
        );
    }
    test_field_valueRange();
}
#[doc = "! Used to describe single clock entry"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_PSTATE20_CLOCK_ENTRY_V1 {
    #[doc = "! ID of the clock domain"]
    pub domainId: NV_GPU_PUBLIC_CLOCK_ID,
    #[doc = "! Clock type ID"]
    pub typeId: NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "! Current frequency delta from nominal settings in (kHz)"]
    pub freqDelta_kHz: NV_GPU_PERF_PSTATES20_PARAM_DELTA,
    pub data: NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1,
}
#[doc = "! Clock domain type dependant information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1 {
    pub single: NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_1,
    pub range: NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "! Clock frequency within given pstate in (kHz)"]
    pub freq_kHz: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_freq_kHz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).freq_kHz) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(freq_kHz)
            )
        );
    }
    test_field_freq_kHz();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "! Min clock frequency within given pstate in (kHz)"]
    pub minFreq_kHz: NvU32,
    #[doc = "! Max clock frequency within given pstate in (kHz)"]
    pub maxFreq_kHz: NvU32,
    #[doc = "! Voltage domain ID and value range in (uV) required for this clock"]
    pub domainId: NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID,
    pub minVoltage_uV: NvU32,
    pub maxVoltage_uV: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_minFreq_kHz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minFreq_kHz) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(minFreq_kHz)
            )
        );
    }
    test_field_minFreq_kHz();
    fn test_field_maxFreq_kHz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxFreq_kHz) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(maxFreq_kHz)
            )
        );
    }
    test_field_maxFreq_kHz();
    fn test_field_domainId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).domainId) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(domainId)
            )
        );
    }
    test_field_domainId();
    fn test_field_minVoltage_uV() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minVoltage_uV) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(minVoltage_uV)
            )
        );
    }
    test_field_minVoltage_uV();
    fn test_field_maxVoltage_uV() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxVoltage_uV) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(maxVoltage_uV)
            )
        );
    }
    test_field_maxVoltage_uV();
}
impl Default for NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1)
        )
    );
    fn test_field_single() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).single) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1),
                "::",
                stringify!(single)
            )
        );
    }
    test_field_single();
    fn test_field_range() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1),
                "::",
                stringify!(range)
            )
        );
    }
    test_field_range();
}
impl Default for NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NV_GPU_PSTATE20_CLOCK_ENTRY_V1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1>(),
        44usize,
        concat!("Size of: ", stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1))
    );
    fn test_field_domainId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).domainId) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1),
                "::",
                stringify!(domainId)
            )
        );
    }
    test_field_domainId();
    fn test_field_typeId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).typeId) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1),
                "::",
                stringify!(typeId)
            )
        );
    }
    test_field_typeId();
    fn test_field_freqDelta_kHz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).freqDelta_kHz) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1),
                "::",
                stringify!(freqDelta_kHz)
            )
        );
    }
    test_field_freqDelta_kHz();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
impl Default for NV_GPU_PSTATE20_CLOCK_ENTRY_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl NV_GPU_PSTATE20_CLOCK_ENTRY_V1 {
    #[inline]
    pub fn bIsEditable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsEditable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsEditable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsEditable: u32 = unsafe { ::std::mem::transmute(bIsEditable) };
            bIsEditable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! Used to describe single base voltage entry"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1 {
    #[doc = "! ID of the voltage domain"]
    pub domainId: NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "! Current base voltage settings in [uV]"]
    pub volt_uV: NvU32,
    pub voltDelta_uV: NV_GPU_PERF_PSTATES20_PARAM_DELTA,
}
#[test]
fn bindgen_test_layout_NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1)
        )
    );
    fn test_field_domainId() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).domainId) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1),
                "::",
                stringify!(domainId)
            )
        );
    }
    test_field_domainId();
    fn test_field_volt_uV() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).volt_uV) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1),
                "::",
                stringify!(volt_uV)
            )
        );
    }
    test_field_volt_uV();
    fn test_field_voltDelta_uV() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).voltDelta_uV) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1),
                "::",
                stringify!(voltDelta_uV)
            )
        );
    }
    test_field_voltDelta_uV();
}
impl Default for NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1 {
    #[inline]
    pub fn bIsEditable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsEditable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsEditable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsEditable: u32 = unsafe { ::std::mem::transmute(bIsEditable) };
            bIsEditable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! Used in NvAPI_GPU_GetPstates20() interface call."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES20_INFO_V1 {
    #[doc = "! Version info of the structure (NV_GPU_PERF_PSTATES20_INFO_VER<n>)"]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "! Number of populated pstates"]
    pub numPstates: NvU32,
    #[doc = "! Number of populated clocks (per pstate)"]
    pub numClocks: NvU32,
    #[doc = "! Number of populated base voltages (per pstate)"]
    pub numBaseVoltages: NvU32,
    pub pstates: [NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1; 16usize],
}
#[doc = "! Performance state (P-State) settings"]
#[doc = "! Valid index range is 0 to numPstates-1"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1 {
    #[doc = "! ID of the P-State"]
    pub pstateId: NV_GPU_PERF_PSTATE_ID,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "! Array of clock entries"]
    #[doc = "! Valid index range is 0 to numClocks-1"]
    pub clocks: [NV_GPU_PSTATE20_CLOCK_ENTRY_V1; 8usize],
    #[doc = "! Array of baseVoltage entries"]
    #[doc = "! Valid index range is 0 to numBaseVoltages-1"]
    pub baseVoltages: [NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1; 4usize],
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1>(),
        456usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1)
        )
    );
    fn test_field_pstateId() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pstateId) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1),
                "::",
                stringify!(pstateId)
            )
        );
    }
    test_field_pstateId();
    fn test_field_clocks() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clocks) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1),
                "::",
                stringify!(clocks)
            )
        );
    }
    test_field_clocks();
    fn test_field_baseVoltages() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).baseVoltages) as usize - ptr as usize
            },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1),
                "::",
                stringify!(baseVoltages)
            )
        );
    }
    test_field_baseVoltages();
}
impl Default for NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1 {
    #[inline]
    pub fn bIsEditable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsEditable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsEditable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsEditable: u32 = unsafe { ::std::mem::transmute(bIsEditable) };
            bIsEditable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES20_INFO_V1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES20_INFO_V1>(),
        7316usize,
        concat!("Size of: ", stringify!(NV_GPU_PERF_PSTATES20_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES20_INFO_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_PERF_PSTATES20_INFO_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES20_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES20_INFO_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_numPstates() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES20_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numPstates) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES20_INFO_V1),
                "::",
                stringify!(numPstates)
            )
        );
    }
    test_field_numPstates();
    fn test_field_numClocks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES20_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numClocks) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES20_INFO_V1),
                "::",
                stringify!(numClocks)
            )
        );
    }
    test_field_numClocks();
    fn test_field_numBaseVoltages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES20_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numBaseVoltages) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES20_INFO_V1),
                "::",
                stringify!(numBaseVoltages)
            )
        );
    }
    test_field_numBaseVoltages();
    fn test_field_pstates() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES20_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pstates) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES20_INFO_V1),
                "::",
                stringify!(pstates)
            )
        );
    }
    test_field_pstates();
}
impl Default for NV_GPU_PERF_PSTATES20_INFO_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl NV_GPU_PERF_PSTATES20_INFO_V1 {
    #[inline]
    pub fn bIsEditable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsEditable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsEditable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsEditable: u32 = unsafe { ::std::mem::transmute(bIsEditable) };
            bIsEditable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! Used in NvAPI_GPU_GetPstates20() interface call."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_PERF_PSTATES20_INFO_V2 {
    #[doc = "! Version info of the structure (NV_GPU_PERF_PSTATES20_INFO_VER<n>)"]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "! Number of populated pstates"]
    pub numPstates: NvU32,
    #[doc = "! Number of populated clocks (per pstate)"]
    pub numClocks: NvU32,
    #[doc = "! Number of populated base voltages (per pstate)"]
    pub numBaseVoltages: NvU32,
    pub pstates: [_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1; 16usize],
    pub ov: _NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2,
}
#[doc = "! Performance state (P-State) settings"]
#[doc = "! Valid index range is 0 to numPstates-1"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1 {
    #[doc = "! ID of the P-State"]
    pub pstateId: NV_GPU_PERF_PSTATE_ID,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "! Array of clock entries"]
    #[doc = "! Valid index range is 0 to numClocks-1"]
    pub clocks: [NV_GPU_PSTATE20_CLOCK_ENTRY_V1; 8usize],
    #[doc = "! Array of baseVoltage entries"]
    #[doc = "! Valid index range is 0 to numBaseVoltages-1"]
    pub baseVoltages: [NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1; 4usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1>(),
        456usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1)
        )
    );
    fn test_field_pstateId() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pstateId) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1),
                "::",
                stringify!(pstateId)
            )
        );
    }
    test_field_pstateId();
    fn test_field_clocks() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clocks) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1),
                "::",
                stringify!(clocks)
            )
        );
    }
    test_field_clocks();
    fn test_field_baseVoltages() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).baseVoltages) as usize - ptr as usize
            },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1),
                "::",
                stringify!(baseVoltages)
            )
        );
    }
    test_field_baseVoltages();
}
impl Default for _NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1 {
    #[inline]
    pub fn bIsEditable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsEditable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsEditable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsEditable: u32 = unsafe { ::std::mem::transmute(bIsEditable) };
            bIsEditable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! OV settings - Please refer to NVIDIA over-volting recommendation to understand impact of this functionality"]
#[doc = "! Valid index range is 0 to numVoltages-1"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2 {
    #[doc = "! Number of populated voltages"]
    pub numVoltages: NvU32,
    #[doc = "! Array of voltage entries"]
    #[doc = "! Valid index range is 0 to numVoltages-1"]
    pub voltages: [NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1; 4usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2>(),
        100usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2)
        )
    );
    fn test_field_numVoltages() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numVoltages) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2),
                "::",
                stringify!(numVoltages)
            )
        );
    }
    test_field_numVoltages();
    fn test_field_voltages() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).voltages) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2),
                "::",
                stringify!(voltages)
            )
        );
    }
    test_field_voltages();
}
impl Default for _NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__NV_GPU_PERF_PSTATES20_INFO_V2() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_PERF_PSTATES20_INFO_V2>(),
        7416usize,
        concat!("Size of: ", stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_PERF_PSTATES20_INFO_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_PERF_PSTATES20_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_numPstates() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_PERF_PSTATES20_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numPstates) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2),
                "::",
                stringify!(numPstates)
            )
        );
    }
    test_field_numPstates();
    fn test_field_numClocks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_PERF_PSTATES20_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numClocks) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2),
                "::",
                stringify!(numClocks)
            )
        );
    }
    test_field_numClocks();
    fn test_field_numBaseVoltages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_PERF_PSTATES20_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numBaseVoltages) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2),
                "::",
                stringify!(numBaseVoltages)
            )
        );
    }
    test_field_numBaseVoltages();
    fn test_field_pstates() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_PERF_PSTATES20_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pstates) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2),
                "::",
                stringify!(pstates)
            )
        );
    }
    test_field_pstates();
    fn test_field_ov() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_PERF_PSTATES20_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ov) as usize - ptr as usize
            },
            7316usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2),
                "::",
                stringify!(ov)
            )
        );
    }
    test_field_ov();
}
impl Default for _NV_GPU_PERF_PSTATES20_INFO_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_GPU_PERF_PSTATES20_INFO_V2 {
    #[inline]
    pub fn bIsEditable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsEditable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsEditable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsEditable: u32 = unsafe { ::std::mem::transmute(bIsEditable) };
            bIsEditable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! Used in NvAPI_GPU_GetPstates20() interface call."]
pub type NV_GPU_PERF_PSTATES20_INFO_V2 = _NV_GPU_PERF_PSTATES20_INFO_V2;
#[doc = "! Used in NvAPI_GPU_GetPstates20() interface call."]
pub type NV_GPU_PERF_PSTATES20_INFO = NV_GPU_PERF_PSTATES20_INFO_V2;
#[doc = "! \\ingroup driverapi"]
#[doc = "! Used in NvAPI_GetDisplayDriverVersion()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_DISPLAY_DRIVER_VERSION {
    pub version: NvU32,
    pub drvVersion: NvU32,
    pub bldChangeListNum: NvU32,
    pub szBuildBranchString: NvAPI_ShortString,
    pub szAdapterString: NvAPI_ShortString,
}
#[test]
fn bindgen_test_layout_NV_DISPLAY_DRIVER_VERSION() {
    assert_eq!(
        ::std::mem::size_of::<NV_DISPLAY_DRIVER_VERSION>(),
        140usize,
        concat!("Size of: ", stringify!(NV_DISPLAY_DRIVER_VERSION))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_DISPLAY_DRIVER_VERSION>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_DISPLAY_DRIVER_VERSION))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_VERSION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_VERSION),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_drvVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_VERSION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drvVersion) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_VERSION),
                "::",
                stringify!(drvVersion)
            )
        );
    }
    test_field_drvVersion();
    fn test_field_bldChangeListNum() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_VERSION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bldChangeListNum) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_VERSION),
                "::",
                stringify!(bldChangeListNum)
            )
        );
    }
    test_field_bldChangeListNum();
    fn test_field_szBuildBranchString() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_VERSION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).szBuildBranchString) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_VERSION),
                "::",
                stringify!(szBuildBranchString)
            )
        );
    }
    test_field_szBuildBranchString();
    fn test_field_szAdapterString() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_DRIVER_VERSION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).szAdapterString) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_DRIVER_VERSION),
                "::",
                stringify!(szAdapterString)
            )
        );
    }
    test_field_szAdapterString();
}
impl Default for NV_DISPLAY_DRIVER_VERSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "! \\ingroup driverapi"]
    pub fn NvAPI_GetDisplayDriverVersion(
        hNvDisplay: NvDisplayHandle,
        pVersion: *mut NV_DISPLAY_DRIVER_VERSION,
    ) -> NvAPI_Status;
}
#[doc = "!   DESCRIPTION: Used in conjunction with OUTPUT_TO_CALLBACK, this is a simple"]
#[doc = "!                callback function the user may use to obtain the feedback"]
#[doc = "!                stream. The function will be called once per fully qualified"]
#[doc = "!                feedback stream entry."]
#[doc = "!"]
#[doc = "!   \\param   categoryId    Contains the bit from the NVAPI_OGLEXPERT_REPORT"]
#[doc = "!                          mask that corresponds to the current message"]
#[doc = "!   \\param   messageId     Unique ID for the current message"]
#[doc = "!   \\param   detailLevel   Contains the bit from the NVAPI_OGLEXPERT_DETAIL"]
#[doc = "!                          mask that corresponds to the current message"]
#[doc = "!   \\param   objectId      Unique ID of the object that corresponds to the"]
#[doc = "!                          current message"]
#[doc = "!   \\param   messageStr    Text string from the current message"]
#[doc = "!"]
#[doc = "!   \\ingroup oglapi"]
#[doc = ""]
pub type NVAPI_OGLEXPERT_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        categoryId: ::std::os::raw::c_uint,
        messageId: ::std::os::raw::c_uint,
        detailLevel: ::std::os::raw::c_uint,
        objectId: ::std::os::raw::c_int,
        messageStr: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    #[doc = "! \\ingroup oglapi"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    pub fn NvAPI_OGL_ExpertModeSet(
        expertDetailLevel: NvU32,
        expertReportMask: NvU32,
        expertOutputMask: NvU32,
        expertCallback: NVAPI_OGLEXPERT_CALLBACK,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! \\addtogroup oglapi"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    pub fn NvAPI_OGL_ExpertModeGet(
        pExpertDetailLevel: *mut NvU32,
        pExpertReportMask: *mut NvU32,
        pExpertOutputMask: *mut NvU32,
        pExpertCallback: *mut NVAPI_OGLEXPERT_CALLBACK,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! \\ingroup oglapi"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    pub fn NvAPI_OGL_ExpertModeDefaultsSet(
        expertDetailLevel: NvU32,
        expertReportMask: NvU32,
        expertOutputMask: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! \\addtogroup oglapi"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    pub fn NvAPI_OGL_ExpertModeDefaultsGet(
        pExpertDetailLevel: *mut NvU32,
        pExpertReportMask: *mut NvU32,
        pExpertOutputMask: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns an array of physical GPU handles that are in TCC Mode."]
    #[doc = "! Each handle represents a physical GPU present in the system in TCC Mode."]
    #[doc = "! That GPU may not be visible to the OS directly."]
    #[doc = "!"]
    #[doc = "! The array nvGPUHandle will be filled with physical GPU handle values. The returned"]
    #[doc = "! gpuCount determines how many entries in the array are valid."]
    #[doc = "!"]
    #[doc = "! NOTE: Handles enumerated by this API are only valid for NvAPIs that are tagged as TCC_SUPPORTED"]
    #[doc = "!       If handle is passed to any other API, it will fail with NVAPI_INVALID_HANDLE"]
    #[doc = "!"]
    #[doc = "!       For WDDM GPU handles please use NvAPI_EnumPhysicalGPUs()"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [out]   nvGPUHandle      Physical GPU array that will contain all TCC Physical GPUs"]
    #[doc = "! \\param [out]   pGpuCount        count represent the number of valid entries in nvGPUHandle"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\retval NVAPI_INVALID_ARGUMENT         nvGPUHandle or pGpuCount is NULL"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_EnumTCCPhysicalGPUs(
        nvGPUHandle: *mut NvPhysicalGpuHandle,
        pGpuCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns an array of logical GPU handles."]
    #[doc = "!"]
    #[doc = "! Each handle represents one or more GPUs acting in concert as a single graphics device."]
    #[doc = "!"]
    #[doc = "! At least one GPU must be present in the system and running an NVIDIA display driver."]
    #[doc = "!"]
    #[doc = "! The array nvGPUHandle will be filled with logical GPU handle values.  The returned"]
    #[doc = "! gpuCount determines how many entries in the array are valid."]
    #[doc = "!"]
    #[doc = "! \\note All logical GPUs handles get invalidated on a GPU topology change, so the calling"]
    #[doc = "!       application is required to renum the logical GPU handles to get latest physical handle"]
    #[doc = "!       mapping after every GPU topology change activated by a call to NvAPI_SetGpuTopologies()."]
    #[doc = "!"]
    #[doc = "! To detect if SLI rendering is enabled, use NvAPI_D3D_GetCurrentSLIState()."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "! \\retval NVAPI_INVALID_ARGUMENT         nvGPUHandle or pGpuCount is NULL"]
    #[doc = "! \\retval NVAPI_OK                       One or more handles were returned"]
    #[doc = "! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_EnumLogicalGPUs(
        nvGPUHandle: *mut NvLogicalGpuHandle,
        pGpuCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns an array of physical GPU handles associated with the specified display."]
    #[doc = "!"]
    #[doc = "! At least one GPU must be present in the system and running an NVIDIA display driver."]
    #[doc = "!"]
    #[doc = "! The array nvGPUHandle will be filled with physical GPU handle values.  The returned"]
    #[doc = "! gpuCount determines how many entries in the array are valid."]
    #[doc = "!"]
    #[doc = "! If the display corresponds to more than one physical GPU, the first GPU returned"]
    #[doc = "! is the one with the attached active output."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "! \\retval NVAPI_INVALID_ARGUMENT         hNvDisp is not valid; nvGPUHandle or pGpuCount is NULL"]
    #[doc = "! \\retval NVAPI_OK                       One or more handles were returned"]
    #[doc = "! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  no NVIDIA GPU driving a display was found"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GetPhysicalGPUsFromDisplay(
        hNvDisp: NvDisplayHandle,
        nvGPUHandle: *mut NvPhysicalGpuHandle,
        pGpuCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns a physical GPU handle associated with the specified unattached display."]
    #[doc = "! The source GPU is a physical render GPU which renders the frame buffer but may or may not drive the scan out."]
    #[doc = "!"]
    #[doc = "! At least one GPU must be present in the system and running an NVIDIA display driver."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "! \\retval NVAPI_INVALID_ARGUMENT         hNvUnAttachedDisp is not valid or pPhysicalGpu is NULL."]
    #[doc = "! \\retval NVAPI_OK                       One or more handles were returned"]
    #[doc = "! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GetPhysicalGPUFromUnAttachedDisplay(
        hNvUnAttachedDisp: NvUnAttachedDisplayHandle,
        pPhysicalGpu: *mut NvPhysicalGpuHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns the logical GPU handle associated with the specified display."]
    #[doc = "! At least one GPU must be present in the system and running an NVIDIA display driver."]
    #[doc = "! hNvDisp can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle()."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "! \\retval NVAPI_INVALID_ARGUMENT         hNvDisp is not valid; pLogicalGPU is NULL"]
    #[doc = "! \\retval NVAPI_OK                       One or more handles were returned"]
    #[doc = "! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GetLogicalGPUFromDisplay(
        hNvDisp: NvDisplayHandle,
        pLogicalGPU: *mut NvLogicalGpuHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns the logical GPU handle associated with specified physical GPU handle."]
    #[doc = "! At least one GPU must be present in the system and running an NVIDIA display driver."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "! \\retval NVAPI_INVALID_ARGUMENT         hPhysicalGPU is not valid; pLogicalGPU is NULL"]
    #[doc = "! \\retval NVAPI_OK                       One or more handles were returned"]
    #[doc = "! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GetLogicalGPUFromPhysicalGPU(
        hPhysicalGPU: NvPhysicalGpuHandle,
        pLogicalGPU: *mut NvLogicalGpuHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the physical GPU handles associated with the specified logical GPU handle."]
    #[doc = "!  At least one GPU must be present in the system and running an NVIDIA display driver."]
    #[doc = "!"]
    #[doc = "!  The array hPhysicalGPU will be filled with physical GPU handle values.  The returned"]
    #[doc = "!  gpuCount determines how many entries in the array are valid."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "! \\retval NVAPI_INVALID_ARGUMENT             hLogicalGPU is not valid; hPhysicalGPU is NULL"]
    #[doc = "! \\retval NVAPI_OK                           One or more handles were returned"]
    #[doc = "! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND      No NVIDIA GPU driving a display was found"]
    #[doc = "! \\retval NVAPI_EXPECTED_LOGICAL_GPU_HANDLE  hLogicalGPU was not a logical GPU handle"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GetPhysicalGPUsFromLogicalGPU(
        hLogicalGPU: NvLogicalGpuHandle,
        hPhysicalGPU: *mut NvPhysicalGpuHandle,
        pGpuCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  Do not use this function for new software development."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 10 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "! \\retval NVAPI_INVALID_ARGUMENT         gpuId is zero or pPhysicalGPU is NULL"]
    #[doc = "! \\retval NVAPI_OK                       Handle was returned"]
    #[doc = "! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GetPhysicalGPUFromGPUID(
        gpuId: NvU32,
        pPhysicalGPU: *mut NvPhysicalGpuHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! SUPPORTED OS:  Windows 10 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 95"]
    #[doc = "!"]
    #[doc = "! \\retval NVAPI_INVALID_ARGUMENT         hPhysicalGpu is NULL or invalid. Re-enumerate the GPU handles."]
    #[doc = "! \\retval NVAPI_OK                       Handle was returned"]
    #[doc = "! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GetGPUIDfromPhysicalGPU(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pGpuId: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This function retrieves the number of Shader SubPipes on the GPU"]
    #[doc = "!                On newer architectures, this corresponds to the number of SM units"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 170"]
    #[doc = "!"]
    #[doc = "! RETURN STATUS: NVAPI_INVALID_ARGUMENT: pCount is NULL"]
    #[doc = "!                NVAPI_OK: *pCount is set"]
    #[doc = "!                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found"]
    #[doc = "!                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle"]
    #[doc = "!"]
    #[doc = "! \\ingroup   gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetShaderSubPipeCount(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: Retrieves the total number of cores defined for a GPU."]
    #[doc = "!                Returns 0 on architectures that don't define GPU cores."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT              pCount is NULL"]
    #[doc = "! \\retval ::NVAPI_OK                            *pCount is set"]
    #[doc = "! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND       no NVIDIA GPU driving a display was found"]
    #[doc = "! \\retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle"]
    #[doc = "! \\retval ::NVAPI_NOT_SUPPORTED                 API call is not supported on current architecture"]
    #[doc = "!"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetGpuCoreCount(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns set of all GPU-output identifiers as a bitmask."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetAllDisplayIds."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 85"]
    #[doc = "!"]
    #[doc = "! \\retval   NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL."]
    #[doc = "! \\retval   NVAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers."]
    #[doc = "! \\retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found."]
    #[doc = "! \\retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle."]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetAllOutputs(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pOutputsMask: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function is the same as NvAPI_GPU_GetAllOutputs() but returns only the set of GPU output"]
    #[doc = "! identifiers that are connected to display devices."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "! \\retval   NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL."]
    #[doc = "! \\retval   NVAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers."]
    #[doc = "! \\retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found."]
    #[doc = "! \\retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle."]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetConnectedOutputs(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pOutputsMask: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This function is the same as NvAPI_GPU_GetConnectedOutputs() but returns only the set of GPU-output"]
    #[doc = "!                identifiers that can be selected in an SLI configuration."]
    #[doc = "!                 NOTE: This function matches NvAPI_GPU_GetConnectedOutputs()"]
    #[doc = "!                 - On systems which are not SLI capable."]
    #[doc = "!                 - If the queried GPU is not part of a valid SLI group."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 170"]
    #[doc = "!"]
    #[doc = "! \\retval   NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL"]
    #[doc = "! \\retval   NVAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers"]
    #[doc = "! \\retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found"]
    #[doc = "! \\retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle"]
    #[doc = "!"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetConnectedSLIOutputs(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pOutputsMask: *mut NvU32,
    ) -> NvAPI_Status;
}
pub const NV_MONITOR_CONN_TYPE_NV_MONITOR_CONN_TYPE_UNINITIALIZED: NV_MONITOR_CONN_TYPE = 0;
pub const NV_MONITOR_CONN_TYPE_NV_MONITOR_CONN_TYPE_VGA: NV_MONITOR_CONN_TYPE = 1;
pub const NV_MONITOR_CONN_TYPE_NV_MONITOR_CONN_TYPE_COMPONENT: NV_MONITOR_CONN_TYPE = 2;
pub const NV_MONITOR_CONN_TYPE_NV_MONITOR_CONN_TYPE_SVIDEO: NV_MONITOR_CONN_TYPE = 3;
pub const NV_MONITOR_CONN_TYPE_NV_MONITOR_CONN_TYPE_HDMI: NV_MONITOR_CONN_TYPE = 4;
pub const NV_MONITOR_CONN_TYPE_NV_MONITOR_CONN_TYPE_DVI: NV_MONITOR_CONN_TYPE = 5;
pub const NV_MONITOR_CONN_TYPE_NV_MONITOR_CONN_TYPE_LVDS: NV_MONITOR_CONN_TYPE = 6;
pub const NV_MONITOR_CONN_TYPE_NV_MONITOR_CONN_TYPE_DP: NV_MONITOR_CONN_TYPE = 7;
pub const NV_MONITOR_CONN_TYPE_NV_MONITOR_CONN_TYPE_COMPOSITE: NV_MONITOR_CONN_TYPE = 8;
pub const NV_MONITOR_CONN_TYPE_NV_MONITOR_CONN_TYPE_UNKNOWN: NV_MONITOR_CONN_TYPE = -1;
#[doc = "! \\ingroup gpu"]
pub type NV_MONITOR_CONN_TYPE = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_DISPLAYIDS {
    pub version: NvU32,
    #[doc = "!< out: vga, tv, dvi, hdmi and dp. This is reserved for future use and clients should not rely on this information. Instead get the"]
    #[doc = "!< GPU connector type from NvAPI_GPU_GetConnectorInfo/NvAPI_GPU_GetConnectorInfoEx"]
    pub connectorType: NV_MONITOR_CONN_TYPE,
    #[doc = "!< this is a unique identifier for each device"]
    pub displayId: NvU32,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NV_GPU_DISPLAYIDS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_DISPLAYIDS>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_GPU_DISPLAYIDS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_DISPLAYIDS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GPU_DISPLAYIDS))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_DISPLAYIDS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_DISPLAYIDS),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_connectorType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_DISPLAYIDS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).connectorType) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_DISPLAYIDS),
                "::",
                stringify!(connectorType)
            )
        );
    }
    test_field_connectorType();
    fn test_field_displayId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_DISPLAYIDS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayId) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_DISPLAYIDS),
                "::",
                stringify!(displayId)
            )
        );
    }
    test_field_displayId();
}
impl Default for _NV_GPU_DISPLAYIDS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_GPU_DISPLAYIDS {
    #[inline]
    pub fn isDynamic(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isDynamic(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMultiStreamRootNode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMultiStreamRootNode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isActive(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isActive(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isCluster(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isCluster(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isOSVisible(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isOSVisible(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isWFD(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isWFD(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isConnected(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isConnected(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedInternal(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reservedInternal(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn isPhysicallyConnected(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isPhysicallyConnected(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isDynamic: NvU32,
        isMultiStreamRootNode: NvU32,
        isActive: NvU32,
        isCluster: NvU32,
        isOSVisible: NvU32,
        isWFD: NvU32,
        isConnected: NvU32,
        reservedInternal: NvU32,
        isPhysicallyConnected: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isDynamic: u32 = unsafe { ::std::mem::transmute(isDynamic) };
            isDynamic as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isMultiStreamRootNode: u32 =
                unsafe { ::std::mem::transmute(isMultiStreamRootNode) };
            isMultiStreamRootNode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isActive: u32 = unsafe { ::std::mem::transmute(isActive) };
            isActive as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let isCluster: u32 = unsafe { ::std::mem::transmute(isCluster) };
            isCluster as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isOSVisible: u32 = unsafe { ::std::mem::transmute(isOSVisible) };
            isOSVisible as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let isWFD: u32 = unsafe { ::std::mem::transmute(isWFD) };
            isWFD as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let isConnected: u32 = unsafe { ::std::mem::transmute(isConnected) };
            isConnected as u64
        });
        __bindgen_bitfield_unit.set(7usize, 10u8, {
            let reservedInternal: u32 = unsafe { ::std::mem::transmute(reservedInternal) };
            reservedInternal as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let isPhysicallyConnected: u32 =
                unsafe { ::std::mem::transmute(isPhysicallyConnected) };
            isPhysicallyConnected as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! \\ingroup gpu"]
pub type NV_GPU_DISPLAYIDS = _NV_GPU_DISPLAYIDS;
extern "C" {
    #[doc = "! \\code"]
    #[doc = "!   DESCRIPTION: Due to space limitation NvAPI_GPU_GetConnectedOutputs can return maximum 32 devices, but"]
    #[doc = "!                this is no longer true for DPMST. NvAPI_GPU_GetConnectedDisplayIds will return all"]
    #[doc = "!                the connected display devices in the form of displayIds for the associated hPhysicalGpu."]
    #[doc = "!                This function can accept set of flags to request cached, uncached, sli and lid to get the connected devices."]
    #[doc = "!                Default value for flags will be cached ."]
    #[doc = "! HOW TO USE: 1) for each PhysicalGpu, make a call to get the number of connected displayId's"]
    #[doc = "!                using NvAPI_GPU_GetConnectedDisplayIds by passing the pDisplayIds as NULL"]
    #[doc = "!                On call success:"]
    #[doc = "!             2) If pDisplayIdCount is greater than 0, allocate memory based on pDisplayIdCount. Then make a call NvAPI_GPU_GetConnectedDisplayIds to populate DisplayIds."]
    #[doc = "!                However, if pDisplayIdCount is 0, do not make this call."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "! PARAMETERS:     hPhysicalGpu (IN)  - GPU selection"]
    #[doc = "!                 flags        (IN)  - One or more defines from NV_GPU_CONNECTED_IDS_FLAG_* as valid flags."]
    #[doc = "!                 pDisplayIds  (IN/OUT) - Pointer to an NV_GPU_DISPLAYIDS struct, each entry represents a one displayID and its attributes"]
    #[doc = "!                 pDisplayIdCount(OUT)- Number of displayId's."]
    #[doc = "!"]
    #[doc = "! RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pDisplayIds or pDisplayIdCount is NULL"]
    #[doc = "!                NVAPI_OK: *pDisplayIds contains a set of GPU-output identifiers"]
    #[doc = "!                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found"]
    #[doc = "!                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle"]
    #[doc = "! \\endcode"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetConnectedDisplayIds(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pDisplayIds: *mut NV_GPU_DISPLAYIDS,
        pDisplayIdCount: *mut NvU32,
        flags: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API returns display IDs for all possible outputs on the GPU."]
    #[doc = "!                For DPMST connector, it will return display IDs for all the video sinks in the topology. \\n"]
    #[doc = "! HOW TO USE: 1. The first call should be made to get the all display ID count. To get the display ID count, send in \\n"]
    #[doc = "!                  a) hPhysicalGpu    - a valid GPU handle(enumerated using NvAPI_EnumPhysicalGPUs()) as input,      \\n"]
    #[doc = "!                  b) pDisplayIds     - NULL, as we just want to get the display ID count.                           \\n"]
    #[doc = "!                  c) pDisplayIdCount - a valid pointer to NvU32, whose value is set to ZERO.                        \\n"]
    #[doc = "!                If all parameters are correct and this call is successful, this call will return the display ID's count. \\n"]
    #[doc = "!             2. To get the display ID array, make the second call to NvAPI_GPU_GetAllDisplayIds() with              \\n"]
    #[doc = "!                  a) hPhysicalGpu    - should be same value which was sent in first call,                           \\n"]
    #[doc = "!                  b) pDisplayIds     - pointer to the display ID array allocated by caller based on display ID count,    \\n"]
    #[doc = "!                                       eg. malloc(sizeof(NV_GPU_DISPLAYIDS) * pDisplayIdCount).                     \\n"]
    #[doc = "!                  c) pDisplayIdCount - a valid pointer to NvU32. This indicates for how many display IDs            \\n"]
    #[doc = "!                                       the memory is allocated(pDisplayIds) by the caller.                          \\n"]
    #[doc = "!                If all parameters are correct and this call is successful, this call will return the display ID array and actual"]
    #[doc = "!                display ID count (which was obtained in the first call to NvAPI_GPU_GetAllDisplayIds). If the input display ID count is"]
    #[doc = "!                less than the actual display ID count, it will overwrite the input and give the pDisplayIdCount as actual count and the"]
    #[doc = "!                API will return NVAPI_INSUFFICIENT_BUFFER."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]     hPhysicalGpu         GPU selection."]
    #[doc = "! \\param [in,out] DisplayIds           Pointer to an array of NV_GPU_DISPLAYIDS structures, each entry represents one displayID"]
    #[doc = "!                                      and its attributes."]
    #[doc = "! \\param [in,out] pDisplayIdCount      As input, this parameter indicates the number of display's id's for which caller has"]
    #[doc = "!                                      allocated the memory. As output, it will return the actual number of display IDs."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with"]
    #[doc = "!          specific meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\retval  NVAPI_INSUFFICIENT_BUFFER  When the input buffer(pDisplayIds) is less than the actual number of display IDs, this API"]
    #[doc = "!                                     will return NVAPI_INSUFFICIENT_BUFFER."]
    #[doc = "!"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetAllDisplayIds(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pDisplayIds: *mut NV_GPU_DISPLAYIDS,
        pDisplayIdCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function is similar to NvAPI_GPU_GetConnectedOutputs(), and returns the connected display identifiers that are connected"]
    #[doc = "!  as an output mask but unlike NvAPI_GPU_GetConnectedOutputs() this API \"always\" reflects the Lid State in the output mask."]
    #[doc = "!  Thus if you expect the LID close state to be available in the connection mask use this API."]
    #[doc = "!  - If LID is closed then this API will remove the LID panel from the connected display identifiers."]
    #[doc = "!  - If LID is open then this API will reflect the LID panel in the connected display identifiers."]
    #[doc = "!"]
    #[doc = "! \\note This API should be used on notebook systems and on systems where the LID state is required in the connection"]
    #[doc = "!       output mask. On desktop systems the returned identifiers will match NvAPI_GPU_GetConnectedOutputs()."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 95"]
    #[doc = "!"]
    #[doc = "! \\retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL"]
    #[doc = "! \\retval  NVAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers"]
    #[doc = "! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found"]
    #[doc = "! \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetConnectedOutputsWithLidState(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pOutputsMask: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This function is the same as NvAPI_GPU_GetConnectedOutputsWithLidState() but returns only the set"]
    #[doc = "!                of GPU-output identifiers that can be selected in an SLI configuration. With SLI disabled,"]
    #[doc = "!                this function matches NvAPI_GPU_GetConnectedOutputsWithLidState()."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 170"]
    #[doc = "!"]
    #[doc = "! \\retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL"]
    #[doc = "! \\retval  NVAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers"]
    #[doc = "! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found"]
    #[doc = "! \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle"]
    #[doc = "!"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetConnectedSLIOutputsWithLidState(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pOutputsMask: *mut NvU32,
    ) -> NvAPI_Status;
}
pub const NV_SYSTEM_TYPE_NV_SYSTEM_TYPE_UNKNOWN: NV_SYSTEM_TYPE = 0;
pub const NV_SYSTEM_TYPE_NV_SYSTEM_TYPE_LAPTOP: NV_SYSTEM_TYPE = 1;
pub const NV_SYSTEM_TYPE_NV_SYSTEM_TYPE_DESKTOP: NV_SYSTEM_TYPE = 2;
#[doc = "! \\ingroup gpu"]
#[doc = "! Used in NvAPI_GPU_GetSystemType()"]
pub type NV_SYSTEM_TYPE = ::std::os::raw::c_int;
extern "C" {
    #[doc = "! \\ingroup gpu"]
    pub fn NvAPI_GPU_GetSystemType(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pSystemType: *mut NV_SYSTEM_TYPE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function is the same as NvAPI_GPU_GetAllOutputs but returns only the set of GPU output"]
    #[doc = "!  identifiers that are actively driving display devices."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 85"]
    #[doc = "!"]
    #[doc = "! \\retval    NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL."]
    #[doc = "! \\retval    NVAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers."]
    #[doc = "! \\retval    NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found."]
    #[doc = "! \\retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle."]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetActiveOutputs(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pOutputsMask: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  Thus function sets the EDID data for the specified GPU handle and connection bit mask."]
    #[doc = "!  User can either send (Gpu handle & output id)  or only display Id in variable displayOutputId parameter & hPhysicalGpu parameter can be default handle (0)."]
    #[doc = "!  \\note The EDID will be cached across the boot session and will be enumerated to the OS in this call."]
    #[doc = "!        To remove the EDID set sizeofEDID to zero."]
    #[doc = "!        OS and NVAPI connection status APIs will reflect the newly set or removed EDID dynamically."]
    #[doc = "!"]
    #[doc = "!                This feature will NOT be supported on the following boards:"]
    #[doc = "!                - GeForce"]
    #[doc = "!                - Quadro VX"]
    #[doc = "!                - Tesla"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 100"]
    #[doc = "!"]
    #[doc = "! \\retval  NVAPI_INVALID_ARGUMENT              pEDID is NULL; displayOutputId has 0 or > 1 bits set"]
    #[doc = "! \\retval  NVAPI_OK                           *pEDID data was applied to the requested displayOutputId."]
    #[doc = "! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found."]
    #[doc = "! \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle."]
    #[doc = "! \\retval  NVAPI_NOT_SUPPORTED                 For the above mentioned GPUs"]
    #[doc = "! \\retval  NVAPI_INVALID_USER_PRIVILEGE        The application will require Administrator privileges to access this API."]
    #[doc = "!                                              The application can be elevated to a higher permission level by selecting \"Run as Administrator\"."]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_SetEDID(
        hPhysicalGpu: NvPhysicalGpuHandle,
        displayOutputId: NvU32,
        pEDID: *mut NV_EDID,
    ) -> NvAPI_Status;
}
pub const _NV_GPU_OUTPUT_TYPE_NVAPI_GPU_OUTPUT_UNKNOWN: _NV_GPU_OUTPUT_TYPE = 0;
#[doc = "!<  CRT display device"]
pub const _NV_GPU_OUTPUT_TYPE_NVAPI_GPU_OUTPUT_CRT: _NV_GPU_OUTPUT_TYPE = 1;
#[doc = "!<  Digital Flat Panel display device"]
pub const _NV_GPU_OUTPUT_TYPE_NVAPI_GPU_OUTPUT_DFP: _NV_GPU_OUTPUT_TYPE = 2;
#[doc = "!<  TV display device"]
pub const _NV_GPU_OUTPUT_TYPE_NVAPI_GPU_OUTPUT_TV: _NV_GPU_OUTPUT_TYPE = 3;
#[doc = "! \\ingroup gpu"]
#[doc = "! used in NvAPI_GPU_GetOutputType()"]
pub type _NV_GPU_OUTPUT_TYPE = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpu"]
#[doc = "! used in NvAPI_GPU_GetOutputType()"]
pub use self::_NV_GPU_OUTPUT_TYPE as NV_GPU_OUTPUT_TYPE;
extern "C" {
    #[doc = "! \\ingroup gpu"]
    pub fn NvAPI_GPU_GetOutputType(
        hPhysicalGpu: NvPhysicalGpuHandle,
        outputId: NvU32,
        pOutputType: *mut NV_GPU_OUTPUT_TYPE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function determines if a set of GPU outputs can be active"]
    #[doc = "!  simultaneously.  While a GPU may have <n> outputs, typically they cannot"]
    #[doc = "!  all be active at the same time due to internal resource sharing."]
    #[doc = "!"]
    #[doc = "!  Given a physical GPU handle and a mask of candidate outputs, this call"]
    #[doc = "!  will return NVAPI_OK if all of the specified outputs can be driven"]
    #[doc = "!  simultaneously.  It will return NVAPI_INVALID_COMBINATION if they cannot."]
    #[doc = "!"]
    #[doc = "!  Use NvAPI_GPU_GetAllOutputs() to determine which outputs are candidates."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 85"]
    #[doc = "!"]
    #[doc = "! \\retval  NVAPI_OK                            Combination of outputs in outputsMask are valid (can be active simultaneously)."]
    #[doc = "! \\retval  NVAPI_INVALID_COMBINATION           Combination of outputs in outputsMask are NOT valid."]
    #[doc = "! \\retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or outputsMask does not have at least 2 bits set."]
    #[doc = "! \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle."]
    #[doc = "! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found."]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_ValidateOutputCombination(
        hPhysicalGpu: NvPhysicalGpuHandle,
        outputsMask: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function retrieves the full GPU name as an ASCII string - for example, \"Quadro FX 1400\"."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 90"]
    #[doc = "!"]
    #[doc = "! \\return  NVAPI_ERROR or NVAPI_OK"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetFullName(
        hPhysicalGpu: NvPhysicalGpuHandle,
        szName: *mut ::std::os::raw::c_char,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the PCI identifiers associated with this GPU."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 90"]
    #[doc = "!"]
    #[doc = "! \\param   DeviceId      The internal PCI device identifier for the GPU."]
    #[doc = "! \\param   SubSystemId   The internal PCI subsystem identifier for the GPU."]
    #[doc = "! \\param   RevisionId    The internal PCI device-specific revision identifier for the GPU."]
    #[doc = "! \\param   ExtDeviceId   The external PCI device identifier for the GPU."]
    #[doc = "!"]
    #[doc = "! \\retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or an argument is NULL"]
    #[doc = "! \\retval  NVAPI_OK                            Arguments are populated with PCI identifiers"]
    #[doc = "! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found"]
    #[doc = "! \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetPCIIdentifiers(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pDeviceId: *mut NvU32,
        pSubSystemId: *mut NvU32,
        pRevisionId: *mut NvU32,
        pExtDeviceId: *mut NvU32,
    ) -> NvAPI_Status;
}
pub const _NV_GPU_TYPE_NV_SYSTEM_TYPE_GPU_UNKNOWN: _NV_GPU_TYPE = 0;
#[doc = "!< Integrated GPU"]
pub const _NV_GPU_TYPE_NV_SYSTEM_TYPE_IGPU: _NV_GPU_TYPE = 1;
#[doc = "!< Discrete GPU"]
pub const _NV_GPU_TYPE_NV_SYSTEM_TYPE_DGPU: _NV_GPU_TYPE = 2;
#[doc = "! \\ingroup gpu"]
#[doc = "! Used in NvAPI_GPU_GetGPUType()."]
pub type _NV_GPU_TYPE = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpu"]
#[doc = "! Used in NvAPI_GPU_GetGPUType()."]
pub use self::_NV_GPU_TYPE as NV_GPU_TYPE;
extern "C" {
    #[doc = "!  DESCRIPTION: This function returns the GPU type (integrated or discrete)."]
    #[doc = "!               See ::NV_GPU_TYPE."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 173"]
    #[doc = "!"]
    #[doc = "! \\retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu"]
    #[doc = "! \\retval  NVAPI_OK                           *pGpuType contains the GPU type"]
    #[doc = "! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found"]
    #[doc = "! \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle"]
    #[doc = "!"]
    #[doc = "!  \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetGPUType(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pGpuType: *mut NV_GPU_TYPE,
    ) -> NvAPI_Status;
}
pub const _NV_GPU_BUS_TYPE_NVAPI_GPU_BUS_TYPE_UNDEFINED: _NV_GPU_BUS_TYPE = 0;
pub const _NV_GPU_BUS_TYPE_NVAPI_GPU_BUS_TYPE_PCI: _NV_GPU_BUS_TYPE = 1;
pub const _NV_GPU_BUS_TYPE_NVAPI_GPU_BUS_TYPE_AGP: _NV_GPU_BUS_TYPE = 2;
pub const _NV_GPU_BUS_TYPE_NVAPI_GPU_BUS_TYPE_PCI_EXPRESS: _NV_GPU_BUS_TYPE = 3;
pub const _NV_GPU_BUS_TYPE_NVAPI_GPU_BUS_TYPE_FPCI: _NV_GPU_BUS_TYPE = 4;
pub const _NV_GPU_BUS_TYPE_NVAPI_GPU_BUS_TYPE_AXI: _NV_GPU_BUS_TYPE = 5;
#[doc = "! \\ingroup gpu"]
#[doc = "! Used in NvAPI_GPU_GetBusType()"]
pub type _NV_GPU_BUS_TYPE = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpu"]
#[doc = "! Used in NvAPI_GPU_GetBusType()"]
pub use self::_NV_GPU_BUS_TYPE as NV_GPU_BUS_TYPE;
extern "C" {
    #[doc = "!  This function returns the type of bus associated with this GPU."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 90"]
    #[doc = "!"]
    #[doc = "! \\return      This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with"]
    #[doc = "!              specific meaning for this API, they are listed below."]
    #[doc = "! \\retval      NVAPI_INVALID_ARGUMENT             hPhysicalGpu or pBusType is NULL."]
    #[doc = "! \\retval      NVAPI_OK                          *pBusType contains bus identifier."]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetBusType(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pBusType: *mut NV_GPU_BUS_TYPE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: Returns the ID of the bus associated with this GPU."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 167"]
    #[doc = "!"]
    #[doc = "!  \\retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pBusId is NULL."]
    #[doc = "!  \\retval  NVAPI_OK                           *pBusId contains the bus ID."]
    #[doc = "!  \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found."]
    #[doc = "!  \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle."]
    #[doc = "!"]
    #[doc = "!  \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetBusId(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pBusId: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: Returns the ID of the bus slot associated with this GPU."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 167"]
    #[doc = "!"]
    #[doc = "!  \\retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pBusSlotId is NULL."]
    #[doc = "!  \\retval  NVAPI_OK                           *pBusSlotId contains the bus slot ID."]
    #[doc = "!  \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found."]
    #[doc = "!  \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle."]
    #[doc = "!"]
    #[doc = "!  \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetBusSlotId(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pBusSlotId: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the interrupt number associated with this GPU."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 90"]
    #[doc = "!"]
    #[doc = "! \\retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pIRQ is NULL."]
    #[doc = "! \\retval  NVAPI_OK                           *pIRQ contains interrupt number."]
    #[doc = "! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found."]
    #[doc = "! \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle."]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetIRQ(hPhysicalGpu: NvPhysicalGpuHandle, pIRQ: *mut NvU32) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the revision of the video BIOS associated with this GPU."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 90"]
    #[doc = "!"]
    #[doc = "! \\retval    NVAPI_INVALID_ARGUMENT               hPhysicalGpu or pBiosRevision is NULL."]
    #[doc = "! \\retval    NVAPI_OK                            *pBiosRevision contains revision number."]
    #[doc = "! \\retval    NVAPI_NVIDIA_DEVICE_NOT_FOUND        No NVIDIA GPU driving a display was found."]
    #[doc = "! \\retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE   hPhysicalGpu was not a physical GPU handle."]
    #[doc = "! \\ingroup   gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetVbiosRevision(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pBiosRevision: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the OEM revision of the video BIOS associated with this GPU."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 90"]
    #[doc = "!"]
    #[doc = "! \\retval    NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pBiosRevision is NULL"]
    #[doc = "! \\retval    NVAPI_OK                           *pBiosRevision contains revision number"]
    #[doc = "! \\retval    NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found"]
    #[doc = "! \\retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle"]
    #[doc = "! \\ingroup   gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetVbiosOEMRevision(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pBiosRevision: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the full video BIOS version string in the form of xx.xx.xx.xx.yy where"]
    #[doc = "!  - xx numbers come from NvAPI_GPU_GetVbiosRevision() and"]
    #[doc = "!  - yy comes from NvAPI_GPU_GetVbiosOEMRevision()."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 90"]
    #[doc = "!"]
    #[doc = "! \\retval   NVAPI_INVALID_ARGUMENT              hPhysicalGpu is NULL."]
    #[doc = "! \\retval   NVAPI_OK                            szBiosRevision contains version string."]
    #[doc = "! \\retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found."]
    #[doc = "! \\retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle."]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetVbiosVersionString(
        hPhysicalGpu: NvPhysicalGpuHandle,
        szBiosRevision: *mut ::std::os::raw::c_char,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the AGP aperture in megabytes."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 455."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 90"]
    #[doc = "!"]
    #[doc = "! \\retval   NVAPI_NOT_SUPPORTED"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetAGPAperture(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pSize: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the current AGP Rate (0 = AGP not present, 1 = 1x, 2 = 2x, etc.)."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 455."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 90"]
    #[doc = "!"]
    #[doc = "! \\retval   NVAPI_NOT_SUPPORTED"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetCurrentAGPRate(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pRate: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the number of PCIE lanes being used for the PCIE interface"]
    #[doc = "!  downstream from the GPU."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 90"]
    #[doc = "!"]
    #[doc = "! \\retval  NVAPI_INVALID_ARGUMENT              pWidth is NULL."]
    #[doc = "! \\retval  NVAPI_OK                            Call successful."]
    #[doc = "! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found."]
    #[doc = "! \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle."]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetCurrentPCIEDownstreamWidth(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pWidth: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   This function returns the physical size of framebuffer in KB.  This does NOT include any"]
    #[doc = "!   system RAM that may be dedicated for use by the GPU."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 90"]
    #[doc = "!"]
    #[doc = "! \\retval  NVAPI_INVALID_ARGUMENT              pSize is NULL"]
    #[doc = "! \\retval  NVAPI_OK                            Call successful"]
    #[doc = "! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found"]
    #[doc = "! \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetPhysicalFrameBufferSize(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pSize: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the virtual size of framebuffer in KB.  This includes the physical RAM plus any"]
    #[doc = "!  system RAM that has been dedicated for use by the GPU."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 90"]
    #[doc = "!"]
    #[doc = "! \\retval  NVAPI_INVALID_ARGUMENT              pSize is NULL."]
    #[doc = "! \\retval  NVAPI_OK                            Call successful."]
    #[doc = "! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found."]
    #[doc = "! \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle."]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetVirtualFrameBufferSize(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pSize: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function retrieves the Quadro status for the GPU (1 if Quadro, 0 if GeForce)"]
    #[doc = "!"]
    #[doc = "!  This API is deprecated and it is recommended to instead query"]
    #[doc = "!  NV_GPU_WORKSTATION_FEATURE_TYPE_PROVIZ support from the API"]
    #[doc = "!  NvAPI_GPU_QueryWorkstationFeatureSupport."]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 460."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "! \\return  NVAPI_ERROR or NVAPI_OK"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetQuadroStatus(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pStatus: *mut NvU32,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_BOARD_INFO {
    #[doc = "!< structure version"]
    pub version: NvU32,
    #[doc = "!< Board Serial Number"]
    pub BoardNum: [NvU8; 16usize],
}
#[test]
fn bindgen_test_layout__NV_BOARD_INFO() {
    assert_eq!(
        ::std::mem::size_of::<_NV_BOARD_INFO>(),
        20usize,
        concat!("Size of: ", stringify!(_NV_BOARD_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_BOARD_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_BOARD_INFO))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_BOARD_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_BOARD_INFO),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_BoardNum() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_BOARD_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).BoardNum) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_BOARD_INFO),
                "::",
                stringify!(BoardNum)
            )
        );
    }
    test_field_BoardNum();
}
#[doc = "! \\ingroup gpu"]
pub type NV_BOARD_INFO_V1 = _NV_BOARD_INFO;
#[doc = "! \\ingroup gpu"]
pub type NV_BOARD_INFO = NV_BOARD_INFO_V1;
extern "C" {
    #[doc = "!   DESCRIPTION: This API Retrieves the Board information (a unique GPU Board Serial Number) stored in the InfoROM."]
    #[doc = "!"]
    #[doc = "! \\param [in]      hPhysicalGpu       Physical GPU Handle."]
    #[doc = "! \\param [in,out]  NV_BOARD_INFO      Board Information."]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                     completed request"]
    #[doc = "! \\retval ::NVAPI_ERROR                  miscellaneous error occurred"]
    #[doc = "! \\retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  handle passed is not a physical GPU handle"]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED            NVAPI not initialized"]
    #[doc = "! \\retval ::NVAPI_INVALID_POINTER               pBoardInfo is NULL"]
    #[doc = "! \\retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION   the version of the INFO struct is not supported"]
    #[doc = "!"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetBoardInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pBoardInfo: *mut NV_BOARD_INFO,
    ) -> NvAPI_Status;
}
#[doc = "! Used in NvAPI_GPU_GetArchInfo()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_GPU_ARCH_INFO_V1 {
    pub version: NvU32,
    pub architecture: NvU32,
    pub implementation: NvU32,
    pub revision: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GPU_ARCH_INFO_V1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_ARCH_INFO_V1>(),
        16usize,
        concat!("Size of: ", stringify!(NV_GPU_ARCH_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_ARCH_INFO_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_ARCH_INFO_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_ARCH_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_ARCH_INFO_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_architecture() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_ARCH_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).architecture) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_ARCH_INFO_V1),
                "::",
                stringify!(architecture)
            )
        );
    }
    test_field_architecture();
    fn test_field_implementation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_ARCH_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).implementation) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_ARCH_INFO_V1),
                "::",
                stringify!(implementation)
            )
        );
    }
    test_field_implementation();
    fn test_field_revision() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_ARCH_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).revision) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_ARCH_INFO_V1),
                "::",
                stringify!(revision)
            )
        );
    }
    test_field_revision();
}
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_T2X: _NV_GPU_ARCHITECTURE_ID = -536870880;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_T3X: _NV_GPU_ARCHITECTURE_ID = -536870864;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_T4X: _NV_GPU_ARCHITECTURE_ID = -536870848;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_T12X: _NV_GPU_ARCHITECTURE_ID = -536870848;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_NV40: _NV_GPU_ARCHITECTURE_ID = 64;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_NV50: _NV_GPU_ARCHITECTURE_ID = 80;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_G78: _NV_GPU_ARCHITECTURE_ID = 96;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_G80: _NV_GPU_ARCHITECTURE_ID = 128;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_G90: _NV_GPU_ARCHITECTURE_ID = 144;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GT200: _NV_GPU_ARCHITECTURE_ID = 160;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GF100: _NV_GPU_ARCHITECTURE_ID = 192;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GF110: _NV_GPU_ARCHITECTURE_ID = 208;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GK100: _NV_GPU_ARCHITECTURE_ID = 224;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GK110: _NV_GPU_ARCHITECTURE_ID = 240;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GK200: _NV_GPU_ARCHITECTURE_ID = 256;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GM000: _NV_GPU_ARCHITECTURE_ID = 272;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GM200: _NV_GPU_ARCHITECTURE_ID = 288;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GP100: _NV_GPU_ARCHITECTURE_ID = 304;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GV100: _NV_GPU_ARCHITECTURE_ID = 320;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GV110: _NV_GPU_ARCHITECTURE_ID = 336;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_TU100: _NV_GPU_ARCHITECTURE_ID = 352;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GA100: _NV_GPU_ARCHITECTURE_ID = 368;
#[doc = "! NV_GPU_ARCH_INFO() values to identify Architecture level for the GPU."]
pub type _NV_GPU_ARCHITECTURE_ID = ::std::os::raw::c_int;
#[doc = "! NV_GPU_ARCH_INFO() values to identify Architecture level for the GPU."]
pub use self::_NV_GPU_ARCHITECTURE_ID as NV_GPU_ARCHITECTURE_ID;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_T20:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_T30:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_T35:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 5;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_T40:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_T124:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV40:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV41:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 1;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV42:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 2;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV43:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 3;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV44:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 4;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV44A:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 10;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV46:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 6;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV47:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 7;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV49:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 9;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV4B:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 11;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV4C:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 12;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV4E:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 14;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV50:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV63:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 3;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV67:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 7;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_G84:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 4;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_G86:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 6;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_G92:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 2;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_G94:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 4;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_G96:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 6;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_G98:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 8;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GT200:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GT212:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 2;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GT214:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 4;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GT215:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 3;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GT216:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 5;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GT218:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 8;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_MCP77:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 10;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GT21C:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 11;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_MCP79:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 12;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GT21A:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 13;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_MCP89:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 15;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GF100:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GF104:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 4;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GF106:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 3;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GF108:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 1;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GF110:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GF116:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 6;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GF117:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 7;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GF118:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 8;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GF119:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 9;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GK104:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 4;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GK106:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 6;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GK107:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 7;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GK20A:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 10;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GK110:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GK208:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 8;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GM204:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 4;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GM206:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 6;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GP100:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GP000:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 1;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GP102:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 2;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GP104:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 4;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GP106:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 6;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GP107:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 7;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GP108:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 8;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GV100:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GV10B:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 11;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_TU100:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_TU102:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 2;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_TU104:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 4;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_TU106:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 6;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_TU116:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 8;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_TU117:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 7;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_TU000:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 1;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GA100:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GA102:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 2;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GA104:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 4;
#[doc = "! NV_GPU_ARCH_INFO() values to identify GPU Architecture Implementation."]
pub type _NV_GPU_ARCH_IMPLEMENTATION_ID = ::std::os::raw::c_int;
#[doc = "! NV_GPU_ARCH_INFO() values to identify GPU Architecture Implementation."]
pub use self::_NV_GPU_ARCH_IMPLEMENTATION_ID as NV_GPU_ARCH_IMPLEMENTATION_ID;
#[doc = "!< QT chip"]
pub const _NV_GPU_CHIP_REVISION_NV_GPU_CHIP_REV_EMULATION_QT: _NV_GPU_CHIP_REVISION = 0;
#[doc = "!< FPGA implementation of the chipset"]
pub const _NV_GPU_CHIP_REVISION_NV_GPU_CHIP_REV_EMULATION_FPGA: _NV_GPU_CHIP_REVISION = 1;
#[doc = "!< First silicon chipset revision"]
pub const _NV_GPU_CHIP_REVISION_NV_GPU_CHIP_REV_A01: _NV_GPU_CHIP_REVISION = 17;
#[doc = "!< Second Silicon chipset revision"]
pub const _NV_GPU_CHIP_REVISION_NV_GPU_CHIP_REV_A02: _NV_GPU_CHIP_REVISION = 18;
#[doc = "!< Third Silicon chipset revision"]
pub const _NV_GPU_CHIP_REVISION_NV_GPU_CHIP_REV_A03: _NV_GPU_CHIP_REVISION = 19;
#[doc = "!< Unknown chip revision"]
pub const _NV_GPU_CHIP_REVISION_NV_GPU_CHIP_REV_UNKNOWN: _NV_GPU_CHIP_REVISION = -1;
pub type _NV_GPU_CHIP_REVISION = ::std::os::raw::c_int;
pub use self::_NV_GPU_CHIP_REVISION as NV_GPU_CHIP_REVISION;
#[doc = "! \\ingroup gpu"]
#[doc = "! Used in NvAPI_GPU_GetArchInfo()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_ARCH_INFO_V2 {
    pub version: NvU32,
    pub __bindgen_anon_1: NV_GPU_ARCH_INFO_V2__bindgen_ty_1,
    pub __bindgen_anon_2: NV_GPU_ARCH_INFO_V2__bindgen_ty_2,
    pub __bindgen_anon_3: NV_GPU_ARCH_INFO_V2__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NV_GPU_ARCH_INFO_V2__bindgen_ty_1 {
    #[doc = "!< architecture and architecture_id are the same. The former is NvU32 while the latter is an enum made for readability."]
    pub architecture: NvU32,
    #[doc = "!< specifies the architecture level for the GPU."]
    pub architecture_id: NV_GPU_ARCHITECTURE_ID,
}
#[test]
fn bindgen_test_layout_NV_GPU_ARCH_INFO_V2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_ARCH_INFO_V2__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_ARCH_INFO_V2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_1)
        )
    );
    fn test_field_architecture() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_ARCH_INFO_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).architecture) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_1),
                "::",
                stringify!(architecture)
            )
        );
    }
    test_field_architecture();
    fn test_field_architecture_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_ARCH_INFO_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).architecture_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_1),
                "::",
                stringify!(architecture_id)
            )
        );
    }
    test_field_architecture_id();
}
impl Default for NV_GPU_ARCH_INFO_V2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NV_GPU_ARCH_INFO_V2__bindgen_ty_2 {
    #[doc = "!< implementation and implementation_id are the same. The former is NvU32 while the latter is an enum made for readability."]
    pub implementation: NvU32,
    #[doc = "!< specifies the implementation of the architecture for the GPU."]
    pub implementation_id: NV_GPU_ARCH_IMPLEMENTATION_ID,
}
#[test]
fn bindgen_test_layout_NV_GPU_ARCH_INFO_V2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_ARCH_INFO_V2__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_ARCH_INFO_V2__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_2)
        )
    );
    fn test_field_implementation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_ARCH_INFO_V2__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).implementation) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_2),
                "::",
                stringify!(implementation)
            )
        );
    }
    test_field_implementation();
    fn test_field_implementation_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_ARCH_INFO_V2__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).implementation_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_2),
                "::",
                stringify!(implementation_id)
            )
        );
    }
    test_field_implementation_id();
}
impl Default for NV_GPU_ARCH_INFO_V2__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NV_GPU_ARCH_INFO_V2__bindgen_ty_3 {
    #[doc = "!< revision and revision_id are the same. The former is NvU32 while the latter is an enum made for readability."]
    pub revision: NvU32,
    #[doc = "!< specifies the architecture revision of the GPU."]
    pub revision_id: NV_GPU_CHIP_REVISION,
}
#[test]
fn bindgen_test_layout_NV_GPU_ARCH_INFO_V2__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_ARCH_INFO_V2__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_ARCH_INFO_V2__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_3)
        )
    );
    fn test_field_revision() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_ARCH_INFO_V2__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).revision) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_3),
                "::",
                stringify!(revision)
            )
        );
    }
    test_field_revision();
    fn test_field_revision_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_ARCH_INFO_V2__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).revision_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_3),
                "::",
                stringify!(revision_id)
            )
        );
    }
    test_field_revision_id();
}
impl Default for NV_GPU_ARCH_INFO_V2__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NV_GPU_ARCH_INFO_V2() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_ARCH_INFO_V2>(),
        16usize,
        concat!("Size of: ", stringify!(NV_GPU_ARCH_INFO_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_ARCH_INFO_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_ARCH_INFO_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_ARCH_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_ARCH_INFO_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
}
impl Default for NV_GPU_ARCH_INFO_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup gpu"]
#[doc = "! Used in NvAPI_GPU_GetArchInfo()"]
pub type NV_GPU_ARCH_INFO = NV_GPU_ARCH_INFO_V2;
extern "C" {
    #[doc = "! \\ingroup gpu"]
    pub fn NvAPI_GPU_GetArchInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pGpuArchInfo: *mut NV_GPU_ARCH_INFO,
    ) -> NvAPI_Status;
}
#[doc = "!< Set i2cSpeedKhz to I2C_SPEED_DEFAULT if default I2C speed is to be chosen, ie.use the current frequency setting."]
pub const NV_I2C_SPEED_NVAPI_I2C_SPEED_DEFAULT: NV_I2C_SPEED = 0;
pub const NV_I2C_SPEED_NVAPI_I2C_SPEED_3KHZ: NV_I2C_SPEED = 1;
pub const NV_I2C_SPEED_NVAPI_I2C_SPEED_10KHZ: NV_I2C_SPEED = 2;
pub const NV_I2C_SPEED_NVAPI_I2C_SPEED_33KHZ: NV_I2C_SPEED = 3;
pub const NV_I2C_SPEED_NVAPI_I2C_SPEED_100KHZ: NV_I2C_SPEED = 4;
pub const NV_I2C_SPEED_NVAPI_I2C_SPEED_200KHZ: NV_I2C_SPEED = 5;
pub const NV_I2C_SPEED_NVAPI_I2C_SPEED_400KHZ: NV_I2C_SPEED = 6;
pub type NV_I2C_SPEED = ::std::os::raw::c_int;
#[doc = "! Used in NvAPI_I2CRead() and NvAPI_I2CWrite()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_I2C_INFO_V1 {
    #[doc = "!< The structure version."]
    pub version: NvU32,
    #[doc = "!< The Display Mask of the concerned display."]
    pub displayMask: NvU32,
    #[doc = "!< This flag indicates either the DDC port (TRUE) or the communication port"]
    #[doc = "!< (FALSE) of the concerned display."]
    pub bIsDDCPort: NvU8,
    #[doc = "!< The address of the I2C slave.  The address should be shifted left by one.  For"]
    #[doc = "!< example, the I2C address 0x50, often used for reading EDIDs, would be stored"]
    #[doc = "!< here as 0xA0.  This matches the position within the byte sent by the master, as"]
    #[doc = "!< the last bit is reserved to specify the read or write direction."]
    pub i2cDevAddress: NvU8,
    #[doc = "!< The I2C target register address.  May be NULL, which indicates no register"]
    #[doc = "!< address should be sent."]
    pub pbI2cRegAddress: *mut NvU8,
    #[doc = "!< The size in bytes of target register address.  If pbI2cRegAddress is NULL, this"]
    #[doc = "!< field must be 0."]
    pub regAddrSize: NvU32,
    #[doc = "!< The buffer of data which is to be read or written (depending on the command)."]
    pub pbData: *mut NvU8,
    #[doc = "!< The size of the data buffer, pbData, to be read or written."]
    pub cbSize: NvU32,
    #[doc = "!< The target speed of the transaction (between 28Kbps to 40Kbps; not guaranteed)."]
    pub i2cSpeed: NvU32,
}
#[test]
fn bindgen_test_layout_NV_I2C_INFO_V1() {
    assert_eq!(
        ::std::mem::size_of::<NV_I2C_INFO_V1>(),
        48usize,
        concat!("Size of: ", stringify!(NV_I2C_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_I2C_INFO_V1>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_I2C_INFO_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_displayMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayMask) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V1),
                "::",
                stringify!(displayMask)
            )
        );
    }
    test_field_displayMask();
    fn test_field_bIsDDCPort() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bIsDDCPort) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V1),
                "::",
                stringify!(bIsDDCPort)
            )
        );
    }
    test_field_bIsDDCPort();
    fn test_field_i2cDevAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i2cDevAddress) as usize - ptr as usize
            },
            9usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V1),
                "::",
                stringify!(i2cDevAddress)
            )
        );
    }
    test_field_i2cDevAddress();
    fn test_field_pbI2cRegAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pbI2cRegAddress) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V1),
                "::",
                stringify!(pbI2cRegAddress)
            )
        );
    }
    test_field_pbI2cRegAddress();
    fn test_field_regAddrSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regAddrSize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V1),
                "::",
                stringify!(regAddrSize)
            )
        );
    }
    test_field_regAddrSize();
    fn test_field_pbData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pbData) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V1),
                "::",
                stringify!(pbData)
            )
        );
    }
    test_field_pbData();
    fn test_field_cbSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cbSize) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V1),
                "::",
                stringify!(cbSize)
            )
        );
    }
    test_field_cbSize();
    fn test_field_i2cSpeed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i2cSpeed) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V1),
                "::",
                stringify!(i2cSpeed)
            )
        );
    }
    test_field_i2cSpeed();
}
impl Default for NV_I2C_INFO_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Used in NvAPI_I2CRead() and NvAPI_I2CWrite()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_I2C_INFO_V2 {
    #[doc = "!< The structure version."]
    pub version: NvU32,
    #[doc = "!< The Display Mask of the concerned display."]
    pub displayMask: NvU32,
    #[doc = "!< This flag indicates either the DDC port (TRUE) or the communication port"]
    #[doc = "!< (FALSE) of the concerned display."]
    pub bIsDDCPort: NvU8,
    #[doc = "!< The address of the I2C slave.  The address should be shifted left by one.  For"]
    #[doc = "!< example, the I2C address 0x50, often used for reading EDIDs, would be stored"]
    #[doc = "!< here as 0xA0.  This matches the position within the byte sent by the master, as"]
    #[doc = "!< the last bit is reserved to specify the read or write direction."]
    pub i2cDevAddress: NvU8,
    #[doc = "!< The I2C target register address.  May be NULL, which indicates no register"]
    #[doc = "!< address should be sent."]
    pub pbI2cRegAddress: *mut NvU8,
    #[doc = "!< The size in bytes of target register address.  If pbI2cRegAddress is NULL, this"]
    #[doc = "!< field must be 0."]
    pub regAddrSize: NvU32,
    #[doc = "!< The buffer of data which is to be read or written (depending on the command)."]
    pub pbData: *mut NvU8,
    #[doc = "!< The size of the data buffer, pbData, to be read or written."]
    pub cbSize: NvU32,
    #[doc = "!< Deprecated, Must be set to NVAPI_I2C_SPEED_DEPRECATED."]
    pub i2cSpeed: NvU32,
    #[doc = "!< The target speed of the transaction in (kHz) (Chosen from the enum NV_I2C_SPEED)."]
    pub i2cSpeedKhz: NV_I2C_SPEED,
}
#[test]
fn bindgen_test_layout_NV_I2C_INFO_V2() {
    assert_eq!(
        ::std::mem::size_of::<NV_I2C_INFO_V2>(),
        56usize,
        concat!("Size of: ", stringify!(NV_I2C_INFO_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_I2C_INFO_V2>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_I2C_INFO_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_displayMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayMask) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V2),
                "::",
                stringify!(displayMask)
            )
        );
    }
    test_field_displayMask();
    fn test_field_bIsDDCPort() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bIsDDCPort) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V2),
                "::",
                stringify!(bIsDDCPort)
            )
        );
    }
    test_field_bIsDDCPort();
    fn test_field_i2cDevAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i2cDevAddress) as usize - ptr as usize
            },
            9usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V2),
                "::",
                stringify!(i2cDevAddress)
            )
        );
    }
    test_field_i2cDevAddress();
    fn test_field_pbI2cRegAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pbI2cRegAddress) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V2),
                "::",
                stringify!(pbI2cRegAddress)
            )
        );
    }
    test_field_pbI2cRegAddress();
    fn test_field_regAddrSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regAddrSize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V2),
                "::",
                stringify!(regAddrSize)
            )
        );
    }
    test_field_regAddrSize();
    fn test_field_pbData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pbData) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V2),
                "::",
                stringify!(pbData)
            )
        );
    }
    test_field_pbData();
    fn test_field_cbSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cbSize) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V2),
                "::",
                stringify!(cbSize)
            )
        );
    }
    test_field_cbSize();
    fn test_field_i2cSpeed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i2cSpeed) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V2),
                "::",
                stringify!(i2cSpeed)
            )
        );
    }
    test_field_i2cSpeed();
    fn test_field_i2cSpeedKhz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i2cSpeedKhz) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V2),
                "::",
                stringify!(i2cSpeedKhz)
            )
        );
    }
    test_field_i2cSpeedKhz();
}
impl Default for NV_I2C_INFO_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Used in NvAPI_I2CRead() and NvAPI_I2CWrite()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_I2C_INFO_V3 {
    #[doc = "!< The structure version."]
    pub version: NvU32,
    #[doc = "!< The Display Mask of the concerned display."]
    pub displayMask: NvU32,
    #[doc = "!< This flag indicates either the DDC port (TRUE) or the communication port"]
    #[doc = "!< (FALSE) of the concerned display."]
    pub bIsDDCPort: NvU8,
    #[doc = "!< The address of the I2C slave.  The address should be shifted left by one.  For"]
    #[doc = "!< example, the I2C address 0x50, often used for reading EDIDs, would be stored"]
    #[doc = "!< here as 0xA0.  This matches the position within the byte sent by the master, as"]
    #[doc = "!< the last bit is reserved to specify the read or write direction."]
    pub i2cDevAddress: NvU8,
    #[doc = "!< The I2C target register address.  May be NULL, which indicates no register"]
    #[doc = "!< address should be sent."]
    pub pbI2cRegAddress: *mut NvU8,
    #[doc = "!< The size in bytes of target register address.  If pbI2cRegAddress is NULL, this"]
    #[doc = "!< field must be 0."]
    pub regAddrSize: NvU32,
    #[doc = "!< The buffer of data which is to be read or written (depending on the command)."]
    pub pbData: *mut NvU8,
    #[doc = "!< The size of the data buffer, pbData, to be read or written."]
    pub cbSize: NvU32,
    #[doc = "!< Deprecated, Must be set to NVAPI_I2C_SPEED_DEPRECATED."]
    pub i2cSpeed: NvU32,
    #[doc = "!< The target speed of the transaction in (kHz) (Chosen from the enum NV_I2C_SPEED)."]
    pub i2cSpeedKhz: NV_I2C_SPEED,
    #[doc = "!< The portid on which device is connected (remember to set bIsPortIdSet if this value is set)"]
    #[doc = "!< Optional for pre-Kepler"]
    pub portId: NvU8,
    #[doc = "!< set this flag on if and only if portid value is set"]
    pub bIsPortIdSet: NvU32,
}
#[test]
fn bindgen_test_layout_NV_I2C_INFO_V3() {
    assert_eq!(
        ::std::mem::size_of::<NV_I2C_INFO_V3>(),
        64usize,
        concat!("Size of: ", stringify!(NV_I2C_INFO_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_I2C_INFO_V3>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_I2C_INFO_V3))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V3),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_displayMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayMask) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V3),
                "::",
                stringify!(displayMask)
            )
        );
    }
    test_field_displayMask();
    fn test_field_bIsDDCPort() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bIsDDCPort) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V3),
                "::",
                stringify!(bIsDDCPort)
            )
        );
    }
    test_field_bIsDDCPort();
    fn test_field_i2cDevAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i2cDevAddress) as usize - ptr as usize
            },
            9usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V3),
                "::",
                stringify!(i2cDevAddress)
            )
        );
    }
    test_field_i2cDevAddress();
    fn test_field_pbI2cRegAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pbI2cRegAddress) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V3),
                "::",
                stringify!(pbI2cRegAddress)
            )
        );
    }
    test_field_pbI2cRegAddress();
    fn test_field_regAddrSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regAddrSize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V3),
                "::",
                stringify!(regAddrSize)
            )
        );
    }
    test_field_regAddrSize();
    fn test_field_pbData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pbData) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V3),
                "::",
                stringify!(pbData)
            )
        );
    }
    test_field_pbData();
    fn test_field_cbSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cbSize) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V3),
                "::",
                stringify!(cbSize)
            )
        );
    }
    test_field_cbSize();
    fn test_field_i2cSpeed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i2cSpeed) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V3),
                "::",
                stringify!(i2cSpeed)
            )
        );
    }
    test_field_i2cSpeed();
    fn test_field_i2cSpeedKhz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i2cSpeedKhz) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V3),
                "::",
                stringify!(i2cSpeedKhz)
            )
        );
    }
    test_field_i2cSpeedKhz();
    fn test_field_portId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).portId) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V3),
                "::",
                stringify!(portId)
            )
        );
    }
    test_field_portId();
    fn test_field_bIsPortIdSet() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_I2C_INFO_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bIsPortIdSet) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_I2C_INFO_V3),
                "::",
                stringify!(bIsPortIdSet)
            )
        );
    }
    test_field_bIsPortIdSet();
}
impl Default for NV_I2C_INFO_V3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Used in NvAPI_I2CRead() and NvAPI_I2CWrite()"]
pub type NV_I2C_INFO = NV_I2C_INFO_V3;
extern "C" {
    #[doc = "!  This function reads the data buffer from the I2C port."]
    #[doc = "!                 The I2C request must be for a DDC port: pI2cInfo->bIsDDCPort = 1."]
    #[doc = "!"]
    #[doc = "!                 A data buffer size larger than 16 bytes may be rejected if a register address is specified.  In such a case,"]
    #[doc = "!                 NVAPI_ARGUMENT_EXCEED_MAX_SIZE would be returned."]
    #[doc = "!"]
    #[doc = "!                 If a register address is specified (i.e. regAddrSize is positive), then the transaction will be performed in"]
    #[doc = "!                 the combined format described in the I2C specification.  The register address will be written, followed by"]
    #[doc = "!                 reading into the data buffer."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 85"]
    #[doc = "!"]
    #[doc = "! \\param [in]   hPhysicalGPU     GPU selection."]
    #[doc = "! \\param [out]  NV_I2C_INFO     *pI2cInfo The I2C data input structure"]
    #[doc = "!"]
    #[doc = "! \\retval   NVAPI_OK                            Completed request"]
    #[doc = "! \\retval   NVAPI_ERROR                         Miscellaneous error occurred."]
    #[doc = "! \\retval   NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide)."]
    #[doc = "! \\retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle."]
    #[doc = "! \\retval   NVAPI_INCOMPATIBLE_STRUCT_VERSION   Structure version is not supported."]
    #[doc = "! \\retval   NVAPI_INVALID_ARGUMENT - argument does not meet specified requirements"]
    #[doc = "! \\retval   NVAPI_ARGUMENT_EXCEED_MAX_SIZE - an argument exceeds the maximum"]
    #[doc = "!"]
    #[doc = "! \\ingroup i2capi"]
    #[doc = ""]
    pub fn NvAPI_I2CRead(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pI2cInfo: *mut NV_I2C_INFO,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function writes the data buffer to the I2C port."]
    #[doc = "!"]
    #[doc = "!                 The I2C request must be for a DDC port: pI2cInfo->bIsDDCPort = 1."]
    #[doc = "!"]
    #[doc = "!                 A data buffer size larger than 16 bytes may be rejected if a register address is specified.  In such a case,"]
    #[doc = "!                 NVAPI_ARGUMENT_EXCEED_MAX_SIZE would be returned."]
    #[doc = "!"]
    #[doc = "!                 If a register address is specified (i.e. regAddrSize is positive), then the register address will be written"]
    #[doc = "!                 and the data buffer will immediately follow without a restart."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 85"]
    #[doc = "!"]
    #[doc = "! \\param [in]   hPhysicalGPU     GPU selection."]
    #[doc = "! \\param [in]   pI2cInfo         The I2C data input structure"]
    #[doc = "!"]
    #[doc = "! \\retval   NVAPI_OK                            Completed request"]
    #[doc = "! \\retval   NVAPI_ERROR                         Miscellaneous error occurred."]
    #[doc = "! \\retval   NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide)."]
    #[doc = "! \\retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle."]
    #[doc = "! \\retval   NVAPI_INCOMPATIBLE_STRUCT_VERSION    Structure version is not supported."]
    #[doc = "! \\retval   NVAPI_INVALID_ARGUMENT              Argument does not meet specified requirements"]
    #[doc = "! \\retval   NVAPI_ARGUMENT_EXCEED_MAX_SIZE      Argument exceeds the maximum"]
    #[doc = "!"]
    #[doc = "! \\ingroup i2capi"]
    #[doc = ""]
    pub fn NvAPI_I2CWrite(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pI2cInfo: *mut NV_I2C_INFO,
    ) -> NvAPI_Status;
}
pub const NVAPI_GPU_WORKSTATION_FEATURE_MASK_NVAPI_GPU_WORKSTATION_FEATURE_MASK_SWAPGROUP:
    NVAPI_GPU_WORKSTATION_FEATURE_MASK = 1;
pub const NVAPI_GPU_WORKSTATION_FEATURE_MASK_NVAPI_GPU_WORKSTATION_FEATURE_MASK_STEREO:
    NVAPI_GPU_WORKSTATION_FEATURE_MASK = 16;
pub const NVAPI_GPU_WORKSTATION_FEATURE_MASK_NVAPI_GPU_WORKSTATION_FEATURE_MASK_WARPING:
    NVAPI_GPU_WORKSTATION_FEATURE_MASK = 256;
pub const NVAPI_GPU_WORKSTATION_FEATURE_MASK_NVAPI_GPU_WORKSTATION_FEATURE_MASK_PIXINTENSITY:
    NVAPI_GPU_WORKSTATION_FEATURE_MASK = 512;
pub const NVAPI_GPU_WORKSTATION_FEATURE_MASK_NVAPI_GPU_WORKSTATION_FEATURE_MASK_GRAYSCALE:
    NVAPI_GPU_WORKSTATION_FEATURE_MASK = 1024;
pub const NVAPI_GPU_WORKSTATION_FEATURE_MASK_NVAPI_GPU_WORKSTATION_FEATURE_MASK_BPC10:
    NVAPI_GPU_WORKSTATION_FEATURE_MASK = 4096;
#[doc = "! \\ingroup gpu"]
pub type NVAPI_GPU_WORKSTATION_FEATURE_MASK = ::std::os::raw::c_int;
extern "C" {
    #[doc = "! \\ingroup gpu"]
    pub fn NvAPI_GPU_WorkstationFeatureSetup(
        hPhysicalGpu: NvPhysicalGpuHandle,
        featureEnableMask: NvU32,
        featureDisableMask: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! \\ingroup gpu"]
    pub fn NvAPI_GPU_WorkstationFeatureQuery(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pConfiguredFeatureMask: *mut NvU32,
        pConsistentFeatureMask: *mut NvU32,
    ) -> NvAPI_Status;
}
pub const _NV_GPU_HDCP_FUSE_STATE_NV_GPU_HDCP_FUSE_STATE_UNKNOWN: _NV_GPU_HDCP_FUSE_STATE = 0;
pub const _NV_GPU_HDCP_FUSE_STATE_NV_GPU_HDCP_FUSE_STATE_DISABLED: _NV_GPU_HDCP_FUSE_STATE = 1;
pub const _NV_GPU_HDCP_FUSE_STATE_NV_GPU_HDCP_FUSE_STATE_ENABLED: _NV_GPU_HDCP_FUSE_STATE = 2;
#[doc = "! HDCP fuse states - used in NV_GPU_GET_HDCP_SUPPORT_STATUS"]
pub type _NV_GPU_HDCP_FUSE_STATE = ::std::os::raw::c_int;
#[doc = "! HDCP fuse states - used in NV_GPU_GET_HDCP_SUPPORT_STATUS"]
pub use self::_NV_GPU_HDCP_FUSE_STATE as NV_GPU_HDCP_FUSE_STATE;
pub const _NV_GPU_HDCP_KEY_SOURCE_NV_GPU_HDCP_KEY_SOURCE_UNKNOWN: _NV_GPU_HDCP_KEY_SOURCE = 0;
pub const _NV_GPU_HDCP_KEY_SOURCE_NV_GPU_HDCP_KEY_SOURCE_NONE: _NV_GPU_HDCP_KEY_SOURCE = 1;
pub const _NV_GPU_HDCP_KEY_SOURCE_NV_GPU_HDCP_KEY_SOURCE_CRYPTO_ROM: _NV_GPU_HDCP_KEY_SOURCE = 2;
pub const _NV_GPU_HDCP_KEY_SOURCE_NV_GPU_HDCP_KEY_SOURCE_SBIOS: _NV_GPU_HDCP_KEY_SOURCE = 3;
pub const _NV_GPU_HDCP_KEY_SOURCE_NV_GPU_HDCP_KEY_SOURCE_I2C_ROM: _NV_GPU_HDCP_KEY_SOURCE = 4;
pub const _NV_GPU_HDCP_KEY_SOURCE_NV_GPU_HDCP_KEY_SOURCE_FUSES: _NV_GPU_HDCP_KEY_SOURCE = 5;
#[doc = "! HDCP key sources - used in NV_GPU_GET_HDCP_SUPPORT_STATUS"]
pub type _NV_GPU_HDCP_KEY_SOURCE = ::std::os::raw::c_int;
#[doc = "! HDCP key sources - used in NV_GPU_GET_HDCP_SUPPORT_STATUS"]
pub use self::_NV_GPU_HDCP_KEY_SOURCE as NV_GPU_HDCP_KEY_SOURCE;
pub const _NV_GPU_HDCP_KEY_SOURCE_STATE_NV_GPU_HDCP_KEY_SOURCE_STATE_UNKNOWN:
    _NV_GPU_HDCP_KEY_SOURCE_STATE = 0;
pub const _NV_GPU_HDCP_KEY_SOURCE_STATE_NV_GPU_HDCP_KEY_SOURCE_STATE_ABSENT:
    _NV_GPU_HDCP_KEY_SOURCE_STATE = 1;
pub const _NV_GPU_HDCP_KEY_SOURCE_STATE_NV_GPU_HDCP_KEY_SOURCE_STATE_PRESENT:
    _NV_GPU_HDCP_KEY_SOURCE_STATE = 2;
#[doc = "! HDCP key source states - used in NV_GPU_GET_HDCP_SUPPORT_STATUS"]
pub type _NV_GPU_HDCP_KEY_SOURCE_STATE = ::std::os::raw::c_int;
#[doc = "! HDCP key source states - used in NV_GPU_GET_HDCP_SUPPORT_STATUS"]
pub use self::_NV_GPU_HDCP_KEY_SOURCE_STATE as NV_GPU_HDCP_KEY_SOURCE_STATE;
#[doc = "! HDPC support status - used in NvAPI_GPU_GetHDCPSupportStatus()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_GET_HDCP_SUPPORT_STATUS {
    pub version: NvU32,
    #[doc = "! Structure version constucted by macro #NV_GPU_GET_HDCP_SUPPORT_STATUS"]
    pub hdcpFuseState: NV_GPU_HDCP_FUSE_STATE,
    #[doc = "! GPU's HDCP fuse state"]
    pub hdcpKeySource: NV_GPU_HDCP_KEY_SOURCE,
    #[doc = "! GPU's HDCP key source"]
    pub hdcpKeySourceState: NV_GPU_HDCP_KEY_SOURCE_STATE,
}
#[test]
fn bindgen_test_layout_NV_GPU_GET_HDCP_SUPPORT_STATUS() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_GET_HDCP_SUPPORT_STATUS>(),
        16usize,
        concat!("Size of: ", stringify!(NV_GPU_GET_HDCP_SUPPORT_STATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_GET_HDCP_SUPPORT_STATUS>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_GET_HDCP_SUPPORT_STATUS))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_GET_HDCP_SUPPORT_STATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_GET_HDCP_SUPPORT_STATUS),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_hdcpFuseState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_GET_HDCP_SUPPORT_STATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hdcpFuseState) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_GET_HDCP_SUPPORT_STATUS),
                "::",
                stringify!(hdcpFuseState)
            )
        );
    }
    test_field_hdcpFuseState();
    fn test_field_hdcpKeySource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_GET_HDCP_SUPPORT_STATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hdcpKeySource) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_GET_HDCP_SUPPORT_STATUS),
                "::",
                stringify!(hdcpKeySource)
            )
        );
    }
    test_field_hdcpKeySource();
    fn test_field_hdcpKeySourceState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_GET_HDCP_SUPPORT_STATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hdcpKeySourceState) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_GET_HDCP_SUPPORT_STATUS),
                "::",
                stringify!(hdcpKeySourceState)
            )
        );
    }
    test_field_hdcpKeySourceState();
}
impl Default for NV_GPU_GET_HDCP_SUPPORT_STATUS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "!  \\ingroup gpu"]
    pub fn NvAPI_GPU_GetHDCPSupportStatus(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pGetHDCPSupportStatus: *mut NV_GPU_GET_HDCP_SUPPORT_STATUS,
    ) -> NvAPI_Status;
}
#[doc = "! @}"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_COMPUTE_GPU_TOPOLOGY_V1 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< Total number of compute-capable GPUs"]
    pub gpuCount: NvU32,
    #[doc = "!< Array of compute-capable physical GPUs."]
    pub computeGpus: [NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1 {
    #[doc = "!< Compute-capable physical GPU handle"]
    pub hPhysicalGpu: NvPhysicalGpuHandle,
    #[doc = "!< One or more flags from \\ref nvcomp_gpu_top"]
    pub flags: NvU32,
}
#[test]
fn bindgen_test_layout_NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1)
        )
    );
    fn test_field_hPhysicalGpu() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hPhysicalGpu) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1),
                "::",
                stringify!(hPhysicalGpu)
            )
        );
    }
    test_field_hPhysicalGpu();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
impl Default for NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NV_COMPUTE_GPU_TOPOLOGY_V1() {
    assert_eq!(
        ::std::mem::size_of::<NV_COMPUTE_GPU_TOPOLOGY_V1>(),
        136usize,
        concat!("Size of: ", stringify!(NV_COMPUTE_GPU_TOPOLOGY_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_COMPUTE_GPU_TOPOLOGY_V1>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_COMPUTE_GPU_TOPOLOGY_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_COMPUTE_GPU_TOPOLOGY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_COMPUTE_GPU_TOPOLOGY_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_gpuCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_COMPUTE_GPU_TOPOLOGY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gpuCount) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_COMPUTE_GPU_TOPOLOGY_V1),
                "::",
                stringify!(gpuCount)
            )
        );
    }
    test_field_gpuCount();
    fn test_field_computeGpus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_COMPUTE_GPU_TOPOLOGY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).computeGpus) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_COMPUTE_GPU_TOPOLOGY_V1),
                "::",
                stringify!(computeGpus)
            )
        );
    }
    test_field_computeGpus();
}
impl Default for NV_COMPUTE_GPU_TOPOLOGY_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_COMPUTE_GPU {
    #[doc = "!< Compute-capable physical GPU handle"]
    pub hPhysicalGpu: NvPhysicalGpuHandle,
    #[doc = "!< One or more flags from \\ref nvcomp_gpu_top"]
    pub flags: NvU32,
}
#[test]
fn bindgen_test_layout__NV_COMPUTE_GPU() {
    assert_eq!(
        ::std::mem::size_of::<_NV_COMPUTE_GPU>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_COMPUTE_GPU))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COMPUTE_GPU>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_COMPUTE_GPU))
    );
    fn test_field_hPhysicalGpu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COMPUTE_GPU>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hPhysicalGpu) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COMPUTE_GPU),
                "::",
                stringify!(hPhysicalGpu)
            )
        );
    }
    test_field_hPhysicalGpu();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COMPUTE_GPU>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COMPUTE_GPU),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
impl Default for _NV_COMPUTE_GPU {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_COMPUTE_GPU = _NV_COMPUTE_GPU;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_COMPUTE_GPU_TOPOLOGY_V2 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< Size of array"]
    pub gpuCount: NvU32,
    #[doc = "!< Array of compute-capable physical GPUs (allocate memory of size of Physical gpuCount of system)."]
    pub computeGpus: *mut NV_COMPUTE_GPU,
}
#[test]
fn bindgen_test_layout__NV_COMPUTE_GPU_TOPOLOGY_V2() {
    assert_eq!(
        ::std::mem::size_of::<_NV_COMPUTE_GPU_TOPOLOGY_V2>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_COMPUTE_GPU_TOPOLOGY_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COMPUTE_GPU_TOPOLOGY_V2>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_COMPUTE_GPU_TOPOLOGY_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COMPUTE_GPU_TOPOLOGY_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COMPUTE_GPU_TOPOLOGY_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_gpuCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COMPUTE_GPU_TOPOLOGY_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gpuCount) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COMPUTE_GPU_TOPOLOGY_V2),
                "::",
                stringify!(gpuCount)
            )
        );
    }
    test_field_gpuCount();
    fn test_field_computeGpus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COMPUTE_GPU_TOPOLOGY_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).computeGpus) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COMPUTE_GPU_TOPOLOGY_V2),
                "::",
                stringify!(computeGpus)
            )
        );
    }
    test_field_computeGpus();
}
impl Default for _NV_COMPUTE_GPU_TOPOLOGY_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_COMPUTE_GPU_TOPOLOGY_V2 = _NV_COMPUTE_GPU_TOPOLOGY_V2;
pub type NV_COMPUTE_GPU_TOPOLOGY = NV_COMPUTE_GPU_TOPOLOGY_V2;
extern "C" {
    #[doc = "! DESCRIPTION:   This API enumerates one or more compute-capable GPUs."]
    #[doc = "!                Note that this API is deprecated and should no longer be used for new software development."]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 319."]
    #[doc = "! SUPPORTED OS:  Windows 10 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "! \\param [inout]      pComputeTopo  Pointer to the structure NV_COMPUTE_GPU_TOPOLOGY."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                           The request was completed successfully."]
    #[doc = "!                                              The gpuCount indicates if one or more compute-capable GPUs are found."]
    #[doc = "!                                              gpuCount >= 1 means atleast one compute-capable GPU is found."]
    #[doc = "! \\retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  Structure version is not supported, initialize to NV_COMPUTE_GPU_TOPOLOGY_VER."]
    #[doc = "! \\retval ::NVAPI_ERROR                        Enumeration of the GPUs failed. Make sure at least one NVIDIA GPU exists in the system."]
    #[doc = "!"]
    #[doc = "! \\ingroup gpucuda"]
    #[doc = ""]
    pub fn NvAPI_GPU_CudaEnumComputeCapableGpus(
        pComputeTopo: *mut NV_COMPUTE_GPU_TOPOLOGY,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API retrieves the fan speed tachometer reading for the specified physical GPU."]
    #[doc = "!"]
    #[doc = "!   HOW TO USE:"]
    #[doc = "!                 - NvU32 Value = 0;"]
    #[doc = "!                 - ret = NvAPI_GPU_GetTachReading(hPhysicalGpu, &Value);"]
    #[doc = "!                 - On call success:"]
    #[doc = "!                 - Value contains the tachometer reading"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\param [in]    hPhysicalGpu   GPU selection."]
    #[doc = "! \\param [out]   pValue         Pointer to a variable to get the tachometer reading"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK - completed request"]
    #[doc = "! \\retval ::NVAPI_ERROR - miscellaneous error occurred"]
    #[doc = "! \\retval ::NVAPI_NOT_SUPPORTED - functionality not supported"]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED - nvapi not initialized"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT - invalid argument passed"]
    #[doc = "! \\retval ::NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)"]
    #[doc = "! \\retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle"]
    #[doc = "!"]
    #[doc = "! \\ingroup gpucooler"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetTachReading(
        hPhysicalGPU: NvPhysicalGpuHandle,
        pValue: *mut NvU32,
    ) -> NvAPI_Status;
}
pub const _NV_ECC_CONFIGURATION_NV_ECC_CONFIGURATION_NOT_SUPPORTED: _NV_ECC_CONFIGURATION = 0;
#[doc = "!< Changes require a POST to take effect"]
pub const _NV_ECC_CONFIGURATION_NV_ECC_CONFIGURATION_DEFERRED: _NV_ECC_CONFIGURATION = 1;
#[doc = "!< Changes can optionally be made to take effect immediately"]
pub const _NV_ECC_CONFIGURATION_NV_ECC_CONFIGURATION_IMMEDIATE: _NV_ECC_CONFIGURATION = 2;
#[doc = "! \\addtogroup gpuecc"]
#[doc = "! Used in NV_GPU_ECC_STATUS_INFO."]
pub type _NV_ECC_CONFIGURATION = ::std::os::raw::c_int;
#[doc = "! \\addtogroup gpuecc"]
#[doc = "! Used in NV_GPU_ECC_STATUS_INFO."]
pub use self::_NV_ECC_CONFIGURATION as NV_ECC_CONFIGURATION;
#[doc = "! \\ingroup gpuecc"]
#[doc = "! Used in NvAPI_GPU_GetECCStatusInfo()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_ECC_STATUS_INFO {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "!< Supported ECC memory feature configuration options"]
    pub configurationOptions: NV_ECC_CONFIGURATION,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_NV_GPU_ECC_STATUS_INFO() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_ECC_STATUS_INFO>(),
        16usize,
        concat!("Size of: ", stringify!(NV_GPU_ECC_STATUS_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_ECC_STATUS_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_ECC_STATUS_INFO))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_ECC_STATUS_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_ECC_STATUS_INFO),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_configurationOptions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_ECC_STATUS_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).configurationOptions) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_ECC_STATUS_INFO),
                "::",
                stringify!(configurationOptions)
            )
        );
    }
    test_field_configurationOptions();
}
impl Default for NV_GPU_ECC_STATUS_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl NV_GPU_ECC_STATUS_INFO {
    #[inline]
    pub fn isSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isSupported: NvU32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isSupported: u32 = unsafe { ::std::mem::transmute(isSupported) };
            isSupported as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn isEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(isEnabled: NvU32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isEnabled: u32 = unsafe { ::std::mem::transmute(isEnabled) };
            isEnabled as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = "! \\ingroup gpuecc"]
    pub fn NvAPI_GPU_GetECCStatusInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pECCStatusInfo: *mut NV_GPU_ECC_STATUS_INFO,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpuecc"]
#[doc = "! Used in NvAPI_GPU_GetECCErrorInfo()/"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_GPU_ECC_ERROR_INFO {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    pub current: NV_GPU_ECC_ERROR_INFO__bindgen_ty_1,
    pub aggregate: NV_GPU_ECC_ERROR_INFO__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_GPU_ECC_ERROR_INFO__bindgen_ty_1 {
    #[doc = "!< Number of single-bit ECC errors detected since last boot"]
    pub singleBitErrors: NvU64,
    #[doc = "!< Number of double-bit ECC errors detected since last boot"]
    pub doubleBitErrors: NvU64,
}
#[test]
fn bindgen_test_layout_NV_GPU_ECC_ERROR_INFO__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_ECC_ERROR_INFO__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(NV_GPU_ECC_ERROR_INFO__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_ECC_ERROR_INFO__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_ECC_ERROR_INFO__bindgen_ty_1)
        )
    );
    fn test_field_singleBitErrors() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_ECC_ERROR_INFO__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).singleBitErrors) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_ECC_ERROR_INFO__bindgen_ty_1),
                "::",
                stringify!(singleBitErrors)
            )
        );
    }
    test_field_singleBitErrors();
    fn test_field_doubleBitErrors() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_ECC_ERROR_INFO__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).doubleBitErrors) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_ECC_ERROR_INFO__bindgen_ty_1),
                "::",
                stringify!(doubleBitErrors)
            )
        );
    }
    test_field_doubleBitErrors();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_GPU_ECC_ERROR_INFO__bindgen_ty_2 {
    #[doc = "!< Number of single-bit ECC errors detected since last counter reset"]
    pub singleBitErrors: NvU64,
    #[doc = "!< Number of double-bit ECC errors detected since last counter reset"]
    pub doubleBitErrors: NvU64,
}
#[test]
fn bindgen_test_layout_NV_GPU_ECC_ERROR_INFO__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_ECC_ERROR_INFO__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(NV_GPU_ECC_ERROR_INFO__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_ECC_ERROR_INFO__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_ECC_ERROR_INFO__bindgen_ty_2)
        )
    );
    fn test_field_singleBitErrors() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_ECC_ERROR_INFO__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).singleBitErrors) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_ECC_ERROR_INFO__bindgen_ty_2),
                "::",
                stringify!(singleBitErrors)
            )
        );
    }
    test_field_singleBitErrors();
    fn test_field_doubleBitErrors() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_ECC_ERROR_INFO__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).doubleBitErrors) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_ECC_ERROR_INFO__bindgen_ty_2),
                "::",
                stringify!(doubleBitErrors)
            )
        );
    }
    test_field_doubleBitErrors();
}
#[test]
fn bindgen_test_layout_NV_GPU_ECC_ERROR_INFO() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_ECC_ERROR_INFO>(),
        40usize,
        concat!("Size of: ", stringify!(NV_GPU_ECC_ERROR_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_ECC_ERROR_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_GPU_ECC_ERROR_INFO))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_ECC_ERROR_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_ECC_ERROR_INFO),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_current() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_ECC_ERROR_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).current) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_ECC_ERROR_INFO),
                "::",
                stringify!(current)
            )
        );
    }
    test_field_current();
    fn test_field_aggregate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_ECC_ERROR_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aggregate) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_ECC_ERROR_INFO),
                "::",
                stringify!(aggregate)
            )
        );
    }
    test_field_aggregate();
}
extern "C" {
    #[doc = ""]
    #[doc = "! \\ingroup gpuecc"]
    pub fn NvAPI_GPU_GetECCErrorInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pECCErrorInfo: *mut NV_GPU_ECC_ERROR_INFO,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This function resets ECC memory error counters."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\requires Administrator privileges since release 430.39"]
    #[doc = "!"]
    #[doc = "! \\param [in]     hPhysicalGpu     A handle identifying the physical GPU for"]
    #[doc = "!                                  which ECC error information is to be"]
    #[doc = "!                                  cleared."]
    #[doc = "! \\param [in]     bResetCurrent    Reset the current ECC error counters."]
    #[doc = "! \\param [in]     bResetAggregate  Reset the aggregate ECC error counters."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with"]
    #[doc = "!          specific meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_INVALID_USER_PRIVILEGE       - The application will require Administrator privileges to access this API."]
    #[doc = "!                                                The application can be elevated to a higher permission level by selecting \"Run as Administrator\"."]
    #[doc = "!"]
    #[doc = "! \\ingroup gpuecc"]
    #[doc = ""]
    pub fn NvAPI_GPU_ResetECCErrorInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        bResetCurrent: NvU8,
        bResetAggregate: NvU8,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpuecc"]
#[doc = "! Used in NvAPI_GPU_GetECCConfigurationInfo()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_GPU_ECC_CONFIGURATION_INFO {
    pub version: NvU32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_NV_GPU_ECC_CONFIGURATION_INFO() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_ECC_CONFIGURATION_INFO>(),
        8usize,
        concat!("Size of: ", stringify!(NV_GPU_ECC_CONFIGURATION_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_ECC_CONFIGURATION_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_ECC_CONFIGURATION_INFO))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_ECC_CONFIGURATION_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_ECC_CONFIGURATION_INFO),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
}
impl NV_GPU_ECC_CONFIGURATION_INFO {
    #[inline]
    pub fn isEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isEnabledByDefault(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEnabledByDefault(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isEnabled: NvU32,
        isEnabledByDefault: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isEnabled: u32 = unsafe { ::std::mem::transmute(isEnabled) };
            isEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isEnabledByDefault: u32 = unsafe { ::std::mem::transmute(isEnabledByDefault) };
            isEnabledByDefault as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = "! \\ingroup gpuecc"]
    pub fn NvAPI_GPU_GetECCConfigurationInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pECCConfigurationInfo: *mut NV_GPU_ECC_CONFIGURATION_INFO,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This function updates the ECC memory configuration setting."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\requires Administrator privileges since release 430.39"]
    #[doc = "!"]
    #[doc = "! \\param [in]      hPhysicalGpu    A handle identifying the physical GPU for"]
    #[doc = "!                                  which to update the ECC configuration"]
    #[doc = "!                                  setting."]
    #[doc = "! \\param [in]      bEnable         The new ECC configuration setting."]
    #[doc = "! \\param [in]      bEnableImmediately   Request that the new setting take effect immediately."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with"]
    #[doc = "!          specific meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_INVALID_CONFIGURATION        - Possibly SLI is enabled. Disable SLI and retry."]
    #[doc = "! \\retval ::NVAPI_INVALID_USER_PRIVILEGE       - The application will require Administrator privileges to access this API."]
    #[doc = "!                                                The application can be elevated to a higher permission level by selecting \"Run as Administrator\"."]
    #[doc = "!"]
    #[doc = "! \\ingroup gpuecc"]
    #[doc = ""]
    pub fn NvAPI_GPU_SetECCConfiguration(
        hPhysicalGpu: NvPhysicalGpuHandle,
        bEnable: NvU8,
        bEnableImmediately: NvU8,
    ) -> NvAPI_Status;
}
pub const NV_QSYNC_EVENT_NV_QSYNC_EVENT_NONE: NV_QSYNC_EVENT = 0;
pub const NV_QSYNC_EVENT_NV_QSYNC_EVENT_SYNC_LOSS: NV_QSYNC_EVENT = 1;
pub const NV_QSYNC_EVENT_NV_QSYNC_EVENT_SYNC_GAIN: NV_QSYNC_EVENT = 2;
pub const NV_QSYNC_EVENT_NV_QSYNC_EVENT_HOUSESYNC_GAIN: NV_QSYNC_EVENT = 3;
pub const NV_QSYNC_EVENT_NV_QSYNC_EVENT_HOUSESYNC_LOSS: NV_QSYNC_EVENT = 4;
pub const NV_QSYNC_EVENT_NV_QSYNC_EVENT_RJ45_GAIN: NV_QSYNC_EVENT = 5;
pub const NV_QSYNC_EVENT_NV_QSYNC_EVENT_RJ45_LOSS: NV_QSYNC_EVENT = 6;
pub type NV_QSYNC_EVENT = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_QSYNC_EVENT_DATA {
    pub qsyncEvent: NV_QSYNC_EVENT,
    pub reserved: [NvU32; 7usize],
}
#[test]
fn bindgen_test_layout_NV_QSYNC_EVENT_DATA() {
    assert_eq!(
        ::std::mem::size_of::<NV_QSYNC_EVENT_DATA>(),
        32usize,
        concat!("Size of: ", stringify!(NV_QSYNC_EVENT_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_QSYNC_EVENT_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_QSYNC_EVENT_DATA))
    );
    fn test_field_qsyncEvent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_QSYNC_EVENT_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qsyncEvent) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_QSYNC_EVENT_DATA),
                "::",
                stringify!(qsyncEvent)
            )
        );
    }
    test_field_qsyncEvent();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_QSYNC_EVENT_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_QSYNC_EVENT_DATA),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
impl Default for NV_QSYNC_EVENT_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Callback for QSYNC event"]
pub type NVAPI_CALLBACK_QSYNCEVENT = ::std::option::Option<
    unsafe extern "C" fn(
        qyncEventData: NV_QSYNC_EVENT_DATA,
        callbackParam: *mut ::std::os::raw::c_void,
    ),
>;
pub const NV_EVENT_TYPE_NV_EVENT_TYPE_NONE: NV_EVENT_TYPE = 0;
pub const NV_EVENT_TYPE_NV_EVENT_TYPE_QSYNC: NV_EVENT_TYPE = 6;
#[doc = "! Enum for Event IDs"]
pub type NV_EVENT_TYPE = ::std::os::raw::c_int;
#[doc = "! Core NV_EVENT_REGISTER_CALLBACK structure declaration"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_EVENT_REGISTER_CALLBACK {
    #[doc = "!< version field to ensure minimum version compatibility"]
    pub version: NvU32,
    #[doc = "!< ID of the event being sent"]
    pub eventId: NV_EVENT_TYPE,
    #[doc = "!< This value will be passed back to the callback function when an event occurs"]
    pub callbackParam: *mut ::std::os::raw::c_void,
    pub nvCallBackFunc: NV_EVENT_REGISTER_CALLBACK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NV_EVENT_REGISTER_CALLBACK__bindgen_ty_1 {
    #[doc = "!< Callback function pointer for QSYNC events"]
    pub nvQSYNCEventCallback: NVAPI_CALLBACK_QSYNCEVENT,
}
#[test]
fn bindgen_test_layout_NV_EVENT_REGISTER_CALLBACK__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_EVENT_REGISTER_CALLBACK__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(NV_EVENT_REGISTER_CALLBACK__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_EVENT_REGISTER_CALLBACK__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NV_EVENT_REGISTER_CALLBACK__bindgen_ty_1)
        )
    );
    fn test_field_nvQSYNCEventCallback() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_EVENT_REGISTER_CALLBACK__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvQSYNCEventCallback) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_EVENT_REGISTER_CALLBACK__bindgen_ty_1),
                "::",
                stringify!(nvQSYNCEventCallback)
            )
        );
    }
    test_field_nvQSYNCEventCallback();
}
impl Default for NV_EVENT_REGISTER_CALLBACK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NV_EVENT_REGISTER_CALLBACK() {
    assert_eq!(
        ::std::mem::size_of::<NV_EVENT_REGISTER_CALLBACK>(),
        24usize,
        concat!("Size of: ", stringify!(NV_EVENT_REGISTER_CALLBACK))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_EVENT_REGISTER_CALLBACK>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_EVENT_REGISTER_CALLBACK))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_EVENT_REGISTER_CALLBACK>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_EVENT_REGISTER_CALLBACK),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_eventId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_EVENT_REGISTER_CALLBACK>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).eventId) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_EVENT_REGISTER_CALLBACK),
                "::",
                stringify!(eventId)
            )
        );
    }
    test_field_eventId();
    fn test_field_callbackParam() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_EVENT_REGISTER_CALLBACK>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).callbackParam) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_EVENT_REGISTER_CALLBACK),
                "::",
                stringify!(callbackParam)
            )
        );
    }
    test_field_callbackParam();
    fn test_field_nvCallBackFunc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_EVENT_REGISTER_CALLBACK>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvCallBackFunc) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_EVENT_REGISTER_CALLBACK),
                "::",
                stringify!(nvCallBackFunc)
            )
        );
    }
    test_field_nvCallBackFunc();
}
impl Default for NV_EVENT_REGISTER_CALLBACK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Core NV_EVENT_REGISTER_CALLBACK structure declaration"]
pub type PNV_EVENT_REGISTER_CALLBACK = *mut NV_EVENT_REGISTER_CALLBACK;
#[doc = "!< NVIDIA RTX VR Ready"]
pub const _NV_GPU_WORKSTATION_FEATURE_TYPE_NV_GPU_WORKSTATION_FEATURE_TYPE_NVIDIA_RTX_VR_READY:
    _NV_GPU_WORKSTATION_FEATURE_TYPE = 1;
#[doc = "!< DEPRECATED name - do not use"]
pub const _NV_GPU_WORKSTATION_FEATURE_TYPE_NV_GPU_WORKSTATION_FEATURE_TYPE_QUADRO_VR_READY:
    _NV_GPU_WORKSTATION_FEATURE_TYPE = 1;
pub const _NV_GPU_WORKSTATION_FEATURE_TYPE_NV_GPU_WORKSTATION_FEATURE_TYPE_PROVIZ:
    _NV_GPU_WORKSTATION_FEATURE_TYPE = 2;
#[doc = "! \\ingroup gpu"]
pub type _NV_GPU_WORKSTATION_FEATURE_TYPE = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpu"]
pub use self::_NV_GPU_WORKSTATION_FEATURE_TYPE as NV_GPU_WORKSTATION_FEATURE_TYPE;
extern "C" {
    #[doc = "! \\fn NvAPI_GPU_QueryWorkstationFeatureSupport(NvPhysicalGpuHandle physicalGpu, NV_GPU_WORKSTATION_FEATURE_TYPE gpuWorkstationFeature)"]
    #[doc = "! \\code"]
    #[doc = "! DESCRIPTION:     Indicates whether a queried workstation feature is supported by the requested GPU."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 10 and higher"]
    #[doc = "!"]
    #[doc = "! \\since Release: 440"]
    #[doc = "!"]
    #[doc = "! DESCRIPTION:     This API, when called with a valid physical gpu handle as Input, lets caller know whether the given workstation feature is supported by this GPU."]
    #[doc = "!"]
    #[doc = "! PARAMETERS:      physicalGpu(IN)            : The handle of the GPU for the which caller wants to get the support information."]
    #[doc = "!                  gpuWorkstationFeature(IN ) : The feature for the GPU in question. One of the values from enum NV_GPU_WORKSTATION_FEATURE_TYPE."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status listed below"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK the queried workstation feature is supported on the given GPU."]
    #[doc = "! \\retval ::NVAPI_NO_IMPLEMENTATION the current driver doesn't support this interface."]
    #[doc = "! \\retval ::NVAPI_INVALID_HANDLE the incoming physicalGpu handle is invalid."]
    #[doc = "! \\retval ::NVAPI_NOT_SUPPORTED the requested gpuWorkstationFeature is not supported in the selected GPU."]
    #[doc = "! \\retval ::NVAPI_SETTING_NOT_FOUND the requested gpuWorkstationFeature is unknown to the current driver version."]
    #[doc = "!"]
    #[doc = "! \\endcode"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_QueryWorkstationFeatureSupport(
        physicalGpu: NvPhysicalGpuHandle,
        gpuWorkstationFeature: NV_GPU_WORKSTATION_FEATURE_TYPE,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_SCANOUT_INTENSITY_DATA_V1 {
    #[doc = "!< version of this structure"]
    pub version: NvU32,
    #[doc = "!< width of the input texture"]
    pub width: NvU32,
    #[doc = "!< height of the input texture"]
    pub height: NvU32,
    #[doc = "!< array of floating values building an intensity RGB texture"]
    pub blendingTexture: *mut f32,
}
#[test]
fn bindgen_test_layout_NV_SCANOUT_INTENSITY_DATA_V1() {
    assert_eq!(
        ::std::mem::size_of::<NV_SCANOUT_INTENSITY_DATA_V1>(),
        24usize,
        concat!("Size of: ", stringify!(NV_SCANOUT_INTENSITY_DATA_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_SCANOUT_INTENSITY_DATA_V1>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_SCANOUT_INTENSITY_DATA_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_SCANOUT_INTENSITY_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_SCANOUT_INTENSITY_DATA_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_SCANOUT_INTENSITY_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_SCANOUT_INTENSITY_DATA_V1),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_SCANOUT_INTENSITY_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_SCANOUT_INTENSITY_DATA_V1),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_blendingTexture() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_SCANOUT_INTENSITY_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blendingTexture) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_SCANOUT_INTENSITY_DATA_V1),
                "::",
                stringify!(blendingTexture)
            )
        );
    }
    test_field_blendingTexture();
}
impl Default for NV_SCANOUT_INTENSITY_DATA_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_SCANOUT_INTENSITY_DATA_V2 {
    #[doc = "!< version of this structure"]
    pub version: NvU32,
    #[doc = "!< width of the input texture"]
    pub width: NvU32,
    #[doc = "!< height of the input texture"]
    pub height: NvU32,
    #[doc = "!< array of floating values building an intensity RGB texture"]
    pub blendingTexture: *mut f32,
    #[doc = "!< array of floating values building an offset texture"]
    pub offsetTexture: *mut f32,
    #[doc = "!< number of channels per pixel in the offset texture"]
    pub offsetTexChannels: NvU32,
}
#[test]
fn bindgen_test_layout_NV_SCANOUT_INTENSITY_DATA_V2() {
    assert_eq!(
        ::std::mem::size_of::<NV_SCANOUT_INTENSITY_DATA_V2>(),
        40usize,
        concat!("Size of: ", stringify!(NV_SCANOUT_INTENSITY_DATA_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_SCANOUT_INTENSITY_DATA_V2>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_SCANOUT_INTENSITY_DATA_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_SCANOUT_INTENSITY_DATA_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_SCANOUT_INTENSITY_DATA_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_SCANOUT_INTENSITY_DATA_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_SCANOUT_INTENSITY_DATA_V2),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_SCANOUT_INTENSITY_DATA_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_SCANOUT_INTENSITY_DATA_V2),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_blendingTexture() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_SCANOUT_INTENSITY_DATA_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blendingTexture) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_SCANOUT_INTENSITY_DATA_V2),
                "::",
                stringify!(blendingTexture)
            )
        );
    }
    test_field_blendingTexture();
    fn test_field_offsetTexture() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_SCANOUT_INTENSITY_DATA_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offsetTexture) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_SCANOUT_INTENSITY_DATA_V2),
                "::",
                stringify!(offsetTexture)
            )
        );
    }
    test_field_offsetTexture();
    fn test_field_offsetTexChannels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_SCANOUT_INTENSITY_DATA_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offsetTexChannels) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_SCANOUT_INTENSITY_DATA_V2),
                "::",
                stringify!(offsetTexChannels)
            )
        );
    }
    test_field_offsetTexChannels();
}
impl Default for NV_SCANOUT_INTENSITY_DATA_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup gpu"]
pub type NV_SCANOUT_INTENSITY_DATA = NV_SCANOUT_INTENSITY_DATA_V2;
extern "C" {
    #[doc = "!   DESCRIPTION: This API enables and sets up per-pixel intensity feature on the specified display."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]   displayId              combined physical display and GPU identifier of the display to apply the intensity control."]
    #[doc = "! \\param [in]   scanoutIntensityData   the intensity texture info."]
    #[doc = "! \\param [out]  pbSticky(OUT)           indicates whether the settings will be kept over a reboot."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT Invalid input parameters."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INITIALIZED NvAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT Invalid input data."]
    #[doc = "! \\retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION NV_SCANOUT_INTENSITY_DATA structure version mismatch."]
    #[doc = "! \\retval ::NVAPI_OK Feature enabled."]
    #[doc = "! \\retval ::NVAPI_ERROR Miscellaneous error occurred."]
    #[doc = "!"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_SetScanoutIntensity(
        displayId: NvU32,
        scanoutIntensityData: *mut NV_SCANOUT_INTENSITY_DATA,
        pbSticky: *mut ::std::os::raw::c_int,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_SCANOUT_INTENSITY_STATE_DATA {
    #[doc = "!< version of this structure"]
    pub version: NvU32,
    #[doc = "!< intensity is enabled or not"]
    pub bEnabled: NvU32,
}
#[test]
fn bindgen_test_layout__NV_SCANOUT_INTENSITY_STATE_DATA() {
    assert_eq!(
        ::std::mem::size_of::<_NV_SCANOUT_INTENSITY_STATE_DATA>(),
        8usize,
        concat!("Size of: ", stringify!(_NV_SCANOUT_INTENSITY_STATE_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_SCANOUT_INTENSITY_STATE_DATA>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_SCANOUT_INTENSITY_STATE_DATA)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_SCANOUT_INTENSITY_STATE_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SCANOUT_INTENSITY_STATE_DATA),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_bEnabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_SCANOUT_INTENSITY_STATE_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bEnabled) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SCANOUT_INTENSITY_STATE_DATA),
                "::",
                stringify!(bEnabled)
            )
        );
    }
    test_field_bEnabled();
}
#[doc = "! \\ingroup gpu"]
pub type NV_SCANOUT_INTENSITY_STATE_DATA = _NV_SCANOUT_INTENSITY_STATE_DATA;
extern "C" {
    #[doc = "!   DESCRIPTION: This API queries current state of the intensity feature on the specified display."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]     displayId                       combined physical display and GPU identifier of the display to query the configuration."]
    #[doc = "! \\param [in,out] scanoutIntensityStateData       intensity state data."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with"]
    #[doc = "!          specific meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT Invalid input parameters."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INITIALIZED NvAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs."]
    #[doc = "! \\retval ::NVAPI_OK Feature enabled."]
    #[doc = "! \\retval ::NVAPI_ERROR Miscellaneous error occurred."]
    #[doc = "!"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetScanoutIntensityState(
        displayId: NvU32,
        scanoutIntensityStateData: *mut NV_SCANOUT_INTENSITY_STATE_DATA,
    ) -> NvAPI_Status;
}
pub const NV_GPU_WARPING_VERTICE_FORMAT_NV_GPU_WARPING_VERTICE_FORMAT_TRIANGLESTRIP_XYUVRQ:
    NV_GPU_WARPING_VERTICE_FORMAT = 0;
pub const NV_GPU_WARPING_VERTICE_FORMAT_NV_GPU_WARPING_VERTICE_FORMAT_TRIANGLES_XYUVRQ:
    NV_GPU_WARPING_VERTICE_FORMAT = 1;
#[doc = "! \\ingroup gpu"]
pub type NV_GPU_WARPING_VERTICE_FORMAT = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_SCANOUT_WARPING_DATA {
    #[doc = "!< version of this structure"]
    pub version: NvU32,
    #[doc = "!< width of the input texture"]
    pub vertices: *mut f32,
    #[doc = "!< format of the input vertices"]
    pub vertexFormat: NV_GPU_WARPING_VERTICE_FORMAT,
    #[doc = "!< number of the input vertices"]
    pub numVertices: ::std::os::raw::c_int,
    #[doc = "!< rectangle in desktop coordinates describing the source area for the warping"]
    pub textureRect: *mut NvSBox,
}
#[test]
fn bindgen_test_layout_NV_SCANOUT_WARPING_DATA() {
    assert_eq!(
        ::std::mem::size_of::<NV_SCANOUT_WARPING_DATA>(),
        32usize,
        concat!("Size of: ", stringify!(NV_SCANOUT_WARPING_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_SCANOUT_WARPING_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_SCANOUT_WARPING_DATA))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_SCANOUT_WARPING_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_SCANOUT_WARPING_DATA),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_vertices() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_SCANOUT_WARPING_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertices) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_SCANOUT_WARPING_DATA),
                "::",
                stringify!(vertices)
            )
        );
    }
    test_field_vertices();
    fn test_field_vertexFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_SCANOUT_WARPING_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexFormat) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_SCANOUT_WARPING_DATA),
                "::",
                stringify!(vertexFormat)
            )
        );
    }
    test_field_vertexFormat();
    fn test_field_numVertices() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_SCANOUT_WARPING_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numVertices) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_SCANOUT_WARPING_DATA),
                "::",
                stringify!(numVertices)
            )
        );
    }
    test_field_numVertices();
    fn test_field_textureRect() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_SCANOUT_WARPING_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).textureRect) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_SCANOUT_WARPING_DATA),
                "::",
                stringify!(textureRect)
            )
        );
    }
    test_field_textureRect();
}
impl Default for NV_SCANOUT_WARPING_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API enables and sets up the warping feature on the specified display."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]    displayId               Combined physical display and GPU identifier of the display to apply the intensity control"]
    #[doc = "! \\param [in]    scanoutWarpingData      The warping data info"]
    #[doc = "! \\param [out]   pbSticky                Indicates whether the settings will be kept over a reboot."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT Invalid input parameters."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INITIALIZED NvAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT Invalid input data."]
    #[doc = "! \\retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION NV_SCANOUT_WARPING_DATA structure version mismatch."]
    #[doc = "! \\retval ::NVAPI_OK Feature enabled."]
    #[doc = "! \\retval ::NVAPI_ERROR Miscellaneous error occurred."]
    #[doc = "!"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_SetScanoutWarping(
        displayId: NvU32,
        scanoutWarpingData: *mut NV_SCANOUT_WARPING_DATA,
        piMaxNumVertices: *mut ::std::os::raw::c_int,
        pbSticky: *mut ::std::os::raw::c_int,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_SCANOUT_WARPING_STATE_DATA {
    #[doc = "!< version of this structure"]
    pub version: NvU32,
    #[doc = "!< warping is enabled or not"]
    pub bEnabled: NvU32,
}
#[test]
fn bindgen_test_layout__NV_SCANOUT_WARPING_STATE_DATA() {
    assert_eq!(
        ::std::mem::size_of::<_NV_SCANOUT_WARPING_STATE_DATA>(),
        8usize,
        concat!("Size of: ", stringify!(_NV_SCANOUT_WARPING_STATE_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_SCANOUT_WARPING_STATE_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_SCANOUT_WARPING_STATE_DATA))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_SCANOUT_WARPING_STATE_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SCANOUT_WARPING_STATE_DATA),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_bEnabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_SCANOUT_WARPING_STATE_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bEnabled) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SCANOUT_WARPING_STATE_DATA),
                "::",
                stringify!(bEnabled)
            )
        );
    }
    test_field_bEnabled();
}
#[doc = "! \\ingroup gpu"]
pub type NV_SCANOUT_WARPING_STATE_DATA = _NV_SCANOUT_WARPING_STATE_DATA;
extern "C" {
    #[doc = "!   DESCRIPTION: This API queries current state of the warping feature on the specified display."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]     displayId                      combined physical display and GPU identifier of the display to query the configuration."]
    #[doc = "! \\param [in,out] scanoutWarpingStateData        warping state data."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with"]
    #[doc = "!          specific meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT Invalid input parameters."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INITIALIZED NvAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs."]
    #[doc = "! \\retval ::NVAPI_OK Feature enabled."]
    #[doc = "! \\retval ::NVAPI_ERROR Miscellaneous error occurred."]
    #[doc = "!"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetScanoutWarpingState(
        displayId: NvU32,
        scanoutWarpingStateData: *mut NV_SCANOUT_WARPING_STATE_DATA,
    ) -> NvAPI_Status;
}
pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_NV_GPU_SCANOUT_COMPOSITION_PARAMETER_WARPING_RESAMPLING_METHOD : NV_GPU_SCANOUT_COMPOSITION_PARAMETER = 0 ;
pub type NV_GPU_SCANOUT_COMPOSITION_PARAMETER = ::std::os::raw::c_int;
pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_NV_GPU_SCANOUT_COMPOSITION_PARAMETER_SET_TO_DEFAULT : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = 0 ;
pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BILINEAR : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = 256 ;
pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_TRIANGULAR : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = 257 ;
pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_BELL_SHAPED : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = 258 ;
pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_BSPLINE : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = 259 ;
pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_ADAPTIVE_TRIANGULAR : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = 260 ;
pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_ADAPTIVE_BELL_SHAPED : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = 261 ;
pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_ADAPTIVE_BSPLINE : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = 262 ;
#[doc = "! This enum defines a collection of possible scanout composition values that can be used to configure"]
#[doc = "! possible scanout composition settings.  (Currently the only parameter defined is the WARPING_RESAMPLING_METHOD)."]
pub type NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = ::std::os::raw::c_int;
extern "C" {
    #[doc = "!   DESCRIPTION: This API sets various parameters that configure the scanout composition feature on the specified display."]
    #[doc = "!                (currently there is only one configurable parameter defined: WARPING_RESAMPLING_METHOD,"]
    #[doc = "!                 but this function is designed to support the addition of parameters as needed.)"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]    displayId               Combined physical display and GPU identifier of the display to apply the intensity control"]
    #[doc = "! \\param [in]    parameter               The scanout composition parameter to be set"]
    #[doc = "! \\param [in]    parameterValue          The data to be set for the specified parameter"]
    #[doc = "! \\param [in]    pContainer              Additional container for data associated with the specified parameter"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT Invalid input parameters."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INITIALIZED NvAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT Invalid input data."]
    #[doc = "! \\retval ::NVAPI_OK Feature enabled."]
    #[doc = "! \\retval ::NVAPI_ERROR Miscellaneous error occurred."]
    #[doc = "!"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_SetScanoutCompositionParameter(
        displayId: NvU32,
        parameter: NV_GPU_SCANOUT_COMPOSITION_PARAMETER,
        parameterValue: NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE,
        pContainer: *mut f32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API queries current state of one of the various scanout composition parameters on the specified display."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]     displayId           combined physical display and GPU identifier of the display to query the configuration."]
    #[doc = "! \\param [in]     parameter           scanout composition parameter to by queried."]
    #[doc = "! \\param [out] parameterData          scanout composition parameter data."]
    #[doc = "! \\param [out]   pContainer           Additional container for returning data associated with the specified parameter"]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with"]
    #[doc = "!          specific meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT Invalid input parameters."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INITIALIZED NvAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs."]
    #[doc = "! \\retval ::NVAPI_OK Feature enabled."]
    #[doc = "! \\retval ::NVAPI_ERROR Miscellaneous error occurred."]
    #[doc = "!"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetScanoutCompositionParameter(
        displayId: NvU32,
        parameter: NV_GPU_SCANOUT_COMPOSITION_PARAMETER,
        parameterData: *mut NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE,
        pContainer: *mut f32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API queries the desktop and scanout portion of the specified display."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]     displayId          combined physical display and GPU identifier of the display to query the configuration."]
    #[doc = "! \\param [in,out] desktopRect        desktop area of the display in desktop coordinates."]
    #[doc = "! \\param [in,out] scanoutRect        scanout area of the display relative to desktopRect."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT Invalid input parameters."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INITIALIZED NvAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs."]
    #[doc = "! \\retval ::NVAPI_OK Feature enabled."]
    #[doc = "! \\retval ::NVAPI_ERROR Miscellaneous error occurred."]
    #[doc = "!"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetScanoutConfiguration(
        displayId: NvU32,
        desktopRect: *mut NvSBox,
        scanoutRect: *mut NvSBox,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpu"]
#[doc = "! Used in NvAPI_GPU_GetScanoutConfigurationEx()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_SCANOUT_INFORMATION {
    #[doc = "!< Structure version, needs to be initialized with NV_SCANOUT_INFORMATION_VER."]
    pub version: NvU32,
    #[doc = "!< Operating system display device rect in desktop coordinates displayId is scanning out from."]
    pub sourceDesktopRect: NvSBox,
    #[doc = "!< Area inside the sourceDesktopRect which is scanned out to the display."]
    pub sourceViewportRect: NvSBox,
    #[doc = "!< Area inside the rect described by targetDisplayWidth/Height sourceViewportRect is scanned out to."]
    pub targetViewportRect: NvSBox,
    #[doc = "!< Horizontal size of the active resolution scanned out to the display."]
    pub targetDisplayWidth: NvU32,
    #[doc = "!< Vertical size of the active resolution scanned out to the display."]
    pub targetDisplayHeight: NvU32,
    #[doc = "!< If targets are cloned views of the sourceDesktopRect the cloned targets have an importance assigned (0:primary,1 secondary,...)."]
    pub cloneImportance: NvU32,
    #[doc = "!< Rotation performed between the sourceViewportRect and the targetViewportRect."]
    pub sourceToTargetRotation: NV_ROTATE,
}
#[test]
fn bindgen_test_layout__NV_SCANOUT_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_NV_SCANOUT_INFORMATION>(),
        68usize,
        concat!("Size of: ", stringify!(_NV_SCANOUT_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_SCANOUT_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_SCANOUT_INFORMATION))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_SCANOUT_INFORMATION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SCANOUT_INFORMATION),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_sourceDesktopRect() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_SCANOUT_INFORMATION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sourceDesktopRect) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SCANOUT_INFORMATION),
                "::",
                stringify!(sourceDesktopRect)
            )
        );
    }
    test_field_sourceDesktopRect();
    fn test_field_sourceViewportRect() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_SCANOUT_INFORMATION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sourceViewportRect) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SCANOUT_INFORMATION),
                "::",
                stringify!(sourceViewportRect)
            )
        );
    }
    test_field_sourceViewportRect();
    fn test_field_targetViewportRect() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_SCANOUT_INFORMATION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).targetViewportRect) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SCANOUT_INFORMATION),
                "::",
                stringify!(targetViewportRect)
            )
        );
    }
    test_field_targetViewportRect();
    fn test_field_targetDisplayWidth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_SCANOUT_INFORMATION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).targetDisplayWidth) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SCANOUT_INFORMATION),
                "::",
                stringify!(targetDisplayWidth)
            )
        );
    }
    test_field_targetDisplayWidth();
    fn test_field_targetDisplayHeight() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_SCANOUT_INFORMATION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).targetDisplayHeight) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SCANOUT_INFORMATION),
                "::",
                stringify!(targetDisplayHeight)
            )
        );
    }
    test_field_targetDisplayHeight();
    fn test_field_cloneImportance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_SCANOUT_INFORMATION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cloneImportance) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SCANOUT_INFORMATION),
                "::",
                stringify!(cloneImportance)
            )
        );
    }
    test_field_cloneImportance();
    fn test_field_sourceToTargetRotation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_SCANOUT_INFORMATION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sourceToTargetRotation) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SCANOUT_INFORMATION),
                "::",
                stringify!(sourceToTargetRotation)
            )
        );
    }
    test_field_sourceToTargetRotation();
}
impl Default for _NV_SCANOUT_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup gpu"]
#[doc = "! Used in NvAPI_GPU_GetScanoutConfigurationEx()."]
pub type NV_SCANOUT_INFORMATION = _NV_SCANOUT_INFORMATION;
extern "C" {
    #[doc = "!   DESCRIPTION: This API queries the desktop and scanout portion of the specified display."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "! \\since Release: 331"]
    #[doc = "!"]
    #[doc = "! \\param [in]     displayId            combined physical display and GPU identifier of the display to query the configuration."]
    #[doc = "! \\param [in,out] pScanoutInformation  desktop area to displayId mapping information."]
    #[doc = "!"]
    #[doc = "! \\return This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetScanoutConfigurationEx(
        displayId: NvU32,
        pScanoutInformation: *mut NV_SCANOUT_INFORMATION,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API returns the OS-AdapterID from physicalGpu Handle. OS-AdapterID"]
    #[doc = "!                is the Adapter ID that is used by Win7 CCD APIs."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]    hPhysicalGpu   PhysicalGpu Handle"]
    #[doc = "! \\param [out]   pOSAdapterId   Returns OS-AdapterId, it is typed as void * to"]
    #[doc = "!                               avoid dependency with windows.h. User must type cast it to LUID."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT pOSAdapterId is NULL; hPhysicalGpu is invalid"]
    #[doc = "! \\retval ::NVAPI_OK *pOSAdapterId contains valid data."]
    #[doc = "! \\retval ::NVAPI_NOT_SUPPORTED  This API is not supported on the system."]
    #[doc = "!"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetAdapterIdFromPhysicalGpu(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pOSAdapterId: *mut ::std::os::raw::c_void,
    ) -> NvAPI_Status;
}
#[doc = "!< Represents Bare Metal GPU"]
pub const _NV_VIRTUALIZATION_MODE_NV_VIRTUALIZATION_MODE_NONE: _NV_VIRTUALIZATION_MODE = 0;
#[doc = "!< Represents GPU-Passthrough"]
pub const _NV_VIRTUALIZATION_MODE_NV_VIRTUALIZATION_MODE_NMOS: _NV_VIRTUALIZATION_MODE = 1;
#[doc = "!< Represents vGPU inside virtual machine"]
pub const _NV_VIRTUALIZATION_MODE_NV_VIRTUALIZATION_MODE_VGX: _NV_VIRTUALIZATION_MODE = 2;
#[doc = "!< Represents VGX hypervisor in vGPU mode"]
pub const _NV_VIRTUALIZATION_MODE_NV_VIRTUALIZATION_MODE_HOST_VGPU: _NV_VIRTUALIZATION_MODE = 3;
#[doc = "! \\ingroup gpu"]
pub type _NV_VIRTUALIZATION_MODE = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpu"]
pub use self::_NV_VIRTUALIZATION_MODE as NV_VIRTUALIZATION_MODE;
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_VIRTUALIZATION_INFO {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< one of NV_VIRTUALIZATION_MODE."]
    pub virtualizationMode: NV_VIRTUALIZATION_MODE,
    #[doc = "!< reserved for future use. Should be set to ZERO."]
    pub reserved: NvU32,
}
#[test]
fn bindgen_test_layout__NV_GPU_VIRTUALIZATION_INFO() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_VIRTUALIZATION_INFO>(),
        12usize,
        concat!("Size of: ", stringify!(_NV_GPU_VIRTUALIZATION_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_VIRTUALIZATION_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GPU_VIRTUALIZATION_INFO))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_VIRTUALIZATION_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_VIRTUALIZATION_INFO),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_virtualizationMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_VIRTUALIZATION_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).virtualizationMode) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_VIRTUALIZATION_INFO),
                "::",
                stringify!(virtualizationMode)
            )
        );
    }
    test_field_virtualizationMode();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_VIRTUALIZATION_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_VIRTUALIZATION_INFO),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
impl Default for _NV_GPU_VIRTUALIZATION_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup gpu"]
pub type NV_GPU_VIRTUALIZATION_INFO_V1 = _NV_GPU_VIRTUALIZATION_INFO;
#[doc = "! \\ingroup gpu"]
pub type NV_GPU_VIRTUALIZATION_INFO = NV_GPU_VIRTUALIZATION_INFO_V1;
extern "C" {
    #[doc = ""]
    #[doc = "!"]
    #[doc = "! FUNCTION NAME: NvAPI_GPU_GetVirtualizationInfo"]
    #[doc = "!"]
    #[doc = "!   DESCRIPTION: This API returns virtualization information of the GPU"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 367"]
    #[doc = "!"]
    #[doc = "! \\param [in,out] pVirtualizationInfo         Pointer to NV_GPU_VIRTUALIZATION_INFO structure."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with"]
    #[doc = "!          specific meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetVirtualizationInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pVirtualizationInfo: *mut NV_GPU_VIRTUALIZATION_INFO,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LOGICAL_GPU_DATA_V1 {
    #[doc = "!< [in]  Structure version."]
    pub version: NvU32,
    #[doc = "!< [out] Returns OS-AdapterId. User must send memory buffer of size atleast equal to the size of LUID structure before calling the NVAPI."]
    pub pOSAdapterId: *mut ::std::os::raw::c_void,
    #[doc = "!< [out] Number of physical GPU handles associated with the specified logical GPU handle."]
    pub physicalGpuCount: NvU32,
    #[doc = "!< [out] This array will be filled with physical GPU handles associated with the given logical GPU handle."]
    #[doc = "!< The array index refers to the Physical Gpu Index (Idx)."]
    #[doc = "!< Idx value is the same as D3D11 MultiGPUDevice GPU index, D3D12 node index, OpenGL GL_NV_gpu_multicast GPU index."]
    #[doc = "!< When converted to a bit mask (1 << Idx), it matches:"]
    #[doc = "!<    1. Vulkan deviceNodeMask in VkPhysicalDeviceIDProperties"]
    #[doc = "!<    2. CUDA deviceNodeMask returned by cuDeviceGetLuid"]
    pub physicalGpuHandles: [NvPhysicalGpuHandle; 64usize],
    #[doc = "!< Reserved for future use. Should be set to ZERO."]
    pub reserved: [NvU32; 8usize],
}
#[test]
fn bindgen_test_layout__NV_LOGICAL_GPU_DATA_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_LOGICAL_GPU_DATA_V1>(),
        568usize,
        concat!("Size of: ", stringify!(_NV_LOGICAL_GPU_DATA_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LOGICAL_GPU_DATA_V1>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_LOGICAL_GPU_DATA_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LOGICAL_GPU_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LOGICAL_GPU_DATA_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_pOSAdapterId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LOGICAL_GPU_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pOSAdapterId) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LOGICAL_GPU_DATA_V1),
                "::",
                stringify!(pOSAdapterId)
            )
        );
    }
    test_field_pOSAdapterId();
    fn test_field_physicalGpuCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LOGICAL_GPU_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).physicalGpuCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LOGICAL_GPU_DATA_V1),
                "::",
                stringify!(physicalGpuCount)
            )
        );
    }
    test_field_physicalGpuCount();
    fn test_field_physicalGpuHandles() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LOGICAL_GPU_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).physicalGpuHandles) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LOGICAL_GPU_DATA_V1),
                "::",
                stringify!(physicalGpuHandles)
            )
        );
    }
    test_field_physicalGpuHandles();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LOGICAL_GPU_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            536usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LOGICAL_GPU_DATA_V1),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
impl Default for _NV_LOGICAL_GPU_DATA_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup gpu"]
pub type NV_LOGICAL_GPU_DATA_V1 = _NV_LOGICAL_GPU_DATA_V1;
#[doc = "! \\ingroup gpu"]
pub type NV_LOGICAL_GPU_DATA = NV_LOGICAL_GPU_DATA_V1;
extern "C" {
    #[doc = "!  This function is used to query Logical GPU information."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 421"]
    #[doc = "!"]
    #[doc = "! \\param [in]    hLogicalGpu            logical GPU Handle."]
    #[doc = "! \\param [inout] pLogicalGpuData        Pointer to NV_LOGICAL_GPU_DATA structure."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with"]
    #[doc = "!          specific meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetLogicalGpuInfo(
        hLogicalGpu: NvLogicalGpuHandle,
        pLogicalGpuData: *mut NV_LOGICAL_GPU_DATA,
    ) -> NvAPI_Status;
}
#[doc = "! License string"]
pub type NvAPI_LicenseString = [::std::os::raw::c_char; 128usize];
pub const _NV_LICENSE_FEATURE_TYPE_NV_LICENSE_FEATURE_UNKNOWN: _NV_LICENSE_FEATURE_TYPE = 0;
pub const _NV_LICENSE_FEATURE_TYPE_NV_LICENSE_FEATURE_VGPU: _NV_LICENSE_FEATURE_TYPE = 1;
pub const _NV_LICENSE_FEATURE_TYPE_NV_LICENSE_FEATURE_NVIDIA_RTX: _NV_LICENSE_FEATURE_TYPE = 2;
#[doc = "!< DEPRECATED name - do not use"]
pub const _NV_LICENSE_FEATURE_TYPE_NV_LICENSE_FEATURE_QUADRO: _NV_LICENSE_FEATURE_TYPE = 2;
pub const _NV_LICENSE_FEATURE_TYPE_NV_LICENSE_FEATURE_GAMING: _NV_LICENSE_FEATURE_TYPE = 3;
#[doc = "! Used in NV_LICENSE_FEATURE_DETAILS"]
pub type _NV_LICENSE_FEATURE_TYPE = ::std::os::raw::c_int;
#[doc = "! Used in NV_LICENSE_FEATURE_DETAILS"]
pub use self::_NV_LICENSE_FEATURE_TYPE as NV_LICENSE_FEATURE_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_LICENSE_EXPIRY_DETAILS {
    #[doc = "!< Year value of license expiry"]
    pub year: NvU32,
    #[doc = "!< Month value of license expiry"]
    pub month: NvU16,
    #[doc = "!< Day value of license expiry"]
    pub day: NvU16,
    #[doc = "!< Hour value of license expiry"]
    pub hour: NvU16,
    #[doc = "!< Minutes value of license expiry"]
    pub min: NvU16,
    #[doc = "!< Seconds value of license expiry"]
    pub sec: NvU16,
    #[doc = "!< License expiry status"]
    pub status: NvU8,
}
#[test]
fn bindgen_test_layout__NV_LICENSE_EXPIRY_DETAILS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_LICENSE_EXPIRY_DETAILS>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_LICENSE_EXPIRY_DETAILS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LICENSE_EXPIRY_DETAILS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_LICENSE_EXPIRY_DETAILS))
    );
    fn test_field_year() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_EXPIRY_DETAILS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).year) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_EXPIRY_DETAILS),
                "::",
                stringify!(year)
            )
        );
    }
    test_field_year();
    fn test_field_month() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_EXPIRY_DETAILS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).month) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_EXPIRY_DETAILS),
                "::",
                stringify!(month)
            )
        );
    }
    test_field_month();
    fn test_field_day() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_EXPIRY_DETAILS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).day) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_EXPIRY_DETAILS),
                "::",
                stringify!(day)
            )
        );
    }
    test_field_day();
    fn test_field_hour() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_EXPIRY_DETAILS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hour) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_EXPIRY_DETAILS),
                "::",
                stringify!(hour)
            )
        );
    }
    test_field_hour();
    fn test_field_min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_EXPIRY_DETAILS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_EXPIRY_DETAILS),
                "::",
                stringify!(min)
            )
        );
    }
    test_field_min();
    fn test_field_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_EXPIRY_DETAILS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sec) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_EXPIRY_DETAILS),
                "::",
                stringify!(sec)
            )
        );
    }
    test_field_sec();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_EXPIRY_DETAILS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_EXPIRY_DETAILS),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
}
pub type NV_LICENSE_EXPIRY_DETAILS = _NV_LICENSE_EXPIRY_DETAILS;
#[doc = "! Used in NV_LICENSABLE_FEATURES"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LICENSE_FEATURE_DETAILS_V1 {
    #[doc = "!< IN - Structure version."]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Feature code that corresponds to the licensable feature."]
    pub featureCode: NV_LICENSE_FEATURE_TYPE,
    #[doc = "!< Deprecated"]
    pub licenseInfo: NvAPI_LicenseString,
}
#[test]
fn bindgen_test_layout__NV_LICENSE_FEATURE_DETAILS_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_LICENSE_FEATURE_DETAILS_V1>(),
        140usize,
        concat!("Size of: ", stringify!(_NV_LICENSE_FEATURE_DETAILS_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LICENSE_FEATURE_DETAILS_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_LICENSE_FEATURE_DETAILS_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_FEATURE_DETAILS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_FEATURE_DETAILS_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_featureCode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_FEATURE_DETAILS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).featureCode) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_FEATURE_DETAILS_V1),
                "::",
                stringify!(featureCode)
            )
        );
    }
    test_field_featureCode();
    fn test_field_licenseInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_FEATURE_DETAILS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).licenseInfo) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_FEATURE_DETAILS_V1),
                "::",
                stringify!(licenseInfo)
            )
        );
    }
    test_field_licenseInfo();
}
impl Default for _NV_LICENSE_FEATURE_DETAILS_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_LICENSE_FEATURE_DETAILS_V1 {
    #[inline]
    pub fn isEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isEnabled: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isEnabled: u32 = unsafe { ::std::mem::transmute(isEnabled) };
            isEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! Used in NV_LICENSABLE_FEATURES"]
pub type NV_LICENSE_FEATURE_DETAILS_V1 = _NV_LICENSE_FEATURE_DETAILS_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LICENSE_FEATURE_DETAILS_V2 {
    #[doc = "!< Unused."]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Feature code that corresponds to the licensable feature."]
    pub featureCode: NV_LICENSE_FEATURE_TYPE,
    #[doc = "!< Deprecated"]
    pub licenseInfo: NvAPI_LicenseString,
    #[doc = "!< Nvidia Grid licensable product name."]
    pub productName: NvAPI_LicenseString,
}
#[test]
fn bindgen_test_layout__NV_LICENSE_FEATURE_DETAILS_V2() {
    assert_eq!(
        ::std::mem::size_of::<_NV_LICENSE_FEATURE_DETAILS_V2>(),
        268usize,
        concat!("Size of: ", stringify!(_NV_LICENSE_FEATURE_DETAILS_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LICENSE_FEATURE_DETAILS_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_LICENSE_FEATURE_DETAILS_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_FEATURE_DETAILS_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_FEATURE_DETAILS_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_featureCode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_FEATURE_DETAILS_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).featureCode) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_FEATURE_DETAILS_V2),
                "::",
                stringify!(featureCode)
            )
        );
    }
    test_field_featureCode();
    fn test_field_licenseInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_FEATURE_DETAILS_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).licenseInfo) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_FEATURE_DETAILS_V2),
                "::",
                stringify!(licenseInfo)
            )
        );
    }
    test_field_licenseInfo();
    fn test_field_productName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_FEATURE_DETAILS_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).productName) as usize - ptr as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_FEATURE_DETAILS_V2),
                "::",
                stringify!(productName)
            )
        );
    }
    test_field_productName();
}
impl Default for _NV_LICENSE_FEATURE_DETAILS_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_LICENSE_FEATURE_DETAILS_V2 {
    #[inline]
    pub fn isEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isEnabled: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isEnabled: u32 = unsafe { ::std::mem::transmute(isEnabled) };
            isEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_LICENSE_FEATURE_DETAILS_V2 = _NV_LICENSE_FEATURE_DETAILS_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LICENSE_FEATURE_DETAILS_V3 {
    #[doc = "!< Unused."]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Feature code that corresponds to the licensable feature."]
    pub featureCode: NV_LICENSE_FEATURE_TYPE,
    #[doc = "!< Deprecated"]
    pub licenseInfo: NvAPI_LicenseString,
    #[doc = "!< Nvidia Grid licensable product name."]
    pub productName: NvAPI_LicenseString,
}
#[test]
fn bindgen_test_layout__NV_LICENSE_FEATURE_DETAILS_V3() {
    assert_eq!(
        ::std::mem::size_of::<_NV_LICENSE_FEATURE_DETAILS_V3>(),
        268usize,
        concat!("Size of: ", stringify!(_NV_LICENSE_FEATURE_DETAILS_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LICENSE_FEATURE_DETAILS_V3>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_LICENSE_FEATURE_DETAILS_V3))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_FEATURE_DETAILS_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_FEATURE_DETAILS_V3),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_featureCode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_FEATURE_DETAILS_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).featureCode) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_FEATURE_DETAILS_V3),
                "::",
                stringify!(featureCode)
            )
        );
    }
    test_field_featureCode();
    fn test_field_licenseInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_FEATURE_DETAILS_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).licenseInfo) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_FEATURE_DETAILS_V3),
                "::",
                stringify!(licenseInfo)
            )
        );
    }
    test_field_licenseInfo();
    fn test_field_productName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_FEATURE_DETAILS_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).productName) as usize - ptr as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_FEATURE_DETAILS_V3),
                "::",
                stringify!(productName)
            )
        );
    }
    test_field_productName();
}
impl Default for _NV_LICENSE_FEATURE_DETAILS_V3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_LICENSE_FEATURE_DETAILS_V3 {
    #[inline]
    pub fn isEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isFeatureEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isFeatureEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isEnabled: NvU32,
        isFeatureEnabled: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isEnabled: u32 = unsafe { ::std::mem::transmute(isEnabled) };
            isEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isFeatureEnabled: u32 = unsafe { ::std::mem::transmute(isFeatureEnabled) };
            isFeatureEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_LICENSE_FEATURE_DETAILS_V3 = _NV_LICENSE_FEATURE_DETAILS_V3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LICENSE_FEATURE_DETAILS_V4 {
    #[doc = "!< Unused."]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Feature code that corresponds to the licensable feature."]
    pub featureCode: NV_LICENSE_FEATURE_TYPE,
    #[doc = "!< Deprecated"]
    pub licenseInfo: NvAPI_LicenseString,
    #[doc = "!< Nvidia Grid licensable product name."]
    pub productName: NvAPI_LicenseString,
    #[doc = "!< License expiry information."]
    pub licenseExpiry: NV_LICENSE_EXPIRY_DETAILS,
}
#[test]
fn bindgen_test_layout__NV_LICENSE_FEATURE_DETAILS_V4() {
    assert_eq!(
        ::std::mem::size_of::<_NV_LICENSE_FEATURE_DETAILS_V4>(),
        284usize,
        concat!("Size of: ", stringify!(_NV_LICENSE_FEATURE_DETAILS_V4))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LICENSE_FEATURE_DETAILS_V4>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_LICENSE_FEATURE_DETAILS_V4))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_FEATURE_DETAILS_V4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_FEATURE_DETAILS_V4),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_featureCode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_FEATURE_DETAILS_V4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).featureCode) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_FEATURE_DETAILS_V4),
                "::",
                stringify!(featureCode)
            )
        );
    }
    test_field_featureCode();
    fn test_field_licenseInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_FEATURE_DETAILS_V4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).licenseInfo) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_FEATURE_DETAILS_V4),
                "::",
                stringify!(licenseInfo)
            )
        );
    }
    test_field_licenseInfo();
    fn test_field_productName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_FEATURE_DETAILS_V4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).productName) as usize - ptr as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_FEATURE_DETAILS_V4),
                "::",
                stringify!(productName)
            )
        );
    }
    test_field_productName();
    fn test_field_licenseExpiry() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSE_FEATURE_DETAILS_V4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).licenseExpiry) as usize - ptr as usize
            },
            268usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSE_FEATURE_DETAILS_V4),
                "::",
                stringify!(licenseExpiry)
            )
        );
    }
    test_field_licenseExpiry();
}
impl Default for _NV_LICENSE_FEATURE_DETAILS_V4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_LICENSE_FEATURE_DETAILS_V4 {
    #[inline]
    pub fn isEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isFeatureEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isFeatureEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isEnabled: NvU32,
        isFeatureEnabled: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isEnabled: u32 = unsafe { ::std::mem::transmute(isEnabled) };
            isEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isFeatureEnabled: u32 = unsafe { ::std::mem::transmute(isFeatureEnabled) };
            isFeatureEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_LICENSE_FEATURE_DETAILS_V4 = _NV_LICENSE_FEATURE_DETAILS_V4;
#[doc = "! Used in NV_LICENSABLE_FEATURES"]
pub type NV_LICENSE_FEATURE_DETAILS = NV_LICENSE_FEATURE_DETAILS_V1;
#[doc = "! Licensable features"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LICENSABLE_FEATURES_V1 {
    #[doc = "!< IN - Structure version."]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< The number of licensable features."]
    pub licensableFeatureCount: NvU32,
    #[doc = "!< Dynamic signature required for Authentication of the components,"]
    #[doc = "!< signature length limited to NV_LICENSE_SIGNATURE_SIZE"]
    pub signature: [NvU8; 128usize],
    #[doc = "!< Array of licensable features"]
    pub licenseDetails: [NV_LICENSE_FEATURE_DETAILS_V1; 3usize],
}
#[test]
fn bindgen_test_layout__NV_LICENSABLE_FEATURES_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_LICENSABLE_FEATURES_V1>(),
        560usize,
        concat!("Size of: ", stringify!(_NV_LICENSABLE_FEATURES_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LICENSABLE_FEATURES_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_LICENSABLE_FEATURES_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSABLE_FEATURES_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSABLE_FEATURES_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_licensableFeatureCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSABLE_FEATURES_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).licensableFeatureCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSABLE_FEATURES_V1),
                "::",
                stringify!(licensableFeatureCount)
            )
        );
    }
    test_field_licensableFeatureCount();
    fn test_field_signature() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSABLE_FEATURES_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signature) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSABLE_FEATURES_V1),
                "::",
                stringify!(signature)
            )
        );
    }
    test_field_signature();
    fn test_field_licenseDetails() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSABLE_FEATURES_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).licenseDetails) as usize - ptr as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSABLE_FEATURES_V1),
                "::",
                stringify!(licenseDetails)
            )
        );
    }
    test_field_licenseDetails();
}
impl Default for _NV_LICENSABLE_FEATURES_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_LICENSABLE_FEATURES_V1 {
    #[inline]
    pub fn isLicenseSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isLicenseSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isLicenseSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isLicenseSupported: u32 = unsafe { ::std::mem::transmute(isLicenseSupported) };
            isLicenseSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! Licensable features"]
pub type NV_LICENSABLE_FEATURES_V1 = _NV_LICENSABLE_FEATURES_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LICENSABLE_FEATURES_V2 {
    #[doc = "!< IN - Structure version."]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< The number of licensable features."]
    pub licensableFeatureCount: NvU32,
    #[doc = "!< Dynamic signature required for Authentication of the components,"]
    #[doc = "!< signature length limited to NV_LICENSE_SIGNATURE_SIZE"]
    pub signature: [NvU8; 128usize],
    #[doc = "!< Array of licensable features"]
    pub licenseDetails: [NV_LICENSE_FEATURE_DETAILS_V2; 3usize],
}
#[test]
fn bindgen_test_layout__NV_LICENSABLE_FEATURES_V2() {
    assert_eq!(
        ::std::mem::size_of::<_NV_LICENSABLE_FEATURES_V2>(),
        944usize,
        concat!("Size of: ", stringify!(_NV_LICENSABLE_FEATURES_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LICENSABLE_FEATURES_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_LICENSABLE_FEATURES_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSABLE_FEATURES_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSABLE_FEATURES_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_licensableFeatureCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSABLE_FEATURES_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).licensableFeatureCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSABLE_FEATURES_V2),
                "::",
                stringify!(licensableFeatureCount)
            )
        );
    }
    test_field_licensableFeatureCount();
    fn test_field_signature() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSABLE_FEATURES_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signature) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSABLE_FEATURES_V2),
                "::",
                stringify!(signature)
            )
        );
    }
    test_field_signature();
    fn test_field_licenseDetails() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSABLE_FEATURES_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).licenseDetails) as usize - ptr as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSABLE_FEATURES_V2),
                "::",
                stringify!(licenseDetails)
            )
        );
    }
    test_field_licenseDetails();
}
impl Default for _NV_LICENSABLE_FEATURES_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_LICENSABLE_FEATURES_V2 {
    #[inline]
    pub fn isLicenseSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isLicenseSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isLicenseSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isLicenseSupported: u32 = unsafe { ::std::mem::transmute(isLicenseSupported) };
            isLicenseSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_LICENSABLE_FEATURES_V2 = _NV_LICENSABLE_FEATURES_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LICENSABLE_FEATURES_V3 {
    #[doc = "!< IN - Structure version."]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< The number of licensable features."]
    pub licensableFeatureCount: NvU32,
    #[doc = "!< Dynamic signature required for Authentication of the components,"]
    #[doc = "!< signature length limited to NV_LICENSE_SIGNATURE_SIZE"]
    pub signature: [NvU8; 128usize],
    #[doc = "!< Array of licensable features"]
    pub licenseDetails: [NV_LICENSE_FEATURE_DETAILS_V3; 3usize],
}
#[test]
fn bindgen_test_layout__NV_LICENSABLE_FEATURES_V3() {
    assert_eq!(
        ::std::mem::size_of::<_NV_LICENSABLE_FEATURES_V3>(),
        944usize,
        concat!("Size of: ", stringify!(_NV_LICENSABLE_FEATURES_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LICENSABLE_FEATURES_V3>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_LICENSABLE_FEATURES_V3))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSABLE_FEATURES_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSABLE_FEATURES_V3),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_licensableFeatureCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSABLE_FEATURES_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).licensableFeatureCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSABLE_FEATURES_V3),
                "::",
                stringify!(licensableFeatureCount)
            )
        );
    }
    test_field_licensableFeatureCount();
    fn test_field_signature() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSABLE_FEATURES_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signature) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSABLE_FEATURES_V3),
                "::",
                stringify!(signature)
            )
        );
    }
    test_field_signature();
    fn test_field_licenseDetails() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSABLE_FEATURES_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).licenseDetails) as usize - ptr as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSABLE_FEATURES_V3),
                "::",
                stringify!(licenseDetails)
            )
        );
    }
    test_field_licenseDetails();
}
impl Default for _NV_LICENSABLE_FEATURES_V3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_LICENSABLE_FEATURES_V3 {
    #[inline]
    pub fn isLicenseSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isLicenseSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isLicenseSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isLicenseSupported: u32 = unsafe { ::std::mem::transmute(isLicenseSupported) };
            isLicenseSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_LICENSABLE_FEATURES_V3 = _NV_LICENSABLE_FEATURES_V3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LICENSABLE_FEATURES_V4 {
    #[doc = "!< IN - Structure version."]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< The number of licensable features."]
    pub licensableFeatureCount: NvU32,
    #[doc = "!< Dynamic signature required for Authentication of the components,"]
    #[doc = "!< signature length limited to NV_LICENSE_SIGNATURE_SIZE"]
    pub signature: [NvU8; 128usize],
    #[doc = "!< Array of licensable features"]
    pub licenseDetails: [NV_LICENSE_FEATURE_DETAILS_V4; 3usize],
}
#[test]
fn bindgen_test_layout__NV_LICENSABLE_FEATURES_V4() {
    assert_eq!(
        ::std::mem::size_of::<_NV_LICENSABLE_FEATURES_V4>(),
        992usize,
        concat!("Size of: ", stringify!(_NV_LICENSABLE_FEATURES_V4))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LICENSABLE_FEATURES_V4>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_LICENSABLE_FEATURES_V4))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSABLE_FEATURES_V4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSABLE_FEATURES_V4),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_licensableFeatureCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSABLE_FEATURES_V4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).licensableFeatureCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSABLE_FEATURES_V4),
                "::",
                stringify!(licensableFeatureCount)
            )
        );
    }
    test_field_licensableFeatureCount();
    fn test_field_signature() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSABLE_FEATURES_V4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signature) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSABLE_FEATURES_V4),
                "::",
                stringify!(signature)
            )
        );
    }
    test_field_signature();
    fn test_field_licenseDetails() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LICENSABLE_FEATURES_V4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).licenseDetails) as usize - ptr as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LICENSABLE_FEATURES_V4),
                "::",
                stringify!(licenseDetails)
            )
        );
    }
    test_field_licenseDetails();
}
impl Default for _NV_LICENSABLE_FEATURES_V4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_LICENSABLE_FEATURES_V4 {
    #[inline]
    pub fn isLicenseSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isLicenseSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isLicenseSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isLicenseSupported: u32 = unsafe { ::std::mem::transmute(isLicenseSupported) };
            isLicenseSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_LICENSABLE_FEATURES_V4 = _NV_LICENSABLE_FEATURES_V4;
pub type NV_LICENSABLE_FEATURES = NV_LICENSABLE_FEATURES_V4;
extern "C" {
    #[doc = "!   DESCRIPTION:   This function call identifies whether licenses are supported on this system and if"]
    #[doc = "!                  they are supported, returns the details of the features that can be licensed."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\param [in]  hPhysicalGpu                   GPU selection"]
    #[doc = "! \\param [in,out] pLicensableFeatures         Licensable features information."]
    #[doc = "!"]
    #[doc = "! \\return This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!         If there are return error codes with specific meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\ingroup gridlicense"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetLicensableFeatures(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pLicensableFeatures: *mut NV_LICENSABLE_FEATURES,
    ) -> NvAPI_Status;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_GPU_VR_READY_V1 {
    #[doc = "!< Structure Version."]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NV_GPU_VR_READY_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_VR_READY_V1>(),
        8usize,
        concat!("Size of: ", stringify!(_NV_GPU_VR_READY_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_VR_READY_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GPU_VR_READY_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_VR_READY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_VR_READY_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
}
impl _NV_GPU_VR_READY_V1 {
    #[inline]
    pub fn isVRReady(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isVRReady(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isVRReady: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isVRReady: u32 = unsafe { ::std::mem::transmute(isVRReady) };
            isVRReady as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GPU_VR_READY_V1 = _NV_GPU_VR_READY_V1;
pub type NV_GPU_VR_READY = NV_GPU_VR_READY_V1;
extern "C" {
    #[doc = "! DESCRIPTION: This API will return NVIDIA GPU VR Ready state."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 10 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 465"]
    #[doc = "!"]
    #[doc = "! \\param [inout] pGpuVrReadyData - This structure will be filled with required information."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in"]
    #[doc = "!          #NvAPI_Status.  If there are return error codes with specific"]
    #[doc = "!          meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetVRReadyData(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pGpuVrReadyData: *mut NV_GPU_VR_READY,
    ) -> NvAPI_Status;
}
#[doc = "!< No Slowdown detected"]
pub const _NVAPI_GPU_PERF_DECREASE_NV_GPU_PERF_DECREASE_NONE: _NVAPI_GPU_PERF_DECREASE = 0;
#[doc = "!< Thermal slowdown/shutdown/POR thermal protection"]
pub const _NVAPI_GPU_PERF_DECREASE_NV_GPU_PERF_DECREASE_REASON_THERMAL_PROTECTION:
    _NVAPI_GPU_PERF_DECREASE = 1;
#[doc = "!< Power capping / pstate cap"]
pub const _NVAPI_GPU_PERF_DECREASE_NV_GPU_PERF_DECREASE_REASON_POWER_CONTROL:
    _NVAPI_GPU_PERF_DECREASE = 2;
#[doc = "!< AC->BATT event"]
pub const _NVAPI_GPU_PERF_DECREASE_NV_GPU_PERF_DECREASE_REASON_AC_BATT: _NVAPI_GPU_PERF_DECREASE =
    4;
#[doc = "!< API triggered slowdown"]
pub const _NVAPI_GPU_PERF_DECREASE_NV_GPU_PERF_DECREASE_REASON_API_TRIGGERED:
    _NVAPI_GPU_PERF_DECREASE = 8;
#[doc = "!< Power connector missing"]
pub const _NVAPI_GPU_PERF_DECREASE_NV_GPU_PERF_DECREASE_REASON_INSUFFICIENT_POWER:
    _NVAPI_GPU_PERF_DECREASE = 16;
#[doc = "!< Unknown reason"]
pub const _NVAPI_GPU_PERF_DECREASE_NV_GPU_PERF_DECREASE_REASON_UNKNOWN: _NVAPI_GPU_PERF_DECREASE =
    -2147483648;
#[doc = "! Used in NvAPI_GPU_GetPerfDecreaseInfo."]
#[doc = "! Bit masks for knowing the exact reason for performance decrease"]
pub type _NVAPI_GPU_PERF_DECREASE = ::std::os::raw::c_int;
#[doc = "! Used in NvAPI_GPU_GetPerfDecreaseInfo."]
#[doc = "! Bit masks for knowing the exact reason for performance decrease"]
pub use self::_NVAPI_GPU_PERF_DECREASE as NVAPI_GPU_PERF_DECREASE;
extern "C" {
    #[doc = "! DESCRIPTION:   This function retrieves - in NvU32 variable - reasons for the current performance decrease."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "! \\param [in]      hPhysicalGPU    (IN)    - GPU for which performance decrease is to be evaluated."]
    #[doc = "! \\param [out]  pPerfDecrInfo    (OUT)    - Pointer to a NvU32 variable containing performance decrease info"]
    #[doc = "!"]
    #[doc = "! \\return      This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!"]
    #[doc = "! \\ingroup gpuPerf"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetPerfDecreaseInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pPerfDecrInfo: *mut NvU32,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpupstate"]
#[doc = "! Used in NvAPI_GPU_GetPstatesInfoEx()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES_INFO_V1 {
    pub version: NvU32,
    #[doc = "!< - bit 0 indicates if perfmon is enabled or not"]
    #[doc = "!< - bit 1 indicates if dynamic Pstate is capable or not"]
    #[doc = "!< - bit 2 indicates if dynamic Pstate is enable or not"]
    #[doc = "!< - all other bits must be set to 0"]
    pub flags: NvU32,
    #[doc = "!< The number of available p-states"]
    pub numPstates: NvU32,
    #[doc = "!< The number of clock domains supported by each P-State"]
    pub numClocks: NvU32,
    pub pstates: [NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1 {
    #[doc = "!< ID of the p-state."]
    pub pstateId: NV_GPU_PERF_PSTATE_ID,
    #[doc = "!< - bit 0 indicates if the PCIE limit is GEN1 or GEN2"]
    #[doc = "!< - bit 1 indicates if the Pstate is overclocked or not"]
    #[doc = "!< - bit 2 indicates if the Pstate is overclockable or not"]
    #[doc = "!< - all other bits must be set to 0"]
    pub flags: NvU32,
    pub clocks: [NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "!< ID of the clock domain"]
    pub domainId: NV_GPU_PUBLIC_CLOCK_ID,
    #[doc = "!< Reserved. Must be set to 0"]
    pub flags: NvU32,
    #[doc = "!< Clock frequency in kHz"]
    pub freq: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_domainId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).domainId) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(domainId)
            )
        );
    }
    test_field_domainId();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_freq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).freq) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(freq)
            )
        );
    }
    test_field_freq();
}
impl Default for NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1>(),
        392usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1)
        )
    );
    fn test_field_pstateId() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pstateId) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1),
                "::",
                stringify!(pstateId)
            )
        );
    }
    test_field_pstateId();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_clocks() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clocks) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1),
                "::",
                stringify!(clocks)
            )
        );
    }
    test_field_clocks();
}
impl Default for NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES_INFO_V1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES_INFO_V1>(),
        6288usize,
        concat!("Size of: ", stringify!(NV_GPU_PERF_PSTATES_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES_INFO_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_PERF_PSTATES_INFO_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V1),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_numPstates() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numPstates) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V1),
                "::",
                stringify!(numPstates)
            )
        );
    }
    test_field_numPstates();
    fn test_field_numClocks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numClocks) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V1),
                "::",
                stringify!(numClocks)
            )
        );
    }
    test_field_numClocks();
    fn test_field_pstates() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pstates) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V1),
                "::",
                stringify!(pstates)
            )
        );
    }
    test_field_pstates();
}
impl Default for NV_GPU_PERF_PSTATES_INFO_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup gpupstate"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES_INFO_V2 {
    pub version: NvU32,
    #[doc = "!< - bit 0 indicates if perfmon is enabled or not"]
    #[doc = "!< - bit 1 indicates if dynamic Pstate is capable or not"]
    #[doc = "!< - bit 2 indicates if dynamic Pstate is enable or not"]
    #[doc = "!< - all other bits must be set to 0"]
    pub flags: NvU32,
    #[doc = "!< The number of available p-states"]
    pub numPstates: NvU32,
    #[doc = "!< The number of clock domains supported by each P-State"]
    pub numClocks: NvU32,
    pub numVoltages: NvU32,
    #[doc = "!< Valid index range is 0 to numVoltages-1"]
    pub pstates: [NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1 {
    #[doc = "!< ID of the p-state."]
    pub pstateId: NV_GPU_PERF_PSTATE_ID,
    #[doc = "!< - bit 0 indicates if the PCIE limit is GEN1 or GEN2"]
    #[doc = "!< - bit 1 indicates if the Pstate is overclocked or not"]
    #[doc = "!< - bit 2 indicates if the Pstate is overclockable or not"]
    #[doc = "!< - all other bits must be set to 0"]
    pub flags: NvU32,
    pub clocks: [NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1; 32usize],
    pub voltages: [NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1 {
    pub domainId: NV_GPU_PUBLIC_CLOCK_ID,
    #[doc = "!< bit 0 indicates if this clock is overclockable"]
    #[doc = "!< all other bits must be set to 0"]
    pub flags: NvU32,
    pub freq: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_domainId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).domainId) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(domainId)
            )
        );
    }
    test_field_domainId();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_freq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).freq) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(freq)
            )
        );
    }
    test_field_freq();
}
impl Default for NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "!< ID of the voltage domain, containing flags and mvolt info"]
    pub domainId: NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID,
    #[doc = "!< Reserved for future use. Must be set to 0"]
    pub flags: NvU32,
    #[doc = "!< Voltage in mV"]
    pub mvolt: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_domainId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).domainId) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(domainId)
            )
        );
    }
    test_field_domainId();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_mvolt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mvolt) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(mvolt)
            )
        );
    }
    test_field_mvolt();
}
impl Default for NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1>(),
        584usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1)
        )
    );
    fn test_field_pstateId() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pstateId) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1),
                "::",
                stringify!(pstateId)
            )
        );
    }
    test_field_pstateId();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_clocks() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clocks) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1),
                "::",
                stringify!(clocks)
            )
        );
    }
    test_field_clocks();
    fn test_field_voltages() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).voltages) as usize - ptr as usize
            },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1),
                "::",
                stringify!(voltages)
            )
        );
    }
    test_field_voltages();
}
impl Default for NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES_INFO_V2() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES_INFO_V2>(),
        9364usize,
        concat!("Size of: ", stringify!(NV_GPU_PERF_PSTATES_INFO_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES_INFO_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_PERF_PSTATES_INFO_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V2),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_numPstates() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numPstates) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V2),
                "::",
                stringify!(numPstates)
            )
        );
    }
    test_field_numPstates();
    fn test_field_numClocks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numClocks) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V2),
                "::",
                stringify!(numClocks)
            )
        );
    }
    test_field_numClocks();
    fn test_field_numVoltages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numVoltages) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V2),
                "::",
                stringify!(numVoltages)
            )
        );
    }
    test_field_numVoltages();
    fn test_field_pstates() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_PERF_PSTATES_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pstates) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_PERF_PSTATES_INFO_V2),
                "::",
                stringify!(pstates)
            )
        );
    }
    test_field_pstates();
}
impl Default for NV_GPU_PERF_PSTATES_INFO_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup gpupstate"]
pub type NV_GPU_PERF_PSTATES_INFO = NV_GPU_PERF_PSTATES_INFO_V2;
extern "C" {
    #[doc = "! DESCRIPTION:     This API retrieves all performance states (P-States) information. This is the same as"]
    #[doc = "!                  NvAPI_GPU_GetPstatesInfo(), but supports an input flag for various options."]
    #[doc = "!"]
    #[doc = "!                  P-States are GPU active/executing performance capability and power consumption states."]
    #[doc = "!"]
    #[doc = "!                  P-States ranges from P0 to P15, with P0 being the highest performance/power state, and"]
    #[doc = "!                  P15 being the lowest performance/power state. Each P-State, if available, maps to a"]
    #[doc = "!                  performance level. Not all P-States are available on a given system. The definitions"]
    #[doc = "!                  of each P-State are currently as follows: \\n"]
    #[doc = "!                  - P0/P1 - Maximum 3D performance"]
    #[doc = "!                  - P2/P3 - Balanced 3D performance-power"]
    #[doc = "!                  - P8 - Basic HD video playback"]
    #[doc = "!                  - P10 - DVD playback"]
    #[doc = "!                  - P12 - Minimum idle power consumption"]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 304. Instead, use NvAPI_GPU_GetPstates20."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]     hPhysicalGPU       GPU selection."]
    #[doc = "! \\param [out]    pPerfPstatesInfo   P-States information retrieved, as detailed below: \\n"]
    #[doc = "!                  - flags is reserved for future use."]
    #[doc = "!                  - numPstates is the number of available P-States"]
    #[doc = "!                  - numClocks is the number of clock domains supported by each P-State"]
    #[doc = "!                  - pstates has valid index range from 0 to numPstates - 1"]
    #[doc = "!                  - pstates[i].pstateId is the ID of the P-State,"]
    #[doc = "!                      containing the following info:"]
    #[doc = "!                    - pstates[i].flags containing the following info:"]
    #[doc = "!                        - bit 0 indicates if the PCIE limit is GEN1 or GEN2"]
    #[doc = "!                        - bit 1 indicates if the Pstate is overclocked or not"]
    #[doc = "!                        - bit 2 indicates if the Pstate is overclockable or not"]
    #[doc = "!                    - pstates[i].clocks has valid index range from 0 to numClocks -1"]
    #[doc = "!                    - pstates[i].clocks[j].domainId is the public ID of the clock domain,"]
    #[doc = "!                        containing the following info:"]
    #[doc = "!                      - pstates[i].clocks[j].flags containing the following info:"]
    #[doc = "!                          bit 0 indicates if the clock domain is overclockable or not"]
    #[doc = "!                      - pstates[i].clocks[j].freq is the clock frequency in kHz"]
    #[doc = "!                    - pstates[i].voltages has a valid index range from 0 to numVoltages - 1"]
    #[doc = "!                    - pstates[i].voltages[j].domainId is the ID of the voltage domain,"]
    #[doc = "!                        containing the following info:"]
    #[doc = "!                      - pstates[i].voltages[j].flags is reserved for future use."]
    #[doc = "!                      - pstates[i].voltages[j].mvolt is the voltage in mV"]
    #[doc = "!                  inputFlags(IN)   - This can be used to select various options:"]
    #[doc = "!                    - if bit 0 is set, pPerfPstatesInfo would contain the default settings"]
    #[doc = "!                        instead of the current, possibily overclocked settings."]
    #[doc = "!                    - if bit 1 is set, pPerfPstatesInfo would contain the maximum clock"]
    #[doc = "!                        frequencies instead of the nominal frequencies."]
    #[doc = "!                    - if bit 2 is set, pPerfPstatesInfo would contain the minimum clock"]
    #[doc = "!                        frequencies instead of the nominal frequencies."]
    #[doc = "!                    - all other bits must be set to 0."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                            Completed request"]
    #[doc = "! \\retval ::NVAPI_ERROR                         Miscellaneous error occurred"]
    #[doc = "! \\retval ::NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide)"]
    #[doc = "! \\retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle"]
    #[doc = "! \\retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the NV_GPU_PERF_PSTATES struct is not supported"]
    #[doc = "!"]
    #[doc = "! \\ingroup gpupstate"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetPstatesInfoEx(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pPerfPstatesInfo: *mut NV_GPU_PERF_PSTATES_INFO,
        inputFlags: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:    This API retrieves all performance states (P-States) 2.0 information."]
    #[doc = "!"]
    #[doc = "!                 P-States are GPU active/executing performance capability states."]
    #[doc = "!                 They range from P0 to P15, with P0 being the highest performance state,"]
    #[doc = "!                 and P15 being the lowest performance state. Each P-State, if available,"]
    #[doc = "!                 maps to a performance level. Not all P-States are available on a given system."]
    #[doc = "!                 The definition of each P-States are currently as follow:"]
    #[doc = "!                 - P0/P1 - Maximum 3D performance"]
    #[doc = "!                 - P2/P3 - Balanced 3D performance-power"]
    #[doc = "!                 - P8 - Basic HD video playback"]
    #[doc = "!                 - P10 - DVD playback"]
    #[doc = "!                 - P12 - Minimum idle power consumption"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 295"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]   hPhysicalGPU  GPU selection"]
    #[doc = "! \\param [out]  pPstatesInfo  P-States information retrieved, as documented in declaration above"]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!          If there are return error codes with specific meaning for this API,"]
    #[doc = "!          they are listed below."]
    #[doc = "!"]
    #[doc = "! \\ingroup gpupstate"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetPstates20(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pPstatesInfo: *mut NV_GPU_PERF_PSTATES20_INFO,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This function retrieves the current performance state (P-State)."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 165"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\param [in]      hPhysicalGPU     GPU selection"]
    #[doc = "! \\param [out]     pCurrentPstate   The ID of the current P-State of the GPU - see \\ref NV_GPU_PERF_PSTATES."]
    #[doc = "!"]
    #[doc = "! \\retval    NVAPI_OK                             Completed request"]
    #[doc = "! \\retval    NVAPI_ERROR                          Miscellaneous error occurred."]
    #[doc = "! \\retval    NVAPI_HANDLE_INVALIDATED             Handle passed has been invalidated (see user guide)."]
    #[doc = "! \\retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE   Handle passed is not a physical GPU handle."]
    #[doc = "! \\retval    NVAPI_NOT_SUPPORTED                  P-States is not supported on this setup."]
    #[doc = "!"]
    #[doc = "! \\ingroup   gpupstate"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetCurrentPstate(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pCurrentPstate: *mut NV_GPU_PERF_PSTATE_ID,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpupstate"]
#[doc = "! Used in NvAPI_GPU_GetDynamicPstatesInfoEx()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_GPU_DYNAMIC_PSTATES_INFO_EX {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< bit 0 indicates if the dynamic Pstate is enabled or not"]
    pub flags: NvU32,
    pub utilization: [NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "!< Percentage of time where the domain is considered busy in the last 1 second interval"]
    pub percentage: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1)
        )
    );
    fn test_field_percentage() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).percentage) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1),
                "::",
                stringify!(percentage)
            )
        );
    }
    test_field_percentage();
}
impl NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1 {
    #[inline]
    pub fn bIsPresent(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsPresent(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(bIsPresent: NvU32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsPresent: u32 = unsafe { ::std::mem::transmute(bIsPresent) };
            bIsPresent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NV_GPU_DYNAMIC_PSTATES_INFO_EX() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_DYNAMIC_PSTATES_INFO_EX>(),
        72usize,
        concat!("Size of: ", stringify!(NV_GPU_DYNAMIC_PSTATES_INFO_EX))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_DYNAMIC_PSTATES_INFO_EX>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_DYNAMIC_PSTATES_INFO_EX))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_DYNAMIC_PSTATES_INFO_EX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_DYNAMIC_PSTATES_INFO_EX),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_DYNAMIC_PSTATES_INFO_EX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_DYNAMIC_PSTATES_INFO_EX),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_utilization() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_DYNAMIC_PSTATES_INFO_EX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).utilization) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_DYNAMIC_PSTATES_INFO_EX),
                "::",
                stringify!(utilization)
            )
        );
    }
    test_field_utilization();
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API retrieves the NV_GPU_DYNAMIC_PSTATES_INFO_EX structure for the specified physical GPU."]
    #[doc = "!                Each domain's info is indexed in the array.  For example:"]
    #[doc = "!                - pDynamicPstatesInfo->utilization[NVAPI_GPU_UTILIZATION_DOMAIN_GPU] holds the info for the GPU domain. \\p"]
    #[doc = "!                There are currently 4 domains for which GPU utilization and dynamic P-State thresholds can be retrieved:"]
    #[doc = "!                   graphic engine (GPU), frame buffer (FB), video engine (VID), and bus interface (BUS)."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "! \\since Release: 185"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK"]
    #[doc = "! \\retval ::NVAPI_ERROR"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT  pDynamicPstatesInfo is NULL"]
    #[doc = "! \\retval ::NVAPI_HANDLE_INVALIDATED"]
    #[doc = "! \\retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE"]
    #[doc = "! \\retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION The version of the INFO struct is not supported"]
    #[doc = "!"]
    #[doc = "! \\ingroup gpupstate"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetDynamicPstatesInfoEx(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pDynamicPstatesInfoEx: *mut NV_GPU_DYNAMIC_PSTATES_INFO_EX,
    ) -> NvAPI_Status;
}
pub const NV_THERMAL_TARGET_NVAPI_THERMAL_TARGET_NONE: NV_THERMAL_TARGET = 0;
#[doc = "!< GPU core temperature requires NvPhysicalGpuHandle"]
pub const NV_THERMAL_TARGET_NVAPI_THERMAL_TARGET_GPU: NV_THERMAL_TARGET = 1;
#[doc = "!< GPU memory temperature requires NvPhysicalGpuHandle"]
pub const NV_THERMAL_TARGET_NVAPI_THERMAL_TARGET_MEMORY: NV_THERMAL_TARGET = 2;
#[doc = "!< GPU power supply temperature requires NvPhysicalGpuHandle"]
pub const NV_THERMAL_TARGET_NVAPI_THERMAL_TARGET_POWER_SUPPLY: NV_THERMAL_TARGET = 4;
#[doc = "!< GPU board ambient temperature requires NvPhysicalGpuHandle"]
pub const NV_THERMAL_TARGET_NVAPI_THERMAL_TARGET_BOARD: NV_THERMAL_TARGET = 8;
#[doc = "!< Visual Computing Device Board temperature requires NvVisualComputingDeviceHandle"]
pub const NV_THERMAL_TARGET_NVAPI_THERMAL_TARGET_VCD_BOARD: NV_THERMAL_TARGET = 9;
#[doc = "!< Visual Computing Device Inlet temperature requires NvVisualComputingDeviceHandle"]
pub const NV_THERMAL_TARGET_NVAPI_THERMAL_TARGET_VCD_INLET: NV_THERMAL_TARGET = 10;
#[doc = "!< Visual Computing Device Outlet temperature requires NvVisualComputingDeviceHandle"]
pub const NV_THERMAL_TARGET_NVAPI_THERMAL_TARGET_VCD_OUTLET: NV_THERMAL_TARGET = 11;
pub const NV_THERMAL_TARGET_NVAPI_THERMAL_TARGET_ALL: NV_THERMAL_TARGET = 15;
pub const NV_THERMAL_TARGET_NVAPI_THERMAL_TARGET_UNKNOWN: NV_THERMAL_TARGET = -1;
#[doc = "! \\ingroup gputhermal"]
#[doc = "! Used in NV_GPU_THERMAL_SETTINGS"]
pub type NV_THERMAL_TARGET = ::std::os::raw::c_int;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_NONE: NV_THERMAL_CONTROLLER = 0;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_GPU_INTERNAL: NV_THERMAL_CONTROLLER = 1;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_ADM1032: NV_THERMAL_CONTROLLER = 2;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_MAX6649: NV_THERMAL_CONTROLLER = 3;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_MAX1617: NV_THERMAL_CONTROLLER = 4;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_LM99: NV_THERMAL_CONTROLLER = 5;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_LM89: NV_THERMAL_CONTROLLER = 6;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_LM64: NV_THERMAL_CONTROLLER = 7;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_ADT7473: NV_THERMAL_CONTROLLER = 8;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_SBMAX6649: NV_THERMAL_CONTROLLER = 9;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_VBIOSEVT: NV_THERMAL_CONTROLLER = 10;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_OS: NV_THERMAL_CONTROLLER = 11;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_UNKNOWN: NV_THERMAL_CONTROLLER = -1;
#[doc = "! \\ingroup gputhermal"]
#[doc = "! Used in NV_GPU_THERMAL_SETTINGS"]
pub type NV_THERMAL_CONTROLLER = ::std::os::raw::c_int;
#[doc = "! \\ingroup gputhermal"]
#[doc = "! Used in NvAPI_GPU_GetThermalSettings()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_THERMAL_SETTINGS_V1 {
    #[doc = "!< structure version"]
    pub version: NvU32,
    #[doc = "!< number of associated thermal sensors"]
    pub count: NvU32,
    pub sensor: [NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1 {
    #[doc = "!< internal, ADM1032, MAX6649..."]
    pub controller: NV_THERMAL_CONTROLLER,
    #[doc = "!< The min default temperature value of the thermal sensor in degree Celsius"]
    pub defaultMinTemp: NvU32,
    #[doc = "!< The max default temperature value of the thermal sensor in degree Celsius"]
    pub defaultMaxTemp: NvU32,
    #[doc = "!< The current temperature value of the thermal sensor in degree Celsius"]
    pub currentTemp: NvU32,
    #[doc = "!< Thermal sensor targeted @ GPU, memory, chipset, powersupply, Visual Computing Device, etc."]
    pub target: NV_THERMAL_TARGET,
}
#[test]
fn bindgen_test_layout_NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1)
        )
    );
    fn test_field_controller() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).controller) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1),
                "::",
                stringify!(controller)
            )
        );
    }
    test_field_controller();
    fn test_field_defaultMinTemp() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).defaultMinTemp) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1),
                "::",
                stringify!(defaultMinTemp)
            )
        );
    }
    test_field_defaultMinTemp();
    fn test_field_defaultMaxTemp() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).defaultMaxTemp) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1),
                "::",
                stringify!(defaultMaxTemp)
            )
        );
    }
    test_field_defaultMaxTemp();
    fn test_field_currentTemp() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).currentTemp) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1),
                "::",
                stringify!(currentTemp)
            )
        );
    }
    test_field_currentTemp();
    fn test_field_target() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1),
                "::",
                stringify!(target)
            )
        );
    }
    test_field_target();
}
impl Default for NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NV_GPU_THERMAL_SETTINGS_V1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_THERMAL_SETTINGS_V1>(),
        68usize,
        concat!("Size of: ", stringify!(NV_GPU_THERMAL_SETTINGS_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_THERMAL_SETTINGS_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_THERMAL_SETTINGS_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_THERMAL_SETTINGS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_THERMAL_SETTINGS_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_THERMAL_SETTINGS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_THERMAL_SETTINGS_V1),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_sensor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_THERMAL_SETTINGS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sensor) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_THERMAL_SETTINGS_V1),
                "::",
                stringify!(sensor)
            )
        );
    }
    test_field_sensor();
}
impl Default for NV_GPU_THERMAL_SETTINGS_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup gputhermal"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_THERMAL_SETTINGS_V2 {
    #[doc = "!< structure version"]
    pub version: NvU32,
    #[doc = "!< number of associated thermal sensors"]
    pub count: NvU32,
    pub sensor: [NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1 {
    #[doc = "!< internal, ADM1032, MAX6649..."]
    pub controller: NV_THERMAL_CONTROLLER,
    #[doc = "!< Minimum default temperature value of the thermal sensor in degree Celsius"]
    pub defaultMinTemp: NvS32,
    #[doc = "!< Maximum default temperature value of the thermal sensor in degree Celsius"]
    pub defaultMaxTemp: NvS32,
    #[doc = "!< Current temperature value of the thermal sensor in degree Celsius"]
    pub currentTemp: NvS32,
    #[doc = "!< Thermal sensor targeted - GPU, memory, chipset, powersupply, Visual Computing Device, etc"]
    pub target: NV_THERMAL_TARGET,
}
#[test]
fn bindgen_test_layout_NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1)
        )
    );
    fn test_field_controller() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).controller) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1),
                "::",
                stringify!(controller)
            )
        );
    }
    test_field_controller();
    fn test_field_defaultMinTemp() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).defaultMinTemp) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1),
                "::",
                stringify!(defaultMinTemp)
            )
        );
    }
    test_field_defaultMinTemp();
    fn test_field_defaultMaxTemp() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).defaultMaxTemp) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1),
                "::",
                stringify!(defaultMaxTemp)
            )
        );
    }
    test_field_defaultMaxTemp();
    fn test_field_currentTemp() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).currentTemp) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1),
                "::",
                stringify!(currentTemp)
            )
        );
    }
    test_field_currentTemp();
    fn test_field_target() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1),
                "::",
                stringify!(target)
            )
        );
    }
    test_field_target();
}
impl Default for NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NV_GPU_THERMAL_SETTINGS_V2() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_THERMAL_SETTINGS_V2>(),
        68usize,
        concat!("Size of: ", stringify!(NV_GPU_THERMAL_SETTINGS_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_THERMAL_SETTINGS_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_THERMAL_SETTINGS_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_THERMAL_SETTINGS_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_THERMAL_SETTINGS_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_THERMAL_SETTINGS_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_THERMAL_SETTINGS_V2),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_sensor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_THERMAL_SETTINGS_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sensor) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_THERMAL_SETTINGS_V2),
                "::",
                stringify!(sensor)
            )
        );
    }
    test_field_sensor();
}
impl Default for NV_GPU_THERMAL_SETTINGS_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup gputhermal"]
pub type NV_GPU_THERMAL_SETTINGS = NV_GPU_THERMAL_SETTINGS_V2;
extern "C" {
    #[doc = "!  This function retrieves the thermal information of all thermal sensors or specific thermal sensor associated with the selected GPU."]
    #[doc = "!  Thermal sensors are indexed 0 to NVAPI_MAX_THERMAL_SENSORS_PER_GPU-1."]
    #[doc = "!"]
    #[doc = "!  - To retrieve specific thermal sensor info, set the sensorIndex to the required thermal sensor index."]
    #[doc = "!  - To retrieve info for all sensors, set sensorIndex to NVAPI_THERMAL_TARGET_ALL."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 85"]
    #[doc = "!"]
    #[doc = "! \\param [in]   hPhysicalGPU      GPU selection."]
    #[doc = "! \\param [in]   sensorIndex       Explicit thermal sensor index selection."]
    #[doc = "! \\param [out]  pThermalSettings  Array of thermal settings."]
    #[doc = "!"]
    #[doc = "! \\retval   NVAPI_OK                           Completed request"]
    #[doc = "! \\retval   NVAPI_ERROR                        Miscellaneous error occurred."]
    #[doc = "! \\retval   NVAPI_INVALID_ARGUMENT             pThermalInfo is NULL."]
    #[doc = "! \\retval   NVAPI_HANDLE_INVALIDATED           Handle passed has been invalidated (see user guide)."]
    #[doc = "! \\retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE Handle passed is not a physical GPU handle."]
    #[doc = "! \\retval   NVAPI_INCOMPATIBLE_STRUCT_VERSION  The version of the INFO struct is not supported."]
    #[doc = "! \\ingroup gputhermal"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetThermalSettings(
        hPhysicalGpu: NvPhysicalGpuHandle,
        sensorIndex: NvU32,
        pThermalSettings: *mut NV_GPU_THERMAL_SETTINGS,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpuclock"]
#[doc = "! Used in NvAPI_GPU_GetAllClockFrequencies()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_GPU_CLOCK_FREQUENCIES_V1 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< These bits are reserved for future use."]
    pub reserved: NvU32,
    pub domain: [NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1; 32usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Clock frequency (kHz)"]
    pub frequency: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1)
        )
    );
    fn test_field_frequency() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1),
                "::",
                stringify!(frequency)
            )
        );
    }
    test_field_frequency();
}
impl NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1 {
    #[inline]
    pub fn bIsPresent(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsPresent(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsPresent: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsPresent: u32 = unsafe { ::std::mem::transmute(bIsPresent) };
            bIsPresent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NV_GPU_CLOCK_FREQUENCIES_V1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_CLOCK_FREQUENCIES_V1>(),
        264usize,
        concat!("Size of: ", stringify!(NV_GPU_CLOCK_FREQUENCIES_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_CLOCK_FREQUENCIES_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_CLOCK_FREQUENCIES_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_CLOCK_FREQUENCIES_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_CLOCK_FREQUENCIES_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_CLOCK_FREQUENCIES_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_CLOCK_FREQUENCIES_V1),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
    fn test_field_domain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_CLOCK_FREQUENCIES_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).domain) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_CLOCK_FREQUENCIES_V1),
                "::",
                stringify!(domain)
            )
        );
    }
    test_field_domain();
}
pub const NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE_NV_GPU_CLOCK_FREQUENCIES_CURRENT_FREQ:
    NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE = 0;
pub const NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE_NV_GPU_CLOCK_FREQUENCIES_BASE_CLOCK:
    NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE = 1;
pub const NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE_NV_GPU_CLOCK_FREQUENCIES_BOOST_CLOCK:
    NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE = 2;
pub const NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE_NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE_NUM:
    NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE = 3;
#[doc = "! \\ingroup gpuclock"]
#[doc = "! Used in NvAPI_GPU_GetAllClockFrequencies()"]
pub type NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpuclock"]
#[doc = "! Used in NvAPI_GPU_GetAllClockFrequencies()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_GPU_CLOCK_FREQUENCIES_V2 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub domain: [NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1; 32usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Clock frequency (kHz)"]
    pub frequency: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1)
        )
    );
    fn test_field_frequency() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1),
                "::",
                stringify!(frequency)
            )
        );
    }
    test_field_frequency();
}
impl NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1 {
    #[inline]
    pub fn bIsPresent(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsPresent(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsPresent: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsPresent: u32 = unsafe { ::std::mem::transmute(bIsPresent) };
            bIsPresent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NV_GPU_CLOCK_FREQUENCIES_V2() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_CLOCK_FREQUENCIES_V2>(),
        264usize,
        concat!("Size of: ", stringify!(NV_GPU_CLOCK_FREQUENCIES_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_CLOCK_FREQUENCIES_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_CLOCK_FREQUENCIES_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_CLOCK_FREQUENCIES_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_CLOCK_FREQUENCIES_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_domain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_GPU_CLOCK_FREQUENCIES_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).domain) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_CLOCK_FREQUENCIES_V2),
                "::",
                stringify!(domain)
            )
        );
    }
    test_field_domain();
}
impl NV_GPU_CLOCK_FREQUENCIES_V2 {
    #[inline]
    pub fn ClockType(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ClockType(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ClockType: NvU32,
        reserved: NvU32,
        reserved1: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ClockType: u32 = unsafe { ::std::mem::transmute(ClockType) };
            ClockType as u64
        });
        __bindgen_bitfield_unit.set(4usize, 20u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! \\ingroup gpuclock"]
#[doc = "! Used in NvAPI_GPU_GetAllClockFrequencies()"]
pub type NV_GPU_CLOCK_FREQUENCIES = NV_GPU_CLOCK_FREQUENCIES_V2;
extern "C" {
    #[doc = "!   This function retrieves the NV_GPU_CLOCK_FREQUENCIES structure for the specified physical GPU."]
    #[doc = "!"]
    #[doc = "!   For each clock domain:"]
    #[doc = "!      - bIsPresent is set for each domain that is present on the GPU"]
    #[doc = "!      - frequency is the domain's clock freq in kHz"]
    #[doc = "!"]
    #[doc = "!   Each domain's info is indexed in the array.  For example:"]
    #[doc = "!   clkFreqs.domain[NVAPI_GPU_PUBLIC_CLOCK_MEMORY] holds the info for the MEMORY domain."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 295"]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!          If there are return error codes with specific meaning for this API,"]
    #[doc = "!          they are listed below."]
    #[doc = "! \\retval  NVAPI_INVALID_ARGUMENT     pClkFreqs is NULL."]
    #[doc = "! \\ingroup gpuclock"]
    #[doc = ""]
    pub fn NvAPI_GPU_GetAllClockFrequencies(
        hPhysicalGPU: NvPhysicalGpuHandle,
        pClkFreqs: *mut NV_GPU_CLOCK_FREQUENCIES,
    ) -> NvAPI_Status;
}
pub const _NV_GPU_ILLUMINATION_ATTRIB_NV_GPU_IA_LOGO_BRIGHTNESS: _NV_GPU_ILLUMINATION_ATTRIB = 0;
pub const _NV_GPU_ILLUMINATION_ATTRIB_NV_GPU_IA_SLI_BRIGHTNESS: _NV_GPU_ILLUMINATION_ATTRIB = 1;
#[doc = "! \\ingroup gpu"]
pub type _NV_GPU_ILLUMINATION_ATTRIB = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpu"]
pub use self::_NV_GPU_ILLUMINATION_ATTRIB as NV_GPU_ILLUMINATION_ATTRIB;
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< The handle of the GPU that you are checking for the specified attribute."]
    #[doc = "!< note that this is the GPU that is managing the attribute."]
    #[doc = "!< Only a single GPU can manage an given attribute on a given HW element,"]
    #[doc = "!< regardless of how many are attatched."]
    #[doc = "!< I.E. only one GPU will be used to control the brightness of the LED on an SLI bridge,"]
    #[doc = "!< regardless of how many are physicaly attached."]
    #[doc = "!< You enumerate thru the GPUs with this call to determine which GPU is managing the attribute."]
    pub hPhysicalGpu: NvPhysicalGpuHandle,
    #[doc = "!< An enumeration value specifying the Illumination attribute to be querried."]
    #[doc = "!<     refer to enum \\ref NV_GPU_ILLUMINATION_ATTRIB."]
    pub Attribute: NV_GPU_ILLUMINATION_ATTRIB,
    #[doc = "!< A boolean indicating if the attribute is supported."]
    pub bSupported: NvU32,
}
#[test]
fn bindgen_test_layout__NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_hPhysicalGpu() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hPhysicalGpu) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1),
                "::",
                stringify!(hPhysicalGpu)
            )
        );
    }
    test_field_hPhysicalGpu();
    fn test_field_Attribute() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Attribute) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1),
                "::",
                stringify!(Attribute)
            )
        );
    }
    test_field_Attribute();
    fn test_field_bSupported() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bSupported) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1),
                "::",
                stringify!(bSupported)
            )
        );
    }
    test_field_bSupported();
}
impl Default for _NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup gpu"]
pub type NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1 = _NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1;
#[doc = "! \\ingroup gpu"]
pub type NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM = NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1;
extern "C" {
    #[doc = "! \\ingroup gpu"]
    pub fn NvAPI_GPU_QueryIlluminationSupport(
        pIlluminationSupportInfo: *mut NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_GET_ILLUMINATION_PARM_V1 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< The handle of the GPU that you are checking for the specified attribute."]
    #[doc = "!< Note that this is the GPU that is managing the attribute."]
    #[doc = "!< Only a single GPU can manage an given attribute on a given HW element,"]
    #[doc = "!< regardless of how many are attatched."]
    #[doc = "!< I.E. only one GPU will be used to control the brightness of the LED on an SLI bridge,"]
    #[doc = "!< regardless of how many are physicaly attached."]
    #[doc = "!< You enumerate thru the GPUs with this call to determine which GPU is managing the attribute."]
    pub hPhysicalGpu: NvPhysicalGpuHandle,
    #[doc = "!< An enumeration value specifying the Illumination attribute to be querried."]
    #[doc = "!< refer to enum \\ref NV_GPU_ILLUMINATION_ATTRIB."]
    pub Attribute: NV_GPU_ILLUMINATION_ATTRIB,
    #[doc = "!< A DWORD that will contain the current value of the specified attribute."]
    pub Value: NvU32,
}
#[test]
fn bindgen_test_layout__NV_GPU_GET_ILLUMINATION_PARM_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_GET_ILLUMINATION_PARM_V1>(),
        24usize,
        concat!("Size of: ", stringify!(_NV_GPU_GET_ILLUMINATION_PARM_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_GET_ILLUMINATION_PARM_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_GET_ILLUMINATION_PARM_V1)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_GET_ILLUMINATION_PARM_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_GET_ILLUMINATION_PARM_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_hPhysicalGpu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_GET_ILLUMINATION_PARM_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hPhysicalGpu) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_GET_ILLUMINATION_PARM_V1),
                "::",
                stringify!(hPhysicalGpu)
            )
        );
    }
    test_field_hPhysicalGpu();
    fn test_field_Attribute() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_GET_ILLUMINATION_PARM_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Attribute) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_GET_ILLUMINATION_PARM_V1),
                "::",
                stringify!(Attribute)
            )
        );
    }
    test_field_Attribute();
    fn test_field_Value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_GET_ILLUMINATION_PARM_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_GET_ILLUMINATION_PARM_V1),
                "::",
                stringify!(Value)
            )
        );
    }
    test_field_Value();
}
impl Default for _NV_GPU_GET_ILLUMINATION_PARM_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup gpu"]
pub type NV_GPU_GET_ILLUMINATION_PARM_V1 = _NV_GPU_GET_ILLUMINATION_PARM_V1;
#[doc = "! \\ingroup gpu"]
pub type NV_GPU_GET_ILLUMINATION_PARM = NV_GPU_GET_ILLUMINATION_PARM_V1;
extern "C" {
    #[doc = "! \\ingroup gpu"]
    pub fn NvAPI_GPU_GetIllumination(
        pIlluminationInfo: *mut NV_GPU_GET_ILLUMINATION_PARM,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_SET_ILLUMINATION_PARM_V1 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< The handle of the GPU that you are checking for the specified attribute."]
    #[doc = "!< Note that this is the GPU that is managing the attribute."]
    #[doc = "!< Only a single GPU can manage an given attribute on a given HW element,"]
    #[doc = "!< regardless of how many are attatched."]
    #[doc = "!< I.E. only one GPU will be used to control the brightness of the LED on an SLI bridge,"]
    #[doc = "!< regardless of how many are physicaly attached."]
    #[doc = "!< You enumerate thru the GPUs with this call to determine which GPU is managing the attribute."]
    pub hPhysicalGpu: NvPhysicalGpuHandle,
    #[doc = "!< An enumeration value specifying the Illumination attribute to be querried."]
    #[doc = "!< refer to enum \\ref NV_GPU_ILLUMINATION_ATTRIB."]
    pub Attribute: NV_GPU_ILLUMINATION_ATTRIB,
    #[doc = "!< A DWORD containing the new value for the specified attribute."]
    #[doc = "!< This should be specified as a percentage of the full range of the attribute"]
    #[doc = "!< (0-100; 0 = off, 100 = full brightness)"]
    #[doc = "!< If a value is specified outside this range, NVAPI_INVALID_ARGUMENT will be returned."]
    pub Value: NvU32,
}
#[test]
fn bindgen_test_layout__NV_GPU_SET_ILLUMINATION_PARM_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_SET_ILLUMINATION_PARM_V1>(),
        24usize,
        concat!("Size of: ", stringify!(_NV_GPU_SET_ILLUMINATION_PARM_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_SET_ILLUMINATION_PARM_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_SET_ILLUMINATION_PARM_V1)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_SET_ILLUMINATION_PARM_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_SET_ILLUMINATION_PARM_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_hPhysicalGpu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_SET_ILLUMINATION_PARM_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hPhysicalGpu) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_SET_ILLUMINATION_PARM_V1),
                "::",
                stringify!(hPhysicalGpu)
            )
        );
    }
    test_field_hPhysicalGpu();
    fn test_field_Attribute() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_SET_ILLUMINATION_PARM_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Attribute) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_SET_ILLUMINATION_PARM_V1),
                "::",
                stringify!(Attribute)
            )
        );
    }
    test_field_Attribute();
    fn test_field_Value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_SET_ILLUMINATION_PARM_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_SET_ILLUMINATION_PARM_V1),
                "::",
                stringify!(Value)
            )
        );
    }
    test_field_Value();
}
impl Default for _NV_GPU_SET_ILLUMINATION_PARM_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup gpu"]
pub type NV_GPU_SET_ILLUMINATION_PARM_V1 = _NV_GPU_SET_ILLUMINATION_PARM_V1;
#[doc = "! \\ingroup gpu"]
pub type NV_GPU_SET_ILLUMINATION_PARM = NV_GPU_SET_ILLUMINATION_PARM_V1;
extern "C" {
    #[doc = "! \\ingroup gpu"]
    pub fn NvAPI_GPU_SetIllumination(
        pIlluminationInfo: *mut NV_GPU_SET_ILLUMINATION_PARM,
    ) -> NvAPI_Status;
}
pub const NV_GPU_CLIENT_ILLUM_CTRL_MODE_NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGB:
    NV_GPU_CLIENT_ILLUM_CTRL_MODE = 0;
pub const NV_GPU_CLIENT_ILLUM_CTRL_MODE_NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGB:
    NV_GPU_CLIENT_ILLUM_CTRL_MODE = 1;
pub const NV_GPU_CLIENT_ILLUM_CTRL_MODE_NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL:
    NV_GPU_CLIENT_ILLUM_CTRL_MODE = 0;
pub const NV_GPU_CLIENT_ILLUM_CTRL_MODE_NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR:
    NV_GPU_CLIENT_ILLUM_CTRL_MODE = 1;
pub const NV_GPU_CLIENT_ILLUM_CTRL_MODE_NV_GPU_CLIENT_ILLUM_CTRL_MODE_INVALID:
    NV_GPU_CLIENT_ILLUM_CTRL_MODE = 255;
#[doc = " Enumeration of control modes that can be applied to Illumination Zones."]
pub type NV_GPU_CLIENT_ILLUM_CTRL_MODE = ::std::os::raw::c_int;
pub const NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_GPU_TOP_0:
    NV_GPU_CLIENT_ILLUM_ZONE_LOCATION = 0;
pub const NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_GPU_FRONT_0:
    NV_GPU_CLIENT_ILLUM_ZONE_LOCATION = 8;
pub const NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_GPU_BACK_0:
    NV_GPU_CLIENT_ILLUM_ZONE_LOCATION = 12;
pub const NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_SLI_TOP_0:
    NV_GPU_CLIENT_ILLUM_ZONE_LOCATION = 32;
pub const NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_INVALID:
    NV_GPU_CLIENT_ILLUM_ZONE_LOCATION = -1;
#[doc = " Enumeration of locations where an Illumination Zone might be present."]
#[doc = " Encoding used -"]
#[doc = "   1:0 - Number specifier (0)"]
#[doc = "   4:2 - Location (TOP)"]
#[doc = "   7:5 - Type (GPU/SLI)"]
pub type NV_GPU_CLIENT_ILLUM_ZONE_LOCATION = ::std::os::raw::c_int;
pub const NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_INVALID:
    NV_GPU_CLIENT_ILLUM_DEVICE_TYPE = 0;
pub const NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_MCUV10:
    NV_GPU_CLIENT_ILLUM_DEVICE_TYPE = 1;
pub const NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_GPIO_PWM_RGBW_V10:
    NV_GPU_CLIENT_ILLUM_DEVICE_TYPE = 2;
pub const NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_GPIO_PWM_SINGLE_COLOR_V10 : NV_GPU_CLIENT_ILLUM_DEVICE_TYPE = 3 ;
#[doc = " Enumeration of ILLUM_DEVICEs."]
pub type NV_GPU_CLIENT_ILLUM_DEVICE_TYPE = ::std::os::raw::c_int;
pub const NV_GPU_CLIENT_ILLUM_ZONE_TYPE_NV_GPU_CLIENT_ILLUM_ZONE_TYPE_INVALID:
    NV_GPU_CLIENT_ILLUM_ZONE_TYPE = 0;
pub const NV_GPU_CLIENT_ILLUM_ZONE_TYPE_NV_GPU_CLIENT_ILLUM_ZONE_TYPE_RGB:
    NV_GPU_CLIENT_ILLUM_ZONE_TYPE = 1;
pub const NV_GPU_CLIENT_ILLUM_ZONE_TYPE_NV_GPU_CLIENT_ILLUM_ZONE_TYPE_COLOR_FIXED:
    NV_GPU_CLIENT_ILLUM_ZONE_TYPE = 2;
pub const NV_GPU_CLIENT_ILLUM_ZONE_TYPE_NV_GPU_CLIENT_ILLUM_ZONE_TYPE_RGBW:
    NV_GPU_CLIENT_ILLUM_ZONE_TYPE = 3;
pub const NV_GPU_CLIENT_ILLUM_ZONE_TYPE_NV_GPU_CLIENT_ILLUM_ZONE_TYPE_SINGLE_COLOR:
    NV_GPU_CLIENT_ILLUM_ZONE_TYPE = 4;
#[doc = " Enumeration of ILLUM_ZONEs."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_TYPE = ::std::os::raw::c_int;
pub const NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE_NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_HALF_HALT : NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE = 0 ;
pub const NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE_NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_FULL_HALT : NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE = 1 ;
pub const NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE_NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_FULL_REPEAT : NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE = 2 ;
pub const NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE_NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_INVALID : NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE = 255 ;
#[doc = " Enumeration of Cycle types for piecewise linear control mode."]
pub type NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE = ::std::os::raw::c_int;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1"]
#[doc = " Describes the static information of illumination device type MCUV10."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10 {
    #[doc = " I2C Device Index: Pointing to the illumination device in I2C Devices Table."]
    pub i2cDevIdx: NvU8,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10)
        )
    );
    fn test_field_i2cDevIdx() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i2cDevIdx) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10),
                "::",
                stringify!(i2cDevIdx)
            )
        );
    }
    test_field_i2cDevIdx();
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1"]
#[doc = " Describes the static information of illumination device type MCUV10."]
pub type NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10 = _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1"]
#[doc = " Describes the static information of illum device type GPIO_PWM_RGBW."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW {
    #[doc = " Red drive GPIO pin."]
    pub gpioPinRed: NvU8,
    #[doc = " Green drive GPIO pin."]
    pub gpioPinGreen: NvU8,
    #[doc = " Blue drive GPIO pin."]
    pub gpioPinBlue: NvU8,
    #[doc = " White drive GPIO pin."]
    pub gpioPinWhite: NvU8,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW)
        )
    );
    fn test_field_gpioPinRed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gpioPinRed) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW),
                "::",
                stringify!(gpioPinRed)
            )
        );
    }
    test_field_gpioPinRed();
    fn test_field_gpioPinGreen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gpioPinGreen) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW),
                "::",
                stringify!(gpioPinGreen)
            )
        );
    }
    test_field_gpioPinGreen();
    fn test_field_gpioPinBlue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gpioPinBlue) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW),
                "::",
                stringify!(gpioPinBlue)
            )
        );
    }
    test_field_gpioPinBlue();
    fn test_field_gpioPinWhite() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gpioPinWhite) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW),
                "::",
                stringify!(gpioPinWhite)
            )
        );
    }
    test_field_gpioPinWhite();
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1"]
#[doc = " Describes the static information of illum device type GPIO_PWM_RGBW."]
pub type NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW =
    _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1"]
#[doc = " Describes the static information of illum device type GPIO_PWM_SINGLE_COLOR."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR {
    #[doc = " Single Color GPIO pin."]
    pub gpioPinSingleColor: NvU8,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR)
        )
    );
    fn test_field_gpioPinSingleColor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gpioPinSingleColor) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR),
                "::",
                stringify!(gpioPinSingleColor)
            )
        );
    }
    test_field_gpioPinSingleColor();
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1"]
#[doc = " Describes the static information of illum device type GPIO_PWM_SINGLE_COLOR."]
pub type NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR =
    _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1 {
    #[doc = " Type of the illumination device."]
    pub type_: NV_GPU_CLIENT_ILLUM_DEVICE_TYPE,
    #[doc = " Supported control modes for this illumination device."]
    pub ctrlModeMask: NvU32,
    pub data: _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1,
    #[doc = " Reserved for future."]
    pub rsvd: [NvU8; 64usize],
}
#[doc = " Union of illumination device info data. Interpreted as per"]
#[doc = " @ref NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1::type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1 {
    pub mcuv10: NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10,
    pub gpioPwmRgbwv10: NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW,
    pub gpioPwmSingleColorv10: NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR,
    #[doc = " Reserved bytes for possible future extension of this struct."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1)
        )
    );
    fn test_field_mcuv10() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mcuv10) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1),
                "::",
                stringify!(mcuv10)
            )
        );
    }
    test_field_mcuv10();
    fn test_field_gpioPwmRgbwv10() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gpioPwmRgbwv10) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1),
                "::",
                stringify!(gpioPwmRgbwv10)
            )
        );
    }
    test_field_gpioPwmRgbwv10();
    fn test_field_gpioPwmSingleColorv10() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gpioPwmSingleColorv10) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1),
                "::",
                stringify!(gpioPwmSingleColorv10)
            )
        );
    }
    test_field_gpioPwmSingleColorv10();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1>(),
        136usize,
        concat!("Size of: ", stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1)
        )
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_ctrlModeMask() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctrlModeMask) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1),
                "::",
                stringify!(ctrlModeMask)
            )
        );
    }
    test_field_ctrlModeMask();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1 = _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1 {
    #[doc = " Version of structure. Must always be first member."]
    pub version: NvU32,
    #[doc = " Number of illumination devices present."]
    pub numIllumDevices: NvU32,
    #[doc = " Reserved bytes for possible future extension of this struct."]
    pub rsvd: [NvU8; 64usize],
    pub devices: [NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1; 32usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1>(),
        4424usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_numIllumDevices() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numIllumDevices) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1),
                "::",
                stringify!(numIllumDevices)
            )
        );
    }
    test_field_numIllumDevices();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
    fn test_field_devices() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).devices) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1),
                "::",
                stringify!(devices)
            )
        );
    }
    test_field_devices();
}
impl Default for _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1 = _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1;
pub type NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS = NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1;
extern "C" {
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 400"]
    #[doc = "! \\param [in]  hPhysicalGpu       The physical GPU handle"]
    #[doc = "! \\param [out] pIllumDevicesInfo  Pointer to structure containing static"]
    #[doc = "!                                 information about illumination devices."]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!          If there are return error codes with specific meaning for this API,"]
    #[doc = "!          they are listed below."]
    #[doc = ""]
    pub fn NvAPI_GPU_ClientIllumDevicesGetInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pIllumDevicesInfo: *mut NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS,
    ) -> NvAPI_Status;
}
#[doc = " Structure representing the data required for synchronization."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1 {
    #[doc = " Boolean representing the need for synchronization."]
    pub bSync: NvBool,
    #[doc = " Time stamp value required for synchronization."]
    pub timeStampms: NvU64,
    #[doc = " Reserved for future."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout_NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1>(),
        80usize,
        concat!("Size of: ", stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1)
        )
    );
    fn test_field_bSync() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bSync) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1),
                "::",
                stringify!(bSync)
            )
        );
    }
    test_field_bSync();
    fn test_field_timeStampms() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timeStampms) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1),
                "::",
                stringify!(timeStampms)
            )
        );
    }
    test_field_timeStampms();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Structure representing the device control parameters of each ILLUM_DEVICE."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1 {
    #[doc = " Type of the illum device."]
    pub type_: NV_GPU_CLIENT_ILLUM_DEVICE_TYPE,
    #[doc = " Structure containing the synchronization data for the illumination device."]
    pub syncData: NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1,
    #[doc = " Reserved for future."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout_NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1>(),
        152usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1)
        )
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_syncData() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).syncData) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1),
                "::",
                stringify!(syncData)
            )
        );
    }
    test_field_syncData();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Structure representing the device control parameters of each ILLUM_DEVICE."]
pub type NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL = NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1;
#[doc = " Structure representing the control parameters of ILLUM_DEVICE-s."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1 {
    #[doc = " Version of structure. Must always be first member."]
    pub version: NvU32,
    #[doc = " Number of illumination devices present."]
    pub numIllumDevices: NvU32,
    #[doc = " Reserved bytes for possible future extension of this struct."]
    pub rsvd: [NvU8; 64usize],
    pub devices: [NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1; 32usize],
}
#[test]
fn bindgen_test_layout_NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1>(),
        4936usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_numIllumDevices() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numIllumDevices) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1),
                "::",
                stringify!(numIllumDevices)
            )
        );
    }
    test_field_numIllumDevices();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
    fn test_field_devices() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).devices) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1),
                "::",
                stringify!(devices)
            )
        );
    }
    test_field_devices();
}
impl Default for NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Structure representing the control parameters of ILLUM_DEVICE-s."]
pub type NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS = NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1;
extern "C" {
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 400"]
    #[doc = "! \\param [in]  hPhysicalGpu          The physical GPU handle"]
    #[doc = "! \\param [inout] pIllumDevicesControl  Pointer to structure containing control"]
    #[doc = "!                                 information about illum devices."]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!          If there are return error codes with specific meaning for this API,"]
    #[doc = "!          they are listed below."]
    #[doc = ""]
    pub fn NvAPI_GPU_ClientIllumDevicesGetControl(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pClientIllumDevicesControl: *mut NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 400"]
    #[doc = "! \\param [in]  hPhysicalGpu          The physical GPU handle"]
    #[doc = "! \\param [inout] pClientIllumDevicesControl  Pointer to structure containing control"]
    #[doc = "!                                 information about illum devices."]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!          If there are return error codes with specific meaning for this API,"]
    #[doc = "!          they are listed below."]
    #[doc = ""]
    pub fn NvAPI_GPU_ClientIllumDevicesSetControl(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pClientIllumDevicesControl: *mut NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS,
    ) -> NvAPI_Status;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB {
    pub rsvd: NvU8,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB)
        )
    );
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB = _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1"]
#[doc = " Describes the static information of illum zone type RGBW."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW {
    pub rsvd: NvU8,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW)
        )
    );
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1"]
#[doc = " Describes the static information of illum zone type RGBW."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW = _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1"]
#[doc = " Describes the static information of illum zone type SINGLE_COLOR."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR {
    pub rsvd: NvU8,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR)
        )
    );
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1"]
#[doc = " Describes the static information of illum zone type SINGLE_COLOR."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR =
    _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1 {
    pub type_: NV_GPU_CLIENT_ILLUM_ZONE_TYPE,
    #[doc = " Index pointing to an Illumination Device that controls this zone."]
    pub illumDeviceIdx: NvU8,
    #[doc = " Provider index for representing logical to physical zone mapping."]
    pub provIdx: NvU8,
    #[doc = " Location of the zone on the board."]
    pub zoneLocation: NV_GPU_CLIENT_ILLUM_ZONE_LOCATION,
    pub data: _NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1,
    pub rsvd: [NvU8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1 {
    pub rgb: NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB,
    pub rgbw: NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW,
    pub singleColor: NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR,
    #[doc = " Reserved bytes for possible future extension of this struct."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1)
        )
    );
    fn test_field_rgb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rgb) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1),
                "::",
                stringify!(rgb)
            )
        );
    }
    test_field_rgb();
    fn test_field_rgbw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rgbw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1),
                "::",
                stringify!(rgbw)
            )
        );
    }
    test_field_rgbw();
    fn test_field_singleColor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).singleColor) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1),
                "::",
                stringify!(singleColor)
            )
        );
    }
    test_field_singleColor();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1>(),
        140usize,
        concat!("Size of: ", stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1)
        )
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_illumDeviceIdx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).illumDeviceIdx) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1),
                "::",
                stringify!(illumDeviceIdx)
            )
        );
    }
    test_field_illumDeviceIdx();
    fn test_field_provIdx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).provIdx) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1),
                "::",
                stringify!(provIdx)
            )
        );
    }
    test_field_provIdx();
    fn test_field_zoneLocation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).zoneLocation) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1),
                "::",
                stringify!(zoneLocation)
            )
        );
    }
    test_field_zoneLocation();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1 = _NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1 {
    #[doc = " Version of structure. Must always be first member."]
    pub version: NvU32,
    #[doc = " Number of illumination zones present."]
    pub numIllumZones: NvU32,
    #[doc = " Reserved bytes for possible future extension of this struct."]
    pub rsvd: [NvU8; 64usize],
    pub zones: [NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1; 32usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1>(),
        4552usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_numIllumZones() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numIllumZones) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1),
                "::",
                stringify!(numIllumZones)
            )
        );
    }
    test_field_numIllumZones();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
    fn test_field_zones() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).zones) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1),
                "::",
                stringify!(zones)
            )
        );
    }
    test_field_zones();
}
impl Default for _NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1 = _NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1;
pub type NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS = NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1;
extern "C" {
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 400"]
    #[doc = "! \\param [in]  hPhysicalGpu     The physical GPU handle"]
    #[doc = "! \\param [out] pIllumZonesInfo  Pointer to structure containing static"]
    #[doc = "!                               information about illumination devices."]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!          If there are return error codes with specific meaning for this API,"]
    #[doc = "!          they are listed below."]
    #[doc = ""]
    pub fn NvAPI_GPU_ClientIllumZonesGetInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pIllumZonesInfo: *mut NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS,
    ) -> NvAPI_Status;
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB"]
#[doc = " Parameters required to represent control mode of type"]
#[doc = " \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGB."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS {
    #[doc = " Red compenent of color applied to the zone."]
    pub colorR: NvU8,
    #[doc = " Green compenent of color applied to the zone."]
    pub colorG: NvU8,
    #[doc = " Blue compenent of color applied to the zone."]
    pub colorB: NvU8,
    #[doc = " Brightness perecentage value of the zone."]
    pub brightnessPct: NvU8,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS)
        )
    );
    fn test_field_colorR() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorR) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS),
                "::",
                stringify!(colorR)
            )
        );
    }
    test_field_colorR();
    fn test_field_colorG() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorG) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS),
                "::",
                stringify!(colorG)
            )
        );
    }
    test_field_colorG();
    fn test_field_colorB() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorB) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS),
                "::",
                stringify!(colorB)
            )
        );
    }
    test_field_colorB();
    fn test_field_brightnessPct() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).brightnessPct) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS),
                "::",
                stringify!(brightnessPct)
            )
        );
    }
    test_field_brightnessPct();
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB"]
#[doc = " Parameters required to represent control mode of type"]
#[doc = " \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGB."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB"]
#[doc = " Data required to represent control mode of type"]
#[doc = " \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGB."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB {
    #[doc = " Parameters required to represent control mode of type"]
    #[doc = " \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGB."]
    pub rgbParams: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB)
        )
    );
    fn test_field_rgbParams() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rgbParams) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB),
                "::",
                stringify!(rgbParams)
            )
        );
    }
    test_field_rgbParams();
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB"]
#[doc = " Data required to represent control mode of type"]
#[doc = " \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGB."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB;
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB"]
#[doc = " Data required to represent control mode of type"]
#[doc = " \\ref NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGB."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR {
    #[doc = " Type of cycle effect to apply."]
    pub cycleType: NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE,
    #[doc = " Number of times to repeat function within group period."]
    pub grpCount: NvU8,
    #[doc = " Time in ms to transition from color A to color B."]
    pub riseTimems: NvU16,
    #[doc = " Time in ms to transition from color B to color A."]
    pub fallTimems: NvU16,
    #[doc = " Time in ms to remain at color A before color A to color B transition."]
    pub ATimems: NvU16,
    #[doc = " Time in ms to remain at color B before color B to color A transition."]
    pub BTimems: NvU16,
    #[doc = " Time in ms to remain idle before next group of repeated function cycles."]
    pub grpIdleTimems: NvU16,
    #[doc = " Time in ms to offset the cycle relative to other zones."]
    pub phaseOffsetms: NvU16,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR)
        )
    );
    fn test_field_cycleType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cycleType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR),
                "::",
                stringify!(cycleType)
            )
        );
    }
    test_field_cycleType();
    fn test_field_grpCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).grpCount) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR),
                "::",
                stringify!(grpCount)
            )
        );
    }
    test_field_grpCount();
    fn test_field_riseTimems() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).riseTimems) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR),
                "::",
                stringify!(riseTimems)
            )
        );
    }
    test_field_riseTimems();
    fn test_field_fallTimems() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fallTimems) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR),
                "::",
                stringify!(fallTimems)
            )
        );
    }
    test_field_fallTimems();
    fn test_field_ATimems() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ATimems) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR),
                "::",
                stringify!(ATimems)
            )
        );
    }
    test_field_ATimems();
    fn test_field_BTimems() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).BTimems) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR),
                "::",
                stringify!(BTimems)
            )
        );
    }
    test_field_BTimems();
    fn test_field_grpIdleTimems() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).grpIdleTimems) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR),
                "::",
                stringify!(grpIdleTimems)
            )
        );
    }
    test_field_grpIdleTimems();
    fn test_field_phaseOffsetms() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).phaseOffsetms) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR),
                "::",
                stringify!(phaseOffsetms)
            )
        );
    }
    test_field_phaseOffsetms();
}
impl Default for _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB"]
#[doc = " Data required to represent control mode of type"]
#[doc = " \\ref NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGB."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB"]
#[doc = " Data required to represent control mode of type"]
#[doc = " \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGB."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB {
    #[doc = " Parameters required to represent control mode of type"]
    #[doc = " \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGB."]
    pub rgbParams: [NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS; 2usize],
    pub piecewiseLinearData: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB)
        )
    );
    fn test_field_rgbParams() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rgbParams) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB),
                "::",
                stringify!(rgbParams)
            )
        );
    }
    test_field_rgbParams();
    fn test_field_piecewiseLinearData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).piecewiseLinearData) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB),
                "::",
                stringify!(piecewiseLinearData)
            )
        );
    }
    test_field_piecewiseLinearData();
}
impl Default for _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB"]
#[doc = " Data required to represent control mode of type"]
#[doc = " \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGB."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1"]
#[doc = " Describes the control data for illumination zone of type"]
#[doc = " \\ref NV_GPU_CLIENT_ILLUM_ZONE_TYPE_RGB."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB {
    pub data: _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1,
    #[doc = " Reserved for future."]
    pub rsvd: [NvU8; 64usize],
}
#[doc = " Union of illumination zone control data for zone of type NV_GPU_CLIENT_ILLUM_ZONE_TYPE_RGB."]
#[doc = " Interpreted as per ctrlMode."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1 {
    pub manualRGB: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB,
    pub piecewiseLinearRGB: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB,
    #[doc = " Reserved bytes for possible future extension of this struct."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1)
        )
    );
    fn test_field_manualRGB() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).manualRGB) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1),
                "::",
                stringify!(manualRGB)
            )
        );
    }
    test_field_manualRGB();
    fn test_field_piecewiseLinearRGB() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).piecewiseLinearRGB) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1),
                "::",
                stringify!(piecewiseLinearRGB)
            )
        );
    }
    test_field_piecewiseLinearRGB();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB)
        )
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1"]
#[doc = " Describes the control data for illumination zone of type"]
#[doc = " \\ref NV_GPU_CLIENT_ILLUM_ZONE_TYPE_RGB."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB = _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB;
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED"]
#[doc = " Parameters required to represent control mode of type"]
#[doc = " \\ref NV_GPU_ILLUM_CTRL_MODE_MANUAL_RGB."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS {
    #[doc = " Brightness percentage value of the zone."]
    pub brightnessPct: NvU8,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS)
        )
    );
    fn test_field_brightnessPct() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).brightnessPct) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS),
                "::",
                stringify!(brightnessPct)
            )
        );
    }
    test_field_brightnessPct();
}
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED"]
#[doc = " Parameters required to represent control mode of type"]
#[doc = " \\ref NV_GPU_ILLUM_CTRL_MODE_MANUAL_RGB."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED"]
#[doc = " Data required to represent control mode of type"]
#[doc = " \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGB."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED {
    #[doc = " Parameters required to represent control mode of type"]
    #[doc = " \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGB."]
    pub colorFixedParams: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED)
        )
    );
    fn test_field_colorFixedParams() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorFixedParams) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED),
                "::",
                stringify!(colorFixedParams)
            )
        );
    }
    test_field_colorFixedParams();
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED"]
#[doc = " Data required to represent control mode of type"]
#[doc = " \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGB."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED"]
#[doc = " Data required to represent control mode of type"]
#[doc = " \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGB."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED {
    #[doc = " Parameters required to represent control mode of type"]
    #[doc = " \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGB."]
    pub colorFixedParams: [NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS; 2usize],
    pub piecewiseLinearData: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED>(
        ),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED)
        )
    );
    fn test_field_colorFixedParams() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorFixedParams) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED),
                "::",
                stringify!(colorFixedParams)
            )
        );
    }
    test_field_colorFixedParams();
    fn test_field_piecewiseLinearData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).piecewiseLinearData) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED),
                "::",
                stringify!(piecewiseLinearData)
            )
        );
    }
    test_field_piecewiseLinearData();
}
impl Default for _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED"]
#[doc = " Data required to represent control mode of type"]
#[doc = " \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGB."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1"]
#[doc = " Describes the control data for illum zone of type"]
#[doc = " \\ref NV_GPU_CLIENT_ILLUM_ZONE_TYPE_COLOR_FIXED."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED {
    pub data: _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1,
    #[doc = " Reserved for future."]
    pub rsvd: [NvU8; 64usize],
}
#[doc = " Union of illum zone control data for zone of type NV_GPU_CLIENT_ILLUM_ZONE_TYPE_COLOR_FIXED."]
#[doc = " Interpreted as per ctrlMode."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1 {
    pub manualColorFixed: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED,
    pub piecewiseLinearColorFixed:
        NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED,
    #[doc = " Reserved bytes for possible future extension of this struct."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1)
        )
    );
    fn test_field_manualColorFixed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).manualColorFixed) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1),
                "::",
                stringify!(manualColorFixed)
            )
        );
    }
    test_field_manualColorFixed();
    fn test_field_piecewiseLinearColorFixed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).piecewiseLinearColorFixed) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1),
                "::",
                stringify!(piecewiseLinearColorFixed)
            )
        );
    }
    test_field_piecewiseLinearColorFixed();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED)
        )
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1"]
#[doc = " Describes the control data for illum zone of type"]
#[doc = " \\ref NV_GPU_CLIENT_ILLUM_ZONE_TYPE_COLOR_FIXED."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW"]
#[doc = " Parameters required to represent control mode of type"]
#[doc = " \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGBW."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS {
    #[doc = " Red component of color applied to the zone."]
    pub colorR: NvU8,
    #[doc = " Green component of color applied to the zone."]
    pub colorG: NvU8,
    #[doc = " Blue component of color applied to the zone."]
    pub colorB: NvU8,
    #[doc = " White component of color applied to the zone."]
    pub colorW: NvU8,
    #[doc = " Brightness percentage value of the zone."]
    pub brightnessPct: NvU8,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS>(),
        5usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS)
        )
    );
    fn test_field_colorR() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorR) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS),
                "::",
                stringify!(colorR)
            )
        );
    }
    test_field_colorR();
    fn test_field_colorG() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorG) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS),
                "::",
                stringify!(colorG)
            )
        );
    }
    test_field_colorG();
    fn test_field_colorB() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorB) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS),
                "::",
                stringify!(colorB)
            )
        );
    }
    test_field_colorB();
    fn test_field_colorW() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorW) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS),
                "::",
                stringify!(colorW)
            )
        );
    }
    test_field_colorW();
    fn test_field_brightnessPct() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).brightnessPct) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS),
                "::",
                stringify!(brightnessPct)
            )
        );
    }
    test_field_brightnessPct();
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW"]
#[doc = " Parameters required to represent control mode of type"]
#[doc = " \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGBW."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS;
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_RGBW"]
#[doc = " Data required to represent control mode of type"]
#[doc = " \\ref NV_GPU_ILLUM_CTRL_MODE_MANUAL_RGBW."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW {
    #[doc = " Parameters required to represent control mode of type"]
    #[doc = " \\ref NV_GPU_ILLUM_CTRL_MODE_MANUAL_RGBW."]
    pub rgbwParams: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW>(),
        5usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW)
        )
    );
    fn test_field_rgbwParams() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rgbwParams) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW),
                "::",
                stringify!(rgbwParams)
            )
        );
    }
    test_field_rgbwParams();
}
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_RGBW"]
#[doc = " Data required to represent control mode of type"]
#[doc = " \\ref NV_GPU_ILLUM_CTRL_MODE_MANUAL_RGBW."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW;
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_RGBW"]
#[doc = " Data required to represent control mode of type"]
#[doc = " \\ref NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGBW."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW {
    #[doc = " Parameters required to represent control mode of type"]
    #[doc = " \\ref NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGBW."]
    pub rgbwParams: [NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS; 2usize],
    pub piecewiseLinearData: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW)
        )
    );
    fn test_field_rgbwParams() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rgbwParams) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW),
                "::",
                stringify!(rgbwParams)
            )
        );
    }
    test_field_rgbwParams();
    fn test_field_piecewiseLinearData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).piecewiseLinearData) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW),
                "::",
                stringify!(piecewiseLinearData)
            )
        );
    }
    test_field_piecewiseLinearData();
}
impl Default for _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_RGBW"]
#[doc = " Data required to represent control mode of type"]
#[doc = " \\ref NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGBW."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW;
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_V1"]
#[doc = " Describes the control data for illum zone of type"]
#[doc = " \\ref NV_GPU_ILLUM_ZONE_TYPE_RGBW."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW {
    pub data: _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1,
    #[doc = " Reserved for future."]
    pub rsvd: [NvU8; 64usize],
}
#[doc = " Union of illum zone control data for zone of type NV_GPU_ILLUM_ZONE_TYPE_RGBW."]
#[doc = " Interpreted as per ctrlMode."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1 {
    pub manualRGBW: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW,
    pub piecewiseLinearRGBW: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW,
    #[doc = " Reserved bytes for possible future extension of this struct."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1)
        )
    );
    fn test_field_manualRGBW() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).manualRGBW) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1),
                "::",
                stringify!(manualRGBW)
            )
        );
    }
    test_field_manualRGBW();
    fn test_field_piecewiseLinearRGBW() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).piecewiseLinearRGBW) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1),
                "::",
                stringify!(piecewiseLinearRGBW)
            )
        );
    }
    test_field_piecewiseLinearRGBW();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW)
        )
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_V1"]
#[doc = " Describes the control data for illum zone of type"]
#[doc = " \\ref NV_GPU_ILLUM_ZONE_TYPE_RGBW."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW = _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW;
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR"]
#[doc = " Parameters required to represent control mode of type"]
#[doc = " \\ref NV_GPU_ILLUM_CTRL_MODE_MANUAL_SINGLE_COLOR."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS {
    #[doc = " Brightness percentage value of the zone."]
    pub brightnessPct: NvU8,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS)
        )
    );
    fn test_field_brightnessPct() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).brightnessPct) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS),
                "::",
                stringify!(brightnessPct)
            )
        );
    }
    test_field_brightnessPct();
}
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR"]
#[doc = " Parameters required to represent control mode of type"]
#[doc = " \\ref NV_GPU_ILLUM_CTRL_MODE_MANUAL_SINGLE_COLOR."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS;
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR"]
#[doc = " Data required to represent control mode of type"]
#[doc = " \\ref NV_GPU_ILLUM_CTRL_MODE_MANUAL_SINGLE_COLOR."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR {
    #[doc = " Parameters required to represent control mode of type"]
    #[doc = " \\ref NV_GPU_ILLUM_CTRL_MODE_MANUAL_SINGLE_COLOR."]
    pub singleColorParams: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR)
        )
    );
    fn test_field_singleColorParams() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).singleColorParams) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR),
                "::",
                stringify!(singleColorParams)
            )
        );
    }
    test_field_singleColorParams();
}
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR"]
#[doc = " Data required to represent control mode of type"]
#[doc = " \\ref NV_GPU_ILLUM_CTRL_MODE_MANUAL_SINGLE_COLOR."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR;
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR"]
#[doc = " Data required to represent control mode of type"]
#[doc = " \\ref NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_SINGLE_COLOR."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR {
    #[doc = " Parameters required to represent control mode of type"]
    #[doc = " \\ref NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_SINGLE_COLOR."]
    pub singleColorParams:
        [NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS; 2usize],
    pub piecewiseLinearData: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR>(
        ),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR)
        )
    );
    fn test_field_singleColorParams() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).singleColorParams) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR),
                "::",
                stringify!(singleColorParams)
            )
        );
    }
    test_field_singleColorParams();
    fn test_field_piecewiseLinearData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).piecewiseLinearData) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR),
                "::",
                stringify!(piecewiseLinearData)
            )
        );
    }
    test_field_piecewiseLinearData();
}
impl Default for _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR"]
#[doc = " Data required to represent control mode of type"]
#[doc = " \\ref NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_SINGLE_COLOR."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR;
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_V1"]
#[doc = " Describes the control data for illum zone of type"]
#[doc = " \\ref NV_GPU_ILLUM_ZONE_TYPE_SINGLE_COLOR."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR {
    pub data: _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1,
    #[doc = " Reserved for future."]
    pub rsvd: [NvU8; 64usize],
}
#[doc = " Union of illum zone control data for zone of type NV_GPU_ILLUM_ZONE_TYPE_SINGLE_COLOR."]
#[doc = " Interpreted as per ctrlMode."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1 {
    pub manualSingleColor: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR,
    pub piecewiseLinearSingleColor:
        NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR,
    #[doc = " Reserved bytes for possible future extension of this struct."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1)
        )
    );
    fn test_field_manualSingleColor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).manualSingleColor) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1),
                "::",
                stringify!(manualSingleColor)
            )
        );
    }
    test_field_manualSingleColor();
    fn test_field_piecewiseLinearSingleColor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).piecewiseLinearSingleColor) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1),
                "::",
                stringify!(piecewiseLinearSingleColor)
            )
        );
    }
    test_field_piecewiseLinearSingleColor();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR)
        )
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_V1"]
#[doc = " Describes the control data for illum zone of type"]
#[doc = " \\ref NV_GPU_ILLUM_ZONE_TYPE_SINGLE_COLOR."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1 {
    pub type_: NV_GPU_CLIENT_ILLUM_ZONE_TYPE,
    pub ctrlMode: NV_GPU_CLIENT_ILLUM_CTRL_MODE,
    pub data: _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1,
    pub rsvd: [NvU8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1 {
    pub rgb: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB,
    pub colorFixed: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED,
    pub rgbw: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW,
    pub singleColor: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR,
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1)
        )
    );
    fn test_field_rgb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rgb) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1),
                "::",
                stringify!(rgb)
            )
        );
    }
    test_field_rgb();
    fn test_field_colorFixed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorFixed) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1),
                "::",
                stringify!(colorFixed)
            )
        );
    }
    test_field_colorFixed();
    fn test_field_rgbw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rgbw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1),
                "::",
                stringify!(rgbw)
            )
        );
    }
    test_field_rgbw();
    fn test_field_singleColor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).singleColor) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1),
                "::",
                stringify!(singleColor)
            )
        );
    }
    test_field_singleColor();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1>(),
        200usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1)
        )
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_ctrlMode() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctrlMode) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1),
                "::",
                stringify!(ctrlMode)
            )
        );
    }
    test_field_ctrlMode();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1 = _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " Number of illumination zones present."]
    pub numIllumZonesControl: NvU32,
    #[doc = " Reserved bytes for possible future extension of this struct."]
    pub rsvd: [NvU8; 64usize],
    pub zones: [NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1; 32usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1>(),
        6476usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_numIllumZonesControl() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numIllumZonesControl) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1),
                "::",
                stringify!(numIllumZonesControl)
            )
        );
    }
    test_field_numIllumZonesControl();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
    fn test_field_zones() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).zones) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1),
                "::",
                stringify!(zones)
            )
        );
    }
    test_field_zones();
}
impl Default for _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1 {
    #[inline]
    pub fn bDefault(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bDefault(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvdField(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_rsvdField(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bDefault: NvU32,
        rsvdField: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bDefault: u32 = unsafe { ::std::mem::transmute(bDefault) };
            bDefault as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let rsvdField: u32 = unsafe { ::std::mem::transmute(rsvdField) };
            rsvdField as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1 = _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1;
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS = NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1;
extern "C" {
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 400"]
    #[doc = "! \\param [in]  hPhysicalGpu        The physical GPU handle"]
    #[doc = "! \\param [out] pIllumZonesControl  Pointer to structure containing control"]
    #[doc = "!                                  information about illumination zones."]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!          If there are return error codes with specific meaning for this API,"]
    #[doc = "!          they are listed below."]
    #[doc = ""]
    pub fn NvAPI_GPU_ClientIllumZonesGetControl(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pIllumZonesControl: *mut NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! TCC_SUPPORTED"]
    #[doc = "!"]
    #[doc = "! \\since Release: 400"]
    #[doc = "! \\param [in]  hPhysicalGpu        The physical GPU handle"]
    #[doc = "! \\param [out] pIllumZonesControl  Pointer to structure containing control"]
    #[doc = "!                                  information about illumination zones."]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!          If there are return error codes with specific meaning for this API,"]
    #[doc = "!          they are listed below."]
    #[doc = ""]
    pub fn NvAPI_GPU_ClientIllumZonesSetControl(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pIllumZonesControl: *mut NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API registers the process for events. This API should be called for each eventcallback."]
    #[doc = "!                The handle returned to the client will be common across all eventCallbacks."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]  eventCallback  Pointer to NV_EVENT_REGISTER_CALLBACK structure to call"]
    #[doc = "!                             on new events"]
    #[doc = "! \\param [out] phClient       Handle to client for use with"]
    #[doc = "!                             unregister function"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK - completed request"]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED - NvAPI not initialized"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT - Invalid argument"]
    #[doc = "! \\retval ::NVAPI_ERROR - miscellaneous error occurred"]
    #[doc = "!"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_Event_RegisterCallback(
        eventCallback: PNV_EVENT_REGISTER_CALLBACK,
        phClient: *mut NvEventHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API unregister an event handle."]
    #[doc = "!                This API should be called only once per process(irrespective of the number of callbacks registered)."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]    hClient  Handle associated with this listeners"]
    #[doc = "!                         event queue. Same as returned from"]
    #[doc = "!                         NvAPI_Event_RegisterCallback()."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK - completed request"]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED - NvAPI not initialized"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT - Invalid argument"]
    #[doc = "! \\retval ::NVAPI_ERROR - miscellaneous error occurred"]
    #[doc = "!"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_Event_UnregisterCallback(hClient: NvEventHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns the handle of the NVIDIA display specified by the enum"]
    #[doc = "!                index (thisEnum). The client should keep enumerating until it"]
    #[doc = "!                returns error."]
    #[doc = "!"]
    #[doc = "!                Note: Display handles can get invalidated on a modeset, so the calling applications need to"]
    #[doc = "!                renum the handles after every modeset."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "! \\param [in]  thisEnum      The index of the NVIDIA display."]
    #[doc = "! \\param [out] pNvDispHandle Pointer to the NVIDIA display handle."]
    #[doc = "!"]
    #[doc = "! \\retval NVAPI_INVALID_ARGUMENT        Either the handle pointer is NULL or enum index too big"]
    #[doc = "! \\retval NVAPI_OK                      Return a valid NvDisplayHandle based on the enum index"]
    #[doc = "! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND No NVIDIA device found in the system"]
    #[doc = "! \\retval NVAPI_END_ENUMERATION         No more display device to enumerate"]
    #[doc = "! \\ingroup disphandle"]
    #[doc = ""]
    pub fn NvAPI_EnumNvidiaDisplayHandle(
        thisEnum: NvU32,
        pNvDispHandle: *mut NvDisplayHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns the handle of the NVIDIA unattached display specified by the enum"]
    #[doc = "!                index (thisEnum). The client should keep enumerating until it"]
    #[doc = "!                returns error."]
    #[doc = "!                Note: Display handles can get invalidated on a modeset, so the calling applications need to"]
    #[doc = "!                renum the handles after every modeset."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "! \\param [in]  thisEnum                  The index of the NVIDIA display."]
    #[doc = "! \\param [out] pNvUnAttachedDispHandle   Pointer to the NVIDIA display handle of the unattached display."]
    #[doc = "!"]
    #[doc = "! \\retval NVAPI_INVALID_ARGUMENT         Either the handle pointer is NULL or enum index too big"]
    #[doc = "! \\retval NVAPI_OK                       Return a valid NvDisplayHandle based on the enum index"]
    #[doc = "! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA device found in the system"]
    #[doc = "! \\retval NVAPI_END_ENUMERATION          No more display device to enumerate."]
    #[doc = "! \\ingroup disphandle"]
    #[doc = ""]
    pub fn NvAPI_EnumNvidiaUnAttachedDisplayHandle(
        thisEnum: NvU32,
        pNvUnAttachedDispHandle: *mut NvUnAttachedDisplayHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function converts the unattached display handle to an active attached display handle."]
    #[doc = "!"]
    #[doc = "! At least one GPU must be present in the system and running an NVIDIA display driver."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "! \\retval NVAPI_INVALID_ARGUMENT         hNvUnAttachedDisp is not valid or pNvDisplay is NULL."]
    #[doc = "! \\retval NVAPI_OK                       One or more handles were returned"]
    #[doc = "! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found"]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_CreateDisplayFromUnAttachedDisplay(
        hNvUnAttachedDisp: NvUnAttachedDisplayHandle,
        pNvDisplay: *mut NvDisplayHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the handle of the NVIDIA display that is associated"]
    #[doc = "!  with the given display \"name\" (such as \"\\\\.\\DISPLAY1\")."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "! \\retval NVAPI_INVALID_ARGUMENT         Either argument is NULL"]
    #[doc = "! \\retval NVAPI_OK                      *pNvDispHandle is now valid"]
    #[doc = "! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA device maps to that display name"]
    #[doc = "! \\ingroup disphandle"]
    #[doc = ""]
    pub fn NvAPI_GetAssociatedNvidiaDisplayHandle(
        szDisplayName: *const ::std::os::raw::c_char,
        pNvDispHandle: *mut NvDisplayHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This function returns the handle of an unattached NVIDIA display that is"]
    #[doc = "!                associated with the given display name (such as \"\\\\DISPLAY1\")."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 185"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT          Either argument is NULL."]
    #[doc = "! \\retval ::NVAPI_OK                       *pNvUnAttachedDispHandle is now valid."]
    #[doc = "! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND   No NVIDIA device maps to that display name."]
    #[doc = "!"]
    #[doc = "! \\ingroup disphandle"]
    #[doc = ""]
    pub fn NvAPI_DISP_GetAssociatedUnAttachedNvidiaDisplayHandle(
        szDisplayName: *const ::std::os::raw::c_char,
        pNvUnAttachedDispHandle: *mut NvUnAttachedDisplayHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  For a given NVIDIA display handle, this function returns a string (such as \"\\\\.\\DISPLAY1\") to identify the display."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "! \\retval NVAPI_INVALID_ARGUMENT          Either argument is NULL"]
    #[doc = "! \\retval NVAPI_OK                       *pNvDispHandle is now valid"]
    #[doc = "! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND   No NVIDIA device maps to that display name"]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_GetAssociatedNvidiaDisplayName(
        NvDispHandle: NvDisplayHandle,
        szDisplayName: *mut ::std::os::raw::c_char,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the display name given, for example, \"\\\\DISPLAY1\", using the unattached NVIDIA display handle"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 95"]
    #[doc = "!"]
    #[doc = "! \\retval NVAPI_INVALID_ARGUMENT          Either argument is NULL"]
    #[doc = "! \\retval NVAPI_OK                       *pNvDispHandle is now valid"]
    #[doc = "! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND   No NVIDIA device maps to that display name"]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_GetUnAttachedAssociatedDisplayName(
        hNvUnAttachedDisp: NvUnAttachedDisplayHandle,
        szDisplayName: *mut ::std::os::raw::c_char,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function enables hardware cursor support"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows XP"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "! \\return NVAPI_ERROR or NVAPI_OK"]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_EnableHWCursor(hNvDisplay: NvDisplayHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function disables hardware cursor support"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows XP"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "! \\return  NVAPI_ERROR or NVAPI_OK"]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_DisableHWCursor(hNvDisplay: NvDisplayHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function gets the V-blank counter"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "! \\return NVAPI_ERROR or NVAPI_OK"]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_GetVBlankCounter(
        hNvDisplay: NvDisplayHandle,
        pCounter: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function overrides the refresh rate on the given display/outputsMask."]
    #[doc = "!  The new refresh rate can be applied right away in this API call or deferred to be applied with the"]
    #[doc = "!  next OS modeset. The override is good for only one modeset (regardless whether it's deferred or immediate)."]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows XP"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 80"]
    #[doc = "!"]
    #[doc = "!  \\param [in] hNvDisplay    The NVIDIA display handle. It can be NVAPI_DEFAULT_HANDLE or a handle"]
    #[doc = "!                           enumerated from NvAPI_EnumNVidiaDisplayHandle()."]
    #[doc = "!  \\param [in] outputsMask  A set of bits that identify all target outputs which are associated with the NVIDIA"]
    #[doc = "!                           display handle to apply the refresh rate override. When SLI is enabled, the"]
    #[doc = "!                           outputsMask only applies to the GPU that is driving the display output."]
    #[doc = "!  \\param [in] refreshRate  The override value. \"0.0\" means cancel the override."]
    #[doc = "!  \\param [in] bSetDeferred"]
    #[doc = "!              - \"0\": Apply the refresh rate override immediately in this API call.\\p"]
    #[doc = "!              - \"1\": Apply refresh rate at the next OS modeset."]
    #[doc = "!"]
    #[doc = "!  \\retval  NVAPI_INVALID_ARGUMENT hNvDisplay or outputsMask is invalid"]
    #[doc = "!  \\retval  NVAPI_OK               The refresh rate override is correct set"]
    #[doc = "!  \\retval  NVAPI_ERROR            The operation failed"]
    #[doc = "!  \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_SetRefreshRateOverride(
        hNvDisplay: NvDisplayHandle,
        outputsMask: NvU32,
        refreshRate: f32,
        bSetDeferred: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function gets the active outputId associated with the display handle."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 90"]
    #[doc = "!"]
    #[doc = "! \\param [in]  hNvDisplay  NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle()."]
    #[doc = "! \\param [out] outputId    The active display output ID associated with the selected display handle hNvDisplay."]
    #[doc = "!                          The outputid will have only one bit set. In the case of Clone or Span mode, this will indicate the"]
    #[doc = "!                          display outputId of the primary display that the GPU is driving. See \\ref handles."]
    #[doc = "!"]
    #[doc = "! \\retval  NVAPI_OK                      Call successful."]
    #[doc = "! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND No NVIDIA GPU driving a display was found."]
    #[doc = "! \\retval  NVAPI_EXPECTED_DISPLAY_HANDLE hNvDisplay is not a valid display handle."]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_GetAssociatedDisplayOutputId(
        hNvDisplay: NvDisplayHandle,
        pOutputId: *mut NvU32,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NvAPI_GetDisplayPortInfo()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_DISPLAY_PORT_INFO_V1 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< DPCD version of the monitor"]
    pub dpcd_ver: NvU32,
    #[doc = "!< Maximum supported link rate"]
    pub maxLinkRate: NV_DP_LINK_RATE,
    #[doc = "!< Maximum supported lane count"]
    pub maxLaneCount: NV_DP_LANE_COUNT,
    #[doc = "!< Current link rate"]
    pub curLinkRate: NV_DP_LINK_RATE,
    #[doc = "!< Current lane count"]
    pub curLaneCount: NV_DP_LANE_COUNT,
    #[doc = "!< Current color format"]
    pub colorFormat: NV_DP_COLOR_FORMAT,
    #[doc = "!< Dynamic range"]
    pub dynamicRange: NV_DP_DYNAMIC_RANGE,
    #[doc = "!< Ignored in RGB space"]
    pub colorimetry: NV_DP_COLORIMETRY,
    #[doc = "!< Current bit-per-component"]
    pub bpc: NV_DP_BPC,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NV_DISPLAY_PORT_INFO_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_DISPLAY_PORT_INFO_V1>(),
        44usize,
        concat!("Size of: ", stringify!(_NV_DISPLAY_PORT_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_DISPLAY_PORT_INFO_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_DISPLAY_PORT_INFO_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAY_PORT_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAY_PORT_INFO_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_dpcd_ver() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAY_PORT_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dpcd_ver) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAY_PORT_INFO_V1),
                "::",
                stringify!(dpcd_ver)
            )
        );
    }
    test_field_dpcd_ver();
    fn test_field_maxLinkRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAY_PORT_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxLinkRate) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAY_PORT_INFO_V1),
                "::",
                stringify!(maxLinkRate)
            )
        );
    }
    test_field_maxLinkRate();
    fn test_field_maxLaneCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAY_PORT_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxLaneCount) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAY_PORT_INFO_V1),
                "::",
                stringify!(maxLaneCount)
            )
        );
    }
    test_field_maxLaneCount();
    fn test_field_curLinkRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAY_PORT_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).curLinkRate) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAY_PORT_INFO_V1),
                "::",
                stringify!(curLinkRate)
            )
        );
    }
    test_field_curLinkRate();
    fn test_field_curLaneCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAY_PORT_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).curLaneCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAY_PORT_INFO_V1),
                "::",
                stringify!(curLaneCount)
            )
        );
    }
    test_field_curLaneCount();
    fn test_field_colorFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAY_PORT_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAY_PORT_INFO_V1),
                "::",
                stringify!(colorFormat)
            )
        );
    }
    test_field_colorFormat();
    fn test_field_dynamicRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAY_PORT_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dynamicRange) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAY_PORT_INFO_V1),
                "::",
                stringify!(dynamicRange)
            )
        );
    }
    test_field_dynamicRange();
    fn test_field_colorimetry() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAY_PORT_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorimetry) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAY_PORT_INFO_V1),
                "::",
                stringify!(colorimetry)
            )
        );
    }
    test_field_colorimetry();
    fn test_field_bpc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAY_PORT_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bpc) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAY_PORT_INFO_V1),
                "::",
                stringify!(bpc)
            )
        );
    }
    test_field_bpc();
}
impl Default for _NV_DISPLAY_PORT_INFO_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_DISPLAY_PORT_INFO_V1 {
    #[inline]
    pub fn isDp(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isDp(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isInternalDp(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isInternalDp(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isColorCtrlSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isColorCtrlSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is6BPCSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is6BPCSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is8BPCSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is8BPCSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is10BPCSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is10BPCSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is12BPCSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is12BPCSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is16BPCSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is16BPCSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isYCrCb420Supported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isYCrCb420Supported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isYCrCb422Supported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isYCrCb422Supported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isYCrCb444Supported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isYCrCb444Supported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isRgb444SupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isRgb444SupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isYCbCr444SupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isYCbCr444SupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isYCbCr422SupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isYCbCr422SupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isYCbCr420SupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isYCbCr420SupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is6BPCSupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is6BPCSupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is8BPCSupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is8BPCSupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is10BPCSupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is10BPCSupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is12BPCSupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is12BPCSupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is16BPCSupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is16BPCSupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonxvYCC601Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonxvYCC601Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonxvYCC709Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonxvYCC709Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonsYCC601Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonsYCC601Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonAdobeYCC601Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonAdobeYCC601Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonAdobeRGBCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonAdobeRGBCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonBT2020RGBCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonBT2020RGBCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonBT2020YCCCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonBT2020YCCCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonBT2020cYCCCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonBT2020cYCCCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isDp: NvU32,
        isInternalDp: NvU32,
        isColorCtrlSupported: NvU32,
        is6BPCSupported: NvU32,
        is8BPCSupported: NvU32,
        is10BPCSupported: NvU32,
        is12BPCSupported: NvU32,
        is16BPCSupported: NvU32,
        isYCrCb420Supported: NvU32,
        isYCrCb422Supported: NvU32,
        isYCrCb444Supported: NvU32,
        isRgb444SupportedOnCurrentMode: NvU32,
        isYCbCr444SupportedOnCurrentMode: NvU32,
        isYCbCr422SupportedOnCurrentMode: NvU32,
        isYCbCr420SupportedOnCurrentMode: NvU32,
        is6BPCSupportedOnCurrentMode: NvU32,
        is8BPCSupportedOnCurrentMode: NvU32,
        is10BPCSupportedOnCurrentMode: NvU32,
        is12BPCSupportedOnCurrentMode: NvU32,
        is16BPCSupportedOnCurrentMode: NvU32,
        isMonxvYCC601Capable: NvU32,
        isMonxvYCC709Capable: NvU32,
        isMonsYCC601Capable: NvU32,
        isMonAdobeYCC601Capable: NvU32,
        isMonAdobeRGBCapable: NvU32,
        isMonBT2020RGBCapable: NvU32,
        isMonBT2020YCCCapable: NvU32,
        isMonBT2020cYCCCapable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isDp: u32 = unsafe { ::std::mem::transmute(isDp) };
            isDp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isInternalDp: u32 = unsafe { ::std::mem::transmute(isInternalDp) };
            isInternalDp as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isColorCtrlSupported: u32 = unsafe { ::std::mem::transmute(isColorCtrlSupported) };
            isColorCtrlSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is6BPCSupported: u32 = unsafe { ::std::mem::transmute(is6BPCSupported) };
            is6BPCSupported as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is8BPCSupported: u32 = unsafe { ::std::mem::transmute(is8BPCSupported) };
            is8BPCSupported as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is10BPCSupported: u32 = unsafe { ::std::mem::transmute(is10BPCSupported) };
            is10BPCSupported as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let is12BPCSupported: u32 = unsafe { ::std::mem::transmute(is12BPCSupported) };
            is12BPCSupported as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let is16BPCSupported: u32 = unsafe { ::std::mem::transmute(is16BPCSupported) };
            is16BPCSupported as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let isYCrCb420Supported: u32 = unsafe { ::std::mem::transmute(isYCrCb420Supported) };
            isYCrCb420Supported as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let isYCrCb422Supported: u32 = unsafe { ::std::mem::transmute(isYCrCb422Supported) };
            isYCrCb422Supported as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let isYCrCb444Supported: u32 = unsafe { ::std::mem::transmute(isYCrCb444Supported) };
            isYCrCb444Supported as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let isRgb444SupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(isRgb444SupportedOnCurrentMode) };
            isRgb444SupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let isYCbCr444SupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(isYCbCr444SupportedOnCurrentMode) };
            isYCbCr444SupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let isYCbCr422SupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(isYCbCr422SupportedOnCurrentMode) };
            isYCbCr422SupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let isYCbCr420SupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(isYCbCr420SupportedOnCurrentMode) };
            isYCbCr420SupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let is6BPCSupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(is6BPCSupportedOnCurrentMode) };
            is6BPCSupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let is8BPCSupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(is8BPCSupportedOnCurrentMode) };
            is8BPCSupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let is10BPCSupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(is10BPCSupportedOnCurrentMode) };
            is10BPCSupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let is12BPCSupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(is12BPCSupportedOnCurrentMode) };
            is12BPCSupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let is16BPCSupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(is16BPCSupportedOnCurrentMode) };
            is16BPCSupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let isMonxvYCC601Capable: u32 = unsafe { ::std::mem::transmute(isMonxvYCC601Capable) };
            isMonxvYCC601Capable as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let isMonxvYCC709Capable: u32 = unsafe { ::std::mem::transmute(isMonxvYCC709Capable) };
            isMonxvYCC709Capable as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let isMonsYCC601Capable: u32 = unsafe { ::std::mem::transmute(isMonsYCC601Capable) };
            isMonsYCC601Capable as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let isMonAdobeYCC601Capable: u32 =
                unsafe { ::std::mem::transmute(isMonAdobeYCC601Capable) };
            isMonAdobeYCC601Capable as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let isMonAdobeRGBCapable: u32 = unsafe { ::std::mem::transmute(isMonAdobeRGBCapable) };
            isMonAdobeRGBCapable as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let isMonBT2020RGBCapable: u32 =
                unsafe { ::std::mem::transmute(isMonBT2020RGBCapable) };
            isMonBT2020RGBCapable as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let isMonBT2020YCCCapable: u32 =
                unsafe { ::std::mem::transmute(isMonBT2020YCCCapable) };
            isMonBT2020YCCCapable as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let isMonBT2020cYCCCapable: u32 =
                unsafe { ::std::mem::transmute(isMonBT2020cYCCCapable) };
            isMonBT2020cYCCCapable as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NvAPI_GetDisplayPortInfo()."]
pub type NV_DISPLAY_PORT_INFO_V1 = _NV_DISPLAY_PORT_INFO_V1;
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NvAPI_GetDisplayPortInfo()."]
pub type NV_DISPLAY_PORT_INFO = NV_DISPLAY_PORT_INFO_V1;
extern "C" {
    #[doc = ""]
    #[doc = "! \\ingroup        dispcontrol"]
    pub fn NvAPI_GetDisplayPortInfo(
        hNvDisplay: NvDisplayHandle,
        outputId: NvU32,
        pInfo: *mut NV_DISPLAY_PORT_INFO,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! DisplayPort configuration settings - used in NvAPI_SetDisplayPort()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_DISPLAY_PORT_CONFIG {
    #[doc = "!< Structure version - 2 is the latest"]
    pub version: NvU32,
    #[doc = "!< Link rate"]
    pub linkRate: NV_DP_LINK_RATE,
    #[doc = "!< Lane count"]
    pub laneCount: NV_DP_LANE_COUNT,
    #[doc = "!< Color format to set"]
    pub colorFormat: NV_DP_COLOR_FORMAT,
    #[doc = "!< Dynamic range"]
    pub dynamicRange: NV_DP_DYNAMIC_RANGE,
    #[doc = "!< Ignored in RGB space"]
    pub colorimetry: NV_DP_COLORIMETRY,
    #[doc = "!< Bit-per-component"]
    pub bpc: NV_DP_BPC,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_NV_DISPLAY_PORT_CONFIG() {
    assert_eq!(
        ::std::mem::size_of::<NV_DISPLAY_PORT_CONFIG>(),
        32usize,
        concat!("Size of: ", stringify!(NV_DISPLAY_PORT_CONFIG))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_DISPLAY_PORT_CONFIG>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_DISPLAY_PORT_CONFIG))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PORT_CONFIG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PORT_CONFIG),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_linkRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PORT_CONFIG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).linkRate) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PORT_CONFIG),
                "::",
                stringify!(linkRate)
            )
        );
    }
    test_field_linkRate();
    fn test_field_laneCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PORT_CONFIG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).laneCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PORT_CONFIG),
                "::",
                stringify!(laneCount)
            )
        );
    }
    test_field_laneCount();
    fn test_field_colorFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PORT_CONFIG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PORT_CONFIG),
                "::",
                stringify!(colorFormat)
            )
        );
    }
    test_field_colorFormat();
    fn test_field_dynamicRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PORT_CONFIG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dynamicRange) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PORT_CONFIG),
                "::",
                stringify!(dynamicRange)
            )
        );
    }
    test_field_dynamicRange();
    fn test_field_colorimetry() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PORT_CONFIG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorimetry) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PORT_CONFIG),
                "::",
                stringify!(colorimetry)
            )
        );
    }
    test_field_colorimetry();
    fn test_field_bpc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_DISPLAY_PORT_CONFIG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bpc) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_DISPLAY_PORT_CONFIG),
                "::",
                stringify!(bpc)
            )
        );
    }
    test_field_bpc();
}
impl Default for NV_DISPLAY_PORT_CONFIG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl NV_DISPLAY_PORT_CONFIG {
    #[inline]
    pub fn isHPD(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isHPD(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isSetDeferred(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isSetDeferred(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isChromaLpfOff(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isChromaLpfOff(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isDitherOff(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isDitherOff(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn testLinkTrain(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_testLinkTrain(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn testColorChange(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_testColorChange(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isHPD: NvU32,
        isSetDeferred: NvU32,
        isChromaLpfOff: NvU32,
        isDitherOff: NvU32,
        testLinkTrain: NvU32,
        testColorChange: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isHPD: u32 = unsafe { ::std::mem::transmute(isHPD) };
            isHPD as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isSetDeferred: u32 = unsafe { ::std::mem::transmute(isSetDeferred) };
            isSetDeferred as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isChromaLpfOff: u32 = unsafe { ::std::mem::transmute(isChromaLpfOff) };
            isChromaLpfOff as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let isDitherOff: u32 = unsafe { ::std::mem::transmute(isDitherOff) };
            isDitherOff as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let testLinkTrain: u32 = unsafe { ::std::mem::transmute(testLinkTrain) };
            testLinkTrain as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let testColorChange: u32 = unsafe { ::std::mem::transmute(testColorChange) };
            testColorChange as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = "! \\ingroup          dispcontrol"]
    pub fn NvAPI_SetDisplayPort(
        hNvDisplay: NvDisplayHandle,
        outputId: NvU32,
        pCfg: *mut NV_DISPLAY_PORT_CONFIG,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NvAPI_GetHDMISupportInfo()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_HDMI_SUPPORT_INFO_V1 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Revision number of the EDID 861 extension"]
    pub EDID861ExtRev: NvU32,
}
#[test]
fn bindgen_test_layout__NV_HDMI_SUPPORT_INFO_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_HDMI_SUPPORT_INFO_V1>(),
        12usize,
        concat!("Size of: ", stringify!(_NV_HDMI_SUPPORT_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDMI_SUPPORT_INFO_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_HDMI_SUPPORT_INFO_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDMI_SUPPORT_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDMI_SUPPORT_INFO_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_EDID861ExtRev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDMI_SUPPORT_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).EDID861ExtRev) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDMI_SUPPORT_INFO_V1),
                "::",
                stringify!(EDID861ExtRev)
            )
        );
    }
    test_field_EDID861ExtRev();
}
impl _NV_HDMI_SUPPORT_INFO_V1 {
    #[inline]
    pub fn isGpuHDMICapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isGpuHDMICapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonUnderscanCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonUnderscanCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonBasicAudioCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonBasicAudioCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonYCbCr444Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonYCbCr444Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonYCbCr422Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonYCbCr422Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonxvYCC601Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonxvYCC601Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonxvYCC709Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonxvYCC709Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonHDMI(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonHDMI(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isGpuHDMICapable: NvU32,
        isMonUnderscanCapable: NvU32,
        isMonBasicAudioCapable: NvU32,
        isMonYCbCr444Capable: NvU32,
        isMonYCbCr422Capable: NvU32,
        isMonxvYCC601Capable: NvU32,
        isMonxvYCC709Capable: NvU32,
        isMonHDMI: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isGpuHDMICapable: u32 = unsafe { ::std::mem::transmute(isGpuHDMICapable) };
            isGpuHDMICapable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isMonUnderscanCapable: u32 =
                unsafe { ::std::mem::transmute(isMonUnderscanCapable) };
            isMonUnderscanCapable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isMonBasicAudioCapable: u32 =
                unsafe { ::std::mem::transmute(isMonBasicAudioCapable) };
            isMonBasicAudioCapable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let isMonYCbCr444Capable: u32 = unsafe { ::std::mem::transmute(isMonYCbCr444Capable) };
            isMonYCbCr444Capable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isMonYCbCr422Capable: u32 = unsafe { ::std::mem::transmute(isMonYCbCr422Capable) };
            isMonYCbCr422Capable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let isMonxvYCC601Capable: u32 = unsafe { ::std::mem::transmute(isMonxvYCC601Capable) };
            isMonxvYCC601Capable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let isMonxvYCC709Capable: u32 = unsafe { ::std::mem::transmute(isMonxvYCC709Capable) };
            isMonxvYCC709Capable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let isMonHDMI: u32 = unsafe { ::std::mem::transmute(isMonHDMI) };
            isMonHDMI as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NvAPI_GetHDMISupportInfo()."]
pub type NV_HDMI_SUPPORT_INFO_V1 = _NV_HDMI_SUPPORT_INFO_V1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_HDMI_SUPPORT_INFO_V2 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Revision number of the EDID 861 extension"]
    pub EDID861ExtRev: NvU32,
}
#[test]
fn bindgen_test_layout__NV_HDMI_SUPPORT_INFO_V2() {
    assert_eq!(
        ::std::mem::size_of::<_NV_HDMI_SUPPORT_INFO_V2>(),
        12usize,
        concat!("Size of: ", stringify!(_NV_HDMI_SUPPORT_INFO_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDMI_SUPPORT_INFO_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_HDMI_SUPPORT_INFO_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDMI_SUPPORT_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDMI_SUPPORT_INFO_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_EDID861ExtRev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDMI_SUPPORT_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).EDID861ExtRev) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDMI_SUPPORT_INFO_V2),
                "::",
                stringify!(EDID861ExtRev)
            )
        );
    }
    test_field_EDID861ExtRev();
}
impl _NV_HDMI_SUPPORT_INFO_V2 {
    #[inline]
    pub fn isGpuHDMICapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isGpuHDMICapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonUnderscanCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonUnderscanCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonBasicAudioCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonBasicAudioCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonYCbCr444Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonYCbCr444Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonYCbCr422Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonYCbCr422Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonxvYCC601Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonxvYCC601Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonxvYCC709Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonxvYCC709Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonHDMI(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonHDMI(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonsYCC601Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonsYCC601Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonAdobeYCC601Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonAdobeYCC601Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonAdobeRGBCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonAdobeRGBCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isGpuHDMICapable: NvU32,
        isMonUnderscanCapable: NvU32,
        isMonBasicAudioCapable: NvU32,
        isMonYCbCr444Capable: NvU32,
        isMonYCbCr422Capable: NvU32,
        isMonxvYCC601Capable: NvU32,
        isMonxvYCC709Capable: NvU32,
        isMonHDMI: NvU32,
        isMonsYCC601Capable: NvU32,
        isMonAdobeYCC601Capable: NvU32,
        isMonAdobeRGBCapable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isGpuHDMICapable: u32 = unsafe { ::std::mem::transmute(isGpuHDMICapable) };
            isGpuHDMICapable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isMonUnderscanCapable: u32 =
                unsafe { ::std::mem::transmute(isMonUnderscanCapable) };
            isMonUnderscanCapable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isMonBasicAudioCapable: u32 =
                unsafe { ::std::mem::transmute(isMonBasicAudioCapable) };
            isMonBasicAudioCapable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let isMonYCbCr444Capable: u32 = unsafe { ::std::mem::transmute(isMonYCbCr444Capable) };
            isMonYCbCr444Capable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isMonYCbCr422Capable: u32 = unsafe { ::std::mem::transmute(isMonYCbCr422Capable) };
            isMonYCbCr422Capable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let isMonxvYCC601Capable: u32 = unsafe { ::std::mem::transmute(isMonxvYCC601Capable) };
            isMonxvYCC601Capable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let isMonxvYCC709Capable: u32 = unsafe { ::std::mem::transmute(isMonxvYCC709Capable) };
            isMonxvYCC709Capable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let isMonHDMI: u32 = unsafe { ::std::mem::transmute(isMonHDMI) };
            isMonHDMI as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let isMonsYCC601Capable: u32 = unsafe { ::std::mem::transmute(isMonsYCC601Capable) };
            isMonsYCC601Capable as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let isMonAdobeYCC601Capable: u32 =
                unsafe { ::std::mem::transmute(isMonAdobeYCC601Capable) };
            isMonAdobeYCC601Capable as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let isMonAdobeRGBCapable: u32 = unsafe { ::std::mem::transmute(isMonAdobeRGBCapable) };
            isMonAdobeRGBCapable as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_HDMI_SUPPORT_INFO_V2 = _NV_HDMI_SUPPORT_INFO_V2;
pub type NV_HDMI_SUPPORT_INFO = NV_HDMI_SUPPORT_INFO_V2;
extern "C" {
    #[doc = "! \\ingroup dispcontrol"]
    pub fn NvAPI_GetHDMISupportInfo(
        hNvDisplay: NvDisplayHandle,
        outputId: NvU32,
        pInfo: *mut NV_HDMI_SUPPORT_INFO,
    ) -> NvAPI_Status;
}
#[doc = "!< Returns the fields in the infoframe with values set by the manufacturer - NVIDIA/OEM."]
pub const NV_INFOFRAME_CMD_NV_INFOFRAME_CMD_GET_DEFAULT: NV_INFOFRAME_CMD = 0;
#[doc = "!< Sets the fields in the infoframe to auto, and infoframe to the default infoframe for use in a set."]
pub const NV_INFOFRAME_CMD_NV_INFOFRAME_CMD_RESET: NV_INFOFRAME_CMD = 1;
#[doc = "!< Get the current infoframe state."]
pub const NV_INFOFRAME_CMD_NV_INFOFRAME_CMD_GET: NV_INFOFRAME_CMD = 2;
#[doc = "!< Set the current infoframe state (flushed to the monitor), the values are one time and do not persist."]
pub const NV_INFOFRAME_CMD_NV_INFOFRAME_CMD_SET: NV_INFOFRAME_CMD = 3;
#[doc = "!< Get the override infoframe state, non-override fields will be set to value = AUTO, overridden fields will have the current override values."]
pub const NV_INFOFRAME_CMD_NV_INFOFRAME_CMD_GET_OVERRIDE: NV_INFOFRAME_CMD = 4;
#[doc = "!< Set the override infoframe state, non-override fields will be set to value = AUTO, other values indicate override; persist across modeset/reboot"]
pub const NV_INFOFRAME_CMD_NV_INFOFRAME_CMD_SET_OVERRIDE: NV_INFOFRAME_CMD = 5;
#[doc = "!< get properties associated with infoframe (each of the infoframe type will have properties)"]
pub const NV_INFOFRAME_CMD_NV_INFOFRAME_CMD_GET_PROPERTY: NV_INFOFRAME_CMD = 6;
#[doc = "!< set properties associated with infoframe"]
pub const NV_INFOFRAME_CMD_NV_INFOFRAME_CMD_SET_PROPERTY: NV_INFOFRAME_CMD = 7;
#[doc = "! \\ingroup dispcontrol"]
pub type NV_INFOFRAME_CMD = ::std::os::raw::c_int;
#[doc = "!< Driver determines whether to send infoframes."]
pub const NV_INFOFRAME_PROPERTY_MODE_NV_INFOFRAME_PROPERTY_MODE_AUTO: NV_INFOFRAME_PROPERTY_MODE =
    0;
#[doc = "!< Driver always sends infoframe."]
pub const NV_INFOFRAME_PROPERTY_MODE_NV_INFOFRAME_PROPERTY_MODE_ENABLE: NV_INFOFRAME_PROPERTY_MODE =
    1;
#[doc = "!< Driver never sends infoframe."]
pub const NV_INFOFRAME_PROPERTY_MODE_NV_INFOFRAME_PROPERTY_MODE_DISABLE:
    NV_INFOFRAME_PROPERTY_MODE = 2;
#[doc = "!< Driver only sends infoframe when client requests it via infoframe escape call."]
pub const NV_INFOFRAME_PROPERTY_MODE_NV_INFOFRAME_PROPERTY_MODE_ALLOW_OVERRIDE:
    NV_INFOFRAME_PROPERTY_MODE = 3;
pub type NV_INFOFRAME_PROPERTY_MODE = ::std::os::raw::c_int;
pub const NV_INFOFRAME_PROPERTY_BLACKLIST_NV_INFOFRAME_PROPERTY_BLACKLIST_FALSE:
    NV_INFOFRAME_PROPERTY_BLACKLIST = 0;
pub const NV_INFOFRAME_PROPERTY_BLACKLIST_NV_INFOFRAME_PROPERTY_BLACKLIST_TRUE:
    NV_INFOFRAME_PROPERTY_BLACKLIST = 1;
#[doc = "! Returns whether the current monitor is in blacklist or force this monitor to be in blacklist."]
pub type NV_INFOFRAME_PROPERTY_BLACKLIST = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_INFOFRAME_PROPERTY {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_NV_INFOFRAME_PROPERTY() {
    assert_eq!(
        ::std::mem::size_of::<NV_INFOFRAME_PROPERTY>(),
        4usize,
        concat!("Size of: ", stringify!(NV_INFOFRAME_PROPERTY))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_INFOFRAME_PROPERTY>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_INFOFRAME_PROPERTY))
    );
}
impl NV_INFOFRAME_PROPERTY {
    #[inline]
    pub fn mode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn blackList(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_blackList(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn length(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_length(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mode: NvU32,
        blackList: NvU32,
        reserved: NvU32,
        version: NvU32,
        length: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let mode: u32 = unsafe { ::std::mem::transmute(mode) };
            mode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let blackList: u32 = unsafe { ::std::mem::transmute(blackList) };
            blackList as u64
        });
        __bindgen_bitfield_unit.set(6usize, 10u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let length: u32 = unsafe { ::std::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_NODATA:
    NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO = 0;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_OVERSCAN:
    NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO = 1;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_UNDERSCAN:
    NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO = 2;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_FUTURE:
    NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO = 3;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_AUTO:
    NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO = 7;
#[doc = "! Byte1 related"]
pub type NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_NOT_PRESENT:
    NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA = 0;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_VERTICAL_PRESENT : NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_HORIZONTAL_PRESENT : NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_BOTH_PRESENT:
    NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA = 3;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_AUTO:
    NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA = 7;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO_NV_INFOFRAME_FIELD_VALUE_AVI_AFI_ABSENT:
    NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO = 0;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO_NV_INFOFRAME_FIELD_VALUE_AVI_AFI_PRESENT:
    NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO = 1;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO_NV_INFOFRAME_FIELD_VALUE_AVI_AFI_AUTO:
    NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO = 3;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_RGB:
    NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT = 0;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_YCbCr422 : NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_YCbCr444 : NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_FUTURE : NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_AUTO:
    NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT = 7;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_F17_NV_INFOFRAME_FIELD_VALUE_AVI_F17_FALSE:
    NV_INFOFRAME_FIELD_VALUE_AVI_F17 = 0;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_F17_NV_INFOFRAME_FIELD_VALUE_AVI_F17_TRUE:
    NV_INFOFRAME_FIELD_VALUE_AVI_F17 = 1;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_F17_NV_INFOFRAME_FIELD_VALUE_AVI_F17_AUTO:
    NV_INFOFRAME_FIELD_VALUE_AVI_F17 = 3;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_F17 = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NO_AFD : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE01 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE02 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE03 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_LETTERBOX_GT16x9 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 4 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE05 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 5 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE06 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 6 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE07 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 7 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_EQUAL_CODEDFRAME : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 8 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_CENTER_4x3 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 9 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_CENTER_16x9 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 10 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_CENTER_14x9 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 11 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE12 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 12 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_4x3_ON_14x9 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 13 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_16x9_ON_14x9 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 14 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_16x9_ON_4x3 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 15 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_AUTO : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 31 ;
#[doc = "! Byte2 related"]
pub type NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_NO_DATA : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_4x3 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_16x9 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_FUTURE : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_AUTO : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME = 7 ;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_NO_DATA : NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_SMPTE_170M : NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_ITUR_BT709 : NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_USE_EXTENDED_COLORIMETRY : NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_AUTO:
    NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY = 7;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_NO_DATA : NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_HORIZONTAL : NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_VERTICAL : NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_BOTH : NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_AUTO : NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING = 7 ;
#[doc = "! Byte 3 related"]
pub type NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_DEFAULT : NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_LIMITED_RANGE : NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_FULL_RANGE : NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_RESERVED : NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_AUTO : NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION = 7 ;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_XVYCC601 : NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_XVYCC709 : NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_SYCC601 : NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_ADOBEYCC601 : NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_ADOBERGB : NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY = 4 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_RESERVED05 : NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY = 5 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_RESERVED06 : NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY = 6 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_RESERVED07 : NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY = 7 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_AUTO : NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY = 15 ;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ITC_NV_INFOFRAME_FIELD_VALUE_AVI_ITC_VIDEO_CONTENT:
    NV_INFOFRAME_FIELD_VALUE_AVI_ITC = 0;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ITC_NV_INFOFRAME_FIELD_VALUE_AVI_ITC_ITCONTENT:
    NV_INFOFRAME_FIELD_VALUE_AVI_ITC = 1;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ITC_NV_INFOFRAME_FIELD_VALUE_AVI_ITC_AUTO:
    NV_INFOFRAME_FIELD_VALUE_AVI_ITC = 3;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_ITC = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NONE : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X02 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X03 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X04 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X05 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 4 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X06 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 5 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X07 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 6 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X08 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 7 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X09 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 8 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X10 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 9 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED10 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 10 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED11 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 11 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED12 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 12 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED13 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 13 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED14 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 14 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED15 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 15 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_AUTO : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 31 ;
#[doc = "! Byte 4 related"]
pub type NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_GRAPHICS : NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_PHOTO : NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_CINEMA : NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_GAME:
    NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE = 3;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_AUTO:
    NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE = 7;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_LIMITED_RANGE : NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_FULL_RANGE : NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_RESERVED02 : NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_RESERVED03 : NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_AUTO : NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION = 7 ;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION = ::std::os::raw::c_int;
#[doc = "! Adding an Auto bit to each field"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_INFOFRAME_VIDEO {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 23usize]>,
}
#[test]
fn bindgen_test_layout_NV_INFOFRAME_VIDEO() {
    assert_eq!(
        ::std::mem::size_of::<NV_INFOFRAME_VIDEO>(),
        24usize,
        concat!("Size of: ", stringify!(NV_INFOFRAME_VIDEO))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_INFOFRAME_VIDEO>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_INFOFRAME_VIDEO))
    );
}
impl NV_INFOFRAME_VIDEO {
    #[inline]
    pub fn vic(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vic(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn pixelRepeat(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_pixelRepeat(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn colorSpace(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_colorSpace(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn colorimetry(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_colorimetry(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn extendedColorimetry(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_extendedColorimetry(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rgbQuantizationRange(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rgbQuantizationRange(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn yccQuantizationRange(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_yccQuantizationRange(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn itContent(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_itContent(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn contentTypes(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_contentTypes(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn scanInfo(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(35usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_scanInfo(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(35usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn activeFormatInfoPresent(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_activeFormatInfoPresent(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn activeFormatAspectRatio(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_activeFormatAspectRatio(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn picAspectRatio(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(45usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_picAspectRatio(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(45usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn nonuniformScaling(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_nonuniformScaling(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn barInfo(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_barInfo(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn top_bar(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_top_bar(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn bottom_bar(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_bottom_bar(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn left_bar(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(128usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_left_bar(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(128usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn right_bar(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(160usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_right_bar(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(160usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn Future17(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(177usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Future17(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(177usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Future47(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(179usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Future47(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(179usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vic: NvU32,
        pixelRepeat: NvU32,
        colorSpace: NvU32,
        colorimetry: NvU32,
        extendedColorimetry: NvU32,
        rgbQuantizationRange: NvU32,
        yccQuantizationRange: NvU32,
        itContent: NvU32,
        contentTypes: NvU32,
        scanInfo: NvU32,
        activeFormatInfoPresent: NvU32,
        activeFormatAspectRatio: NvU32,
        picAspectRatio: NvU32,
        nonuniformScaling: NvU32,
        barInfo: NvU32,
        top_bar: NvU32,
        bottom_bar: NvU32,
        left_bar: NvU32,
        right_bar: NvU32,
        Future17: NvU32,
        Future47: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 23usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 23usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vic: u32 = unsafe { ::std::mem::transmute(vic) };
            vic as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let pixelRepeat: u32 = unsafe { ::std::mem::transmute(pixelRepeat) };
            pixelRepeat as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let colorSpace: u32 = unsafe { ::std::mem::transmute(colorSpace) };
            colorSpace as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let colorimetry: u32 = unsafe { ::std::mem::transmute(colorimetry) };
            colorimetry as u64
        });
        __bindgen_bitfield_unit.set(19usize, 4u8, {
            let extendedColorimetry: u32 = unsafe { ::std::mem::transmute(extendedColorimetry) };
            extendedColorimetry as u64
        });
        __bindgen_bitfield_unit.set(23usize, 3u8, {
            let rgbQuantizationRange: u32 = unsafe { ::std::mem::transmute(rgbQuantizationRange) };
            rgbQuantizationRange as u64
        });
        __bindgen_bitfield_unit.set(26usize, 3u8, {
            let yccQuantizationRange: u32 = unsafe { ::std::mem::transmute(yccQuantizationRange) };
            yccQuantizationRange as u64
        });
        __bindgen_bitfield_unit.set(29usize, 2u8, {
            let itContent: u32 = unsafe { ::std::mem::transmute(itContent) };
            itContent as u64
        });
        __bindgen_bitfield_unit.set(32usize, 3u8, {
            let contentTypes: u32 = unsafe { ::std::mem::transmute(contentTypes) };
            contentTypes as u64
        });
        __bindgen_bitfield_unit.set(35usize, 3u8, {
            let scanInfo: u32 = unsafe { ::std::mem::transmute(scanInfo) };
            scanInfo as u64
        });
        __bindgen_bitfield_unit.set(38usize, 2u8, {
            let activeFormatInfoPresent: u32 =
                unsafe { ::std::mem::transmute(activeFormatInfoPresent) };
            activeFormatInfoPresent as u64
        });
        __bindgen_bitfield_unit.set(40usize, 5u8, {
            let activeFormatAspectRatio: u32 =
                unsafe { ::std::mem::transmute(activeFormatAspectRatio) };
            activeFormatAspectRatio as u64
        });
        __bindgen_bitfield_unit.set(45usize, 3u8, {
            let picAspectRatio: u32 = unsafe { ::std::mem::transmute(picAspectRatio) };
            picAspectRatio as u64
        });
        __bindgen_bitfield_unit.set(48usize, 3u8, {
            let nonuniformScaling: u32 = unsafe { ::std::mem::transmute(nonuniformScaling) };
            nonuniformScaling as u64
        });
        __bindgen_bitfield_unit.set(51usize, 3u8, {
            let barInfo: u32 = unsafe { ::std::mem::transmute(barInfo) };
            barInfo as u64
        });
        __bindgen_bitfield_unit.set(64usize, 17u8, {
            let top_bar: u32 = unsafe { ::std::mem::transmute(top_bar) };
            top_bar as u64
        });
        __bindgen_bitfield_unit.set(96usize, 17u8, {
            let bottom_bar: u32 = unsafe { ::std::mem::transmute(bottom_bar) };
            bottom_bar as u64
        });
        __bindgen_bitfield_unit.set(128usize, 17u8, {
            let left_bar: u32 = unsafe { ::std::mem::transmute(left_bar) };
            left_bar as u64
        });
        __bindgen_bitfield_unit.set(160usize, 17u8, {
            let right_bar: u32 = unsafe { ::std::mem::transmute(right_bar) };
            right_bar as u64
        });
        __bindgen_bitfield_unit.set(177usize, 2u8, {
            let Future17: u32 = unsafe { ::std::mem::transmute(Future17) };
            Future17 as u64
        });
        __bindgen_bitfield_unit.set(179usize, 2u8, {
            let Future47: u32 = unsafe { ::std::mem::transmute(Future47) };
            Future47 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_IN_HEADER : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_2 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_3 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_4 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_5 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT = 4 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_6 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT = 5 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_7 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT = 6 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_8 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT = 7 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_AUTO : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT = 15 ;
#[doc = "! Byte 1 related"]
pub type NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_IN_HEADER : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_PCM : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_AC3 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MPEG1 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MP3 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 4 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MPEG2 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 5 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_AACLC : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 6 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DTS : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 7 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_ATRAC : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 8 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DSD : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 9 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_EAC3 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 10 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DTSHD : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 11 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MLP : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 12 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DST : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 13 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_WMAPRO : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 14 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_USE_CODING_EXTENSION_TYPE : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 15 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_AUTO : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 31 ;
pub type NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_IN_HEADER : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_16BITS : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_20BITS : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_24BITS : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_AUTO : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE = 7 ;
#[doc = "! Byte 2 related"]
pub type NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_IN_HEADER : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_32000HZ : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_44100HZ : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_48000HZ : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_88200KHZ : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY = 4 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_96000KHZ : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY = 5 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_176400KHZ : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY = 6 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_192000KHZ : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY = 7 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_AUTO : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY = 15 ;
pub type NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_USE_CODING_TYPE : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_HEAAC : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_HEAACV2 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_MPEGSURROUND : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE04 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 4 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE05 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 5 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE06 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 6 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE07 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 7 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE08 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 8 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE09 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 9 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE10 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 10 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE11 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 11 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE12 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 12 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE13 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 13 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE14 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 14 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE15 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 15 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE16 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 16 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE17 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 17 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE18 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 18 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE19 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 19 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE20 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 20 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE21 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 21 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE22 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 22 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE23 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 23 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE24 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 24 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE25 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 25 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE26 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 26 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE27 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 27 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE28 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 28 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE29 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 29 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE30 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 30 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE31 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 31 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_AUTO : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 63 ;
#[doc = "! Byte 3 related"]
pub type NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_X_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_X_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_X_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 4 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_X_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 5 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 6 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 7 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_X_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 8 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_X_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 9 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 10 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 11 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_X_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 12 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_X_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 13 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 14 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 15 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_X_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 16 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_X_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 17 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 18 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 19 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_X_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 20 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_X_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 21 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 22 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 23 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_X_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 24 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_X_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 25 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 26 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 27 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_X_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 28 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_X_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 29 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 30 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 31 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_FCH_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 32 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_FCH_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 33 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_X_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 34 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_X_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 35 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_X_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 36 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_X_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 37 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_X_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 38 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_X_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 39 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_RC_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 40 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_RC_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 41 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FCH_RC_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 42 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FCH_RC_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 43 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_FCH_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 44 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_FCH_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 45 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 46 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 47 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 48 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 49 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_AUTO : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 511 ;
#[doc = "! Byte 4 related"]
pub type NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_NO_DATA : NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_0DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_PLUS10DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_RESERVED03 : NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_AUTO : NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL = 7 ;
#[doc = "! Byte 5 related"]
pub type NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_0DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_1DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_2DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_3DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_4DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 4 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_5DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 5 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_6DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 6 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_7DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 7 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_8DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 8 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_9DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 9 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_10DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 10 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_11DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 11 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_12DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 12 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_13DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 13 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_14DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 14 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_15DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 15 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_AUTO : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 31 ;
pub type NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_PERMITTED : NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_PROHIBITED : NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_AUTO:
    NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX = 3;
pub type NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_INFOFRAME_AUDIO {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 14usize]>,
    pub __bindgen_padding_0: u16,
}
#[test]
fn bindgen_test_layout_NV_INFOFRAME_AUDIO() {
    assert_eq!(
        ::std::mem::size_of::<NV_INFOFRAME_AUDIO>(),
        16usize,
        concat!("Size of: ", stringify!(NV_INFOFRAME_AUDIO))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_INFOFRAME_AUDIO>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_INFOFRAME_AUDIO))
    );
}
impl NV_INFOFRAME_AUDIO {
    #[inline]
    pub fn codingType(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_codingType(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn codingExtensionType(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_codingExtensionType(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn sampleSize(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_sampleSize(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn sampleRate(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_sampleRate(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn channelCount(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_channelCount(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn speakerPlacement(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_speakerPlacement(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn downmixInhibit(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_downmixInhibit(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lfePlaybackLevel(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_lfePlaybackLevel(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn levelShift(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_levelShift(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Future12(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(42usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Future12(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(42usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Future2x(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Future2x(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Future3x(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Future3x(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Future52(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Future52(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Future6(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Future6(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn Future7(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Future7(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn Future8(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(73usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Future8(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(73usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn Future9(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(82usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Future9(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(82usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn Future10(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Future10(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        codingType: NvU32,
        codingExtensionType: NvU32,
        sampleSize: NvU32,
        sampleRate: NvU32,
        channelCount: NvU32,
        speakerPlacement: NvU32,
        downmixInhibit: NvU32,
        lfePlaybackLevel: NvU32,
        levelShift: NvU32,
        Future12: NvU32,
        Future2x: NvU32,
        Future3x: NvU32,
        Future52: NvU32,
        Future6: NvU32,
        Future7: NvU32,
        Future8: NvU32,
        Future9: NvU32,
        Future10: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 14usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 14usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let codingType: u32 = unsafe { ::std::mem::transmute(codingType) };
            codingType as u64
        });
        __bindgen_bitfield_unit.set(5usize, 6u8, {
            let codingExtensionType: u32 = unsafe { ::std::mem::transmute(codingExtensionType) };
            codingExtensionType as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let sampleSize: u32 = unsafe { ::std::mem::transmute(sampleSize) };
            sampleSize as u64
        });
        __bindgen_bitfield_unit.set(14usize, 4u8, {
            let sampleRate: u32 = unsafe { ::std::mem::transmute(sampleRate) };
            sampleRate as u64
        });
        __bindgen_bitfield_unit.set(18usize, 4u8, {
            let channelCount: u32 = unsafe { ::std::mem::transmute(channelCount) };
            channelCount as u64
        });
        __bindgen_bitfield_unit.set(22usize, 9u8, {
            let speakerPlacement: u32 = unsafe { ::std::mem::transmute(speakerPlacement) };
            speakerPlacement as u64
        });
        __bindgen_bitfield_unit.set(32usize, 2u8, {
            let downmixInhibit: u32 = unsafe { ::std::mem::transmute(downmixInhibit) };
            downmixInhibit as u64
        });
        __bindgen_bitfield_unit.set(34usize, 3u8, {
            let lfePlaybackLevel: u32 = unsafe { ::std::mem::transmute(lfePlaybackLevel) };
            lfePlaybackLevel as u64
        });
        __bindgen_bitfield_unit.set(37usize, 5u8, {
            let levelShift: u32 = unsafe { ::std::mem::transmute(levelShift) };
            levelShift as u64
        });
        __bindgen_bitfield_unit.set(42usize, 2u8, {
            let Future12: u32 = unsafe { ::std::mem::transmute(Future12) };
            Future12 as u64
        });
        __bindgen_bitfield_unit.set(44usize, 4u8, {
            let Future2x: u32 = unsafe { ::std::mem::transmute(Future2x) };
            Future2x as u64
        });
        __bindgen_bitfield_unit.set(48usize, 4u8, {
            let Future3x: u32 = unsafe { ::std::mem::transmute(Future3x) };
            Future3x as u64
        });
        __bindgen_bitfield_unit.set(52usize, 2u8, {
            let Future52: u32 = unsafe { ::std::mem::transmute(Future52) };
            Future52 as u64
        });
        __bindgen_bitfield_unit.set(54usize, 9u8, {
            let Future6: u32 = unsafe { ::std::mem::transmute(Future6) };
            Future6 as u64
        });
        __bindgen_bitfield_unit.set(64usize, 9u8, {
            let Future7: u32 = unsafe { ::std::mem::transmute(Future7) };
            Future7 as u64
        });
        __bindgen_bitfield_unit.set(73usize, 9u8, {
            let Future8: u32 = unsafe { ::std::mem::transmute(Future8) };
            Future8 as u64
        });
        __bindgen_bitfield_unit.set(82usize, 9u8, {
            let Future9: u32 = unsafe { ::std::mem::transmute(Future9) };
            Future9 as u64
        });
        __bindgen_bitfield_unit.set(96usize, 9u8, {
            let Future10: u32 = unsafe { ::std::mem::transmute(Future10) };
            Future10 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_INFOFRAME_DATA {
    #[doc = "!< version of this structure"]
    pub version: NvU32,
    #[doc = "!< size of this structure"]
    pub size: NvU16,
    #[doc = "!< The actions to perform from NV_INFOFRAME_CMD"]
    pub cmd: NvU8,
    #[doc = "!< type of infoframe"]
    pub type_: NvU8,
    pub infoframe: NV_INFOFRAME_DATA__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NV_INFOFRAME_DATA__bindgen_ty_1 {
    #[doc = "!< This is NVIDIA-specific and corresponds to the property cmds and associated infoframe."]
    pub property: NV_INFOFRAME_PROPERTY,
    pub audio: NV_INFOFRAME_AUDIO,
    pub video: NV_INFOFRAME_VIDEO,
}
#[test]
fn bindgen_test_layout_NV_INFOFRAME_DATA__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_INFOFRAME_DATA__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(NV_INFOFRAME_DATA__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_INFOFRAME_DATA__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_INFOFRAME_DATA__bindgen_ty_1))
    );
    fn test_field_property() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_INFOFRAME_DATA__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).property) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_INFOFRAME_DATA__bindgen_ty_1),
                "::",
                stringify!(property)
            )
        );
    }
    test_field_property();
    fn test_field_audio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_INFOFRAME_DATA__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).audio) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_INFOFRAME_DATA__bindgen_ty_1),
                "::",
                stringify!(audio)
            )
        );
    }
    test_field_audio();
    fn test_field_video() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_INFOFRAME_DATA__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).video) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_INFOFRAME_DATA__bindgen_ty_1),
                "::",
                stringify!(video)
            )
        );
    }
    test_field_video();
}
impl Default for NV_INFOFRAME_DATA__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NV_INFOFRAME_DATA() {
    assert_eq!(
        ::std::mem::size_of::<NV_INFOFRAME_DATA>(),
        32usize,
        concat!("Size of: ", stringify!(NV_INFOFRAME_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_INFOFRAME_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_INFOFRAME_DATA))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_INFOFRAME_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_INFOFRAME_DATA),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_INFOFRAME_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_INFOFRAME_DATA),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_INFOFRAME_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_INFOFRAME_DATA),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_INFOFRAME_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            7usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_INFOFRAME_DATA),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_infoframe() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_INFOFRAME_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).infoframe) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_INFOFRAME_DATA),
                "::",
                stringify!(infoframe)
            )
        );
    }
    test_field_infoframe();
}
impl Default for NV_INFOFRAME_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API controls the InfoFrame values."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]     displayId         Monitor Identifier"]
    #[doc = "! \\param [in,out] pInfoframeData    Contains data corresponding to InfoFrame"]
    #[doc = "!"]
    #[doc = "! \\return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with"]
    #[doc = "!            specific meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_Disp_InfoFrameControl(
        displayId: NvU32,
        pInfoframeData: *mut NV_INFOFRAME_DATA,
    ) -> NvAPI_Status;
}
pub const NV_COLOR_CMD_NV_COLOR_CMD_GET: NV_COLOR_CMD = 1;
pub const NV_COLOR_CMD_NV_COLOR_CMD_SET: NV_COLOR_CMD = 2;
pub const NV_COLOR_CMD_NV_COLOR_CMD_IS_SUPPORTED_COLOR: NV_COLOR_CMD = 3;
pub const NV_COLOR_CMD_NV_COLOR_CMD_GET_DEFAULT: NV_COLOR_CMD = 4;
#[doc = ""]
pub type NV_COLOR_CMD = ::std::os::raw::c_int;
pub const NV_COLOR_FORMAT_NV_COLOR_FORMAT_RGB: NV_COLOR_FORMAT = 0;
pub const NV_COLOR_FORMAT_NV_COLOR_FORMAT_YUV422: NV_COLOR_FORMAT = 1;
pub const NV_COLOR_FORMAT_NV_COLOR_FORMAT_YUV444: NV_COLOR_FORMAT = 2;
pub const NV_COLOR_FORMAT_NV_COLOR_FORMAT_YUV420: NV_COLOR_FORMAT = 3;
pub const NV_COLOR_FORMAT_NV_COLOR_FORMAT_DEFAULT: NV_COLOR_FORMAT = 254;
pub const NV_COLOR_FORMAT_NV_COLOR_FORMAT_AUTO: NV_COLOR_FORMAT = 255;
#[doc = "!  See Table 14 of CEA-861E.  Not all of this is supported by the GPU."]
pub type NV_COLOR_FORMAT = ::std::os::raw::c_int;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_RGB: NV_COLOR_COLORIMETRY = 0;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_YCC601: NV_COLOR_COLORIMETRY = 1;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_YCC709: NV_COLOR_COLORIMETRY = 2;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_XVYCC601: NV_COLOR_COLORIMETRY = 3;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_XVYCC709: NV_COLOR_COLORIMETRY = 4;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_SYCC601: NV_COLOR_COLORIMETRY = 5;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_ADOBEYCC601: NV_COLOR_COLORIMETRY = 6;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_ADOBERGB: NV_COLOR_COLORIMETRY = 7;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_BT2020RGB: NV_COLOR_COLORIMETRY = 8;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_BT2020YCC: NV_COLOR_COLORIMETRY = 9;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_BT2020cYCC: NV_COLOR_COLORIMETRY = 10;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_DEFAULT: NV_COLOR_COLORIMETRY = 254;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_AUTO: NV_COLOR_COLORIMETRY = 255;
pub type NV_COLOR_COLORIMETRY = ::std::os::raw::c_int;
pub const _NV_DYNAMIC_RANGE_NV_DYNAMIC_RANGE_VESA: _NV_DYNAMIC_RANGE = 0;
pub const _NV_DYNAMIC_RANGE_NV_DYNAMIC_RANGE_CEA: _NV_DYNAMIC_RANGE = 1;
pub const _NV_DYNAMIC_RANGE_NV_DYNAMIC_RANGE_AUTO: _NV_DYNAMIC_RANGE = 255;
pub type _NV_DYNAMIC_RANGE = ::std::os::raw::c_int;
pub use self::_NV_DYNAMIC_RANGE as NV_DYNAMIC_RANGE;
pub const _NV_BPC_NV_BPC_DEFAULT: _NV_BPC = 0;
pub const _NV_BPC_NV_BPC_6: _NV_BPC = 1;
pub const _NV_BPC_NV_BPC_8: _NV_BPC = 2;
pub const _NV_BPC_NV_BPC_10: _NV_BPC = 3;
pub const _NV_BPC_NV_BPC_12: _NV_BPC = 4;
pub const _NV_BPC_NV_BPC_16: _NV_BPC = 5;
pub type _NV_BPC = ::std::os::raw::c_int;
pub use self::_NV_BPC as NV_BPC;
#[doc = "!< app/nvcpl make decision to select the desire color format"]
pub const _NV_COLOR_SELECTION_POLICY_NV_COLOR_SELECTION_POLICY_USER: _NV_COLOR_SELECTION_POLICY = 0;
#[doc = "!< driver/ OS make decision to select the best color format"]
pub const _NV_COLOR_SELECTION_POLICY_NV_COLOR_SELECTION_POLICY_BEST_QUALITY:
    _NV_COLOR_SELECTION_POLICY = 1;
pub const _NV_COLOR_SELECTION_POLICY_NV_COLOR_SELECTION_POLICY_DEFAULT: _NV_COLOR_SELECTION_POLICY =
    1;
pub const _NV_COLOR_SELECTION_POLICY_NV_COLOR_SELECTION_POLICY_UNKNOWN: _NV_COLOR_SELECTION_POLICY =
    255;
pub type _NV_COLOR_SELECTION_POLICY = ::std::os::raw::c_int;
pub use self::_NV_COLOR_SELECTION_POLICY as NV_COLOR_SELECTION_POLICY;
pub const _NV_DESKTOP_COLOR_DEPTH_NV_DESKTOP_COLOR_DEPTH_DEFAULT: _NV_DESKTOP_COLOR_DEPTH = 0;
pub const _NV_DESKTOP_COLOR_DEPTH_NV_DESKTOP_COLOR_DEPTH_8BPC: _NV_DESKTOP_COLOR_DEPTH = 1;
pub const _NV_DESKTOP_COLOR_DEPTH_NV_DESKTOP_COLOR_DEPTH_10BPC: _NV_DESKTOP_COLOR_DEPTH = 2;
pub const _NV_DESKTOP_COLOR_DEPTH_NV_DESKTOP_COLOR_DEPTH_16BPC_FLOAT: _NV_DESKTOP_COLOR_DEPTH = 3;
pub const _NV_DESKTOP_COLOR_DEPTH_NV_DESKTOP_COLOR_DEPTH_16BPC_FLOAT_WCG: _NV_DESKTOP_COLOR_DEPTH =
    4;
pub const _NV_DESKTOP_COLOR_DEPTH_NV_DESKTOP_COLOR_DEPTH_16BPC_FLOAT_HDR: _NV_DESKTOP_COLOR_DEPTH =
    5;
pub const _NV_DESKTOP_COLOR_DEPTH_NV_DESKTOP_COLOR_DEPTH_MAX_VALUE: _NV_DESKTOP_COLOR_DEPTH = 5;
pub type _NV_DESKTOP_COLOR_DEPTH = ::std::os::raw::c_int;
pub use self::_NV_DESKTOP_COLOR_DEPTH as NV_DESKTOP_COLOR_DEPTH;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_COLOR_DATA_V1 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Size of this structure"]
    pub size: NvU16,
    pub cmd: NvU8,
    pub data: _NV_COLOR_DATA_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_COLOR_DATA_V1__bindgen_ty_1 {
    #[doc = "!< One of NV_COLOR_FORMAT enum values."]
    pub colorFormat: NvU8,
    #[doc = "!< One of NV_COLOR_COLORIMETRY enum values."]
    pub colorimetry: NvU8,
}
#[test]
fn bindgen_test_layout__NV_COLOR_DATA_V1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_COLOR_DATA_V1__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(_NV_COLOR_DATA_V1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COLOR_DATA_V1__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(_NV_COLOR_DATA_V1__bindgen_ty_1))
    );
    fn test_field_colorFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V1__bindgen_ty_1),
                "::",
                stringify!(colorFormat)
            )
        );
    }
    test_field_colorFormat();
    fn test_field_colorimetry() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorimetry) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V1__bindgen_ty_1),
                "::",
                stringify!(colorimetry)
            )
        );
    }
    test_field_colorimetry();
}
#[test]
fn bindgen_test_layout__NV_COLOR_DATA_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_COLOR_DATA_V1>(),
        12usize,
        concat!("Size of: ", stringify!(_NV_COLOR_DATA_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COLOR_DATA_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_COLOR_DATA_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V1),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V1),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            7usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V1),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
pub type NV_COLOR_DATA_V1 = _NV_COLOR_DATA_V1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_COLOR_DATA_V2 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Size of this structure"]
    pub size: NvU16,
    pub cmd: NvU8,
    pub data: _NV_COLOR_DATA_V2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_COLOR_DATA_V2__bindgen_ty_1 {
    #[doc = "!< One of NV_COLOR_FORMAT enum values."]
    pub colorFormat: NvU8,
    #[doc = "!< One of NV_COLOR_COLORIMETRY enum values."]
    pub colorimetry: NvU8,
    #[doc = "!< One of NV_DYNAMIC_RANGE enum values."]
    pub dynamicRange: NvU8,
}
#[test]
fn bindgen_test_layout__NV_COLOR_DATA_V2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_COLOR_DATA_V2__bindgen_ty_1>(),
        3usize,
        concat!("Size of: ", stringify!(_NV_COLOR_DATA_V2__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COLOR_DATA_V2__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(_NV_COLOR_DATA_V2__bindgen_ty_1))
    );
    fn test_field_colorFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V2__bindgen_ty_1),
                "::",
                stringify!(colorFormat)
            )
        );
    }
    test_field_colorFormat();
    fn test_field_colorimetry() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorimetry) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V2__bindgen_ty_1),
                "::",
                stringify!(colorimetry)
            )
        );
    }
    test_field_colorimetry();
    fn test_field_dynamicRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dynamicRange) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V2__bindgen_ty_1),
                "::",
                stringify!(dynamicRange)
            )
        );
    }
    test_field_dynamicRange();
}
#[test]
fn bindgen_test_layout__NV_COLOR_DATA_V2() {
    assert_eq!(
        ::std::mem::size_of::<_NV_COLOR_DATA_V2>(),
        12usize,
        concat!("Size of: ", stringify!(_NV_COLOR_DATA_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COLOR_DATA_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_COLOR_DATA_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V2),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V2),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            7usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V2),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
pub type NV_COLOR_DATA_V2 = _NV_COLOR_DATA_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_COLOR_DATA_V3 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Size of this structure"]
    pub size: NvU16,
    pub cmd: NvU8,
    pub data: _NV_COLOR_DATA_V3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_COLOR_DATA_V3__bindgen_ty_1 {
    #[doc = "!< One of NV_COLOR_FORMAT enum values."]
    pub colorFormat: NvU8,
    #[doc = "!< One of NV_COLOR_COLORIMETRY enum values."]
    pub colorimetry: NvU8,
    #[doc = "!< One of NV_DYNAMIC_RANGE enum values."]
    pub dynamicRange: NvU8,
    #[doc = "!< One of NV_BPC enum values."]
    pub bpc: NV_BPC,
}
#[test]
fn bindgen_test_layout__NV_COLOR_DATA_V3__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_COLOR_DATA_V3__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_NV_COLOR_DATA_V3__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COLOR_DATA_V3__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_COLOR_DATA_V3__bindgen_ty_1))
    );
    fn test_field_colorFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V3__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V3__bindgen_ty_1),
                "::",
                stringify!(colorFormat)
            )
        );
    }
    test_field_colorFormat();
    fn test_field_colorimetry() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V3__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorimetry) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V3__bindgen_ty_1),
                "::",
                stringify!(colorimetry)
            )
        );
    }
    test_field_colorimetry();
    fn test_field_dynamicRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V3__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dynamicRange) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V3__bindgen_ty_1),
                "::",
                stringify!(dynamicRange)
            )
        );
    }
    test_field_dynamicRange();
    fn test_field_bpc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V3__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bpc) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V3__bindgen_ty_1),
                "::",
                stringify!(bpc)
            )
        );
    }
    test_field_bpc();
}
impl Default for _NV_COLOR_DATA_V3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__NV_COLOR_DATA_V3() {
    assert_eq!(
        ::std::mem::size_of::<_NV_COLOR_DATA_V3>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_COLOR_DATA_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COLOR_DATA_V3>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_COLOR_DATA_V3))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V3),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V3),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V3),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V3),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
impl Default for _NV_COLOR_DATA_V3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_COLOR_DATA_V3 = _NV_COLOR_DATA_V3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_COLOR_DATA_V4 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Size of this structure"]
    pub size: NvU16,
    pub cmd: NvU8,
    pub data: _NV_COLOR_DATA_V4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_COLOR_DATA_V4__bindgen_ty_1 {
    #[doc = "!< One of NV_COLOR_FORMAT enum values."]
    pub colorFormat: NvU8,
    #[doc = "!< One of NV_COLOR_COLORIMETRY enum values."]
    pub colorimetry: NvU8,
    #[doc = "!< One of NV_DYNAMIC_RANGE enum values."]
    pub dynamicRange: NvU8,
    #[doc = "!< One of NV_BPC enum values."]
    pub bpc: NV_BPC,
    #[doc = "!< One of the color selection policy"]
    pub colorSelectionPolicy: NV_COLOR_SELECTION_POLICY,
}
#[test]
fn bindgen_test_layout__NV_COLOR_DATA_V4__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_COLOR_DATA_V4__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(_NV_COLOR_DATA_V4__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COLOR_DATA_V4__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_COLOR_DATA_V4__bindgen_ty_1))
    );
    fn test_field_colorFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V4__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V4__bindgen_ty_1),
                "::",
                stringify!(colorFormat)
            )
        );
    }
    test_field_colorFormat();
    fn test_field_colorimetry() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V4__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorimetry) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V4__bindgen_ty_1),
                "::",
                stringify!(colorimetry)
            )
        );
    }
    test_field_colorimetry();
    fn test_field_dynamicRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V4__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dynamicRange) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V4__bindgen_ty_1),
                "::",
                stringify!(dynamicRange)
            )
        );
    }
    test_field_dynamicRange();
    fn test_field_bpc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V4__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bpc) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V4__bindgen_ty_1),
                "::",
                stringify!(bpc)
            )
        );
    }
    test_field_bpc();
    fn test_field_colorSelectionPolicy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V4__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorSelectionPolicy) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V4__bindgen_ty_1),
                "::",
                stringify!(colorSelectionPolicy)
            )
        );
    }
    test_field_colorSelectionPolicy();
}
impl Default for _NV_COLOR_DATA_V4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__NV_COLOR_DATA_V4() {
    assert_eq!(
        ::std::mem::size_of::<_NV_COLOR_DATA_V4>(),
        20usize,
        concat!("Size of: ", stringify!(_NV_COLOR_DATA_V4))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COLOR_DATA_V4>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_COLOR_DATA_V4))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V4),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V4),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V4),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V4),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
impl Default for _NV_COLOR_DATA_V4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_COLOR_DATA_V4 = _NV_COLOR_DATA_V4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_COLOR_DATA_V5 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Size of this structure"]
    pub size: NvU16,
    pub cmd: NvU8,
    pub data: _NV_COLOR_DATA_V5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_COLOR_DATA_V5__bindgen_ty_1 {
    #[doc = "!< One of NV_COLOR_FORMAT enum values."]
    pub colorFormat: NvU8,
    #[doc = "!< One of NV_COLOR_COLORIMETRY enum values."]
    pub colorimetry: NvU8,
    #[doc = "!< One of NV_DYNAMIC_RANGE enum values."]
    pub dynamicRange: NvU8,
    #[doc = "!< One of NV_BPC enum values."]
    pub bpc: NV_BPC,
    #[doc = "!< One of the color selection policy"]
    pub colorSelectionPolicy: NV_COLOR_SELECTION_POLICY,
    #[doc = "!< One of NV_DESKTOP_COLOR_DEPTH enum values."]
    pub depth: NV_DESKTOP_COLOR_DEPTH,
}
#[test]
fn bindgen_test_layout__NV_COLOR_DATA_V5__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_COLOR_DATA_V5__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_COLOR_DATA_V5__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COLOR_DATA_V5__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_COLOR_DATA_V5__bindgen_ty_1))
    );
    fn test_field_colorFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V5__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V5__bindgen_ty_1),
                "::",
                stringify!(colorFormat)
            )
        );
    }
    test_field_colorFormat();
    fn test_field_colorimetry() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V5__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorimetry) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V5__bindgen_ty_1),
                "::",
                stringify!(colorimetry)
            )
        );
    }
    test_field_colorimetry();
    fn test_field_dynamicRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V5__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dynamicRange) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V5__bindgen_ty_1),
                "::",
                stringify!(dynamicRange)
            )
        );
    }
    test_field_dynamicRange();
    fn test_field_bpc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V5__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bpc) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V5__bindgen_ty_1),
                "::",
                stringify!(bpc)
            )
        );
    }
    test_field_bpc();
    fn test_field_colorSelectionPolicy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V5__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorSelectionPolicy) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V5__bindgen_ty_1),
                "::",
                stringify!(colorSelectionPolicy)
            )
        );
    }
    test_field_colorSelectionPolicy();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V5__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V5__bindgen_ty_1),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
}
impl Default for _NV_COLOR_DATA_V5__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__NV_COLOR_DATA_V5() {
    assert_eq!(
        ::std::mem::size_of::<_NV_COLOR_DATA_V5>(),
        24usize,
        concat!("Size of: ", stringify!(_NV_COLOR_DATA_V5))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COLOR_DATA_V5>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_COLOR_DATA_V5))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V5),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V5),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V5),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_COLOR_DATA_V5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_COLOR_DATA_V5),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
impl Default for _NV_COLOR_DATA_V5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_COLOR_DATA_V5 = _NV_COLOR_DATA_V5;
pub type NV_COLOR_DATA = NV_COLOR_DATA_V5;
extern "C" {
    pub fn NvAPI_Disp_ColorControl(
        displayId: NvU32,
        pColorData: *mut NV_COLOR_DATA,
    ) -> NvAPI_Status;
}
#[doc = "!< Tells the type of structure used to define the Static Metadata Descriptor block."]
pub const NV_STATIC_METADATA_DESCRIPTOR_ID_NV_STATIC_METADATA_TYPE_1:
    NV_STATIC_METADATA_DESCRIPTOR_ID = 0;
#[doc = "! @}"]
pub type NV_STATIC_METADATA_DESCRIPTOR_ID = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V1 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Static Metadata Descriptor Id (0 for static metadata type 1)"]
    pub static_metadata_descriptor_id: NV_STATIC_METADATA_DESCRIPTOR_ID,
    pub display_data: _NV_HDR_CAPABILITIES_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V1__bindgen_ty_1 {
    #[doc = "!< x coordinate of color primary 0 (e.g. Red) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x0: NvU16,
    #[doc = "!< y coordinate of color primary 0 (e.g. Red) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y0: NvU16,
    #[doc = "!< x coordinate of color primary 1 (e.g. Green) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x1: NvU16,
    #[doc = "!< y coordinate of color primary 1 (e.g. Green) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y1: NvU16,
    #[doc = "!< x coordinate of color primary 2 (e.g. Blue) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x2: NvU16,
    #[doc = "!< y coordinate of color primary 2 (e.g. Blue) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y2: NvU16,
    #[doc = "!< x coordinate of white point of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayWhitePoint_x: NvU16,
    #[doc = "!< y coordinate of white point of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayWhitePoint_y: NvU16,
    #[doc = "!< Maximum display luminance = desired max luminance of HDR content ([0x0001-0xFFFF] = [1.0 - 65535.0] cd/m^2)"]
    pub desired_content_max_luminance: NvU16,
    #[doc = "!< Minimum display luminance = desired min luminance of HDR content ([0x0001-0xFFFF] = [1.0 - 6.55350] cd/m^2)"]
    pub desired_content_min_luminance: NvU16,
    #[doc = "!< Desired maximum Frame-Average Light Level (MaxFALL) of HDR content ([0x0001-0xFFFF] = [1.0 - 65535.0] cd/m^2)"]
    pub desired_content_max_frame_average_luminance: NvU16,
}
#[test]
fn bindgen_test_layout__NV_HDR_CAPABILITIES_V1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_CAPABILITIES_V1__bindgen_ty_1>(),
        22usize,
        concat!(
            "Size of: ",
            stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_CAPABILITIES_V1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1)
        )
    );
    fn test_field_displayPrimary_x0() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_x0) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_x0)
            )
        );
    }
    test_field_displayPrimary_x0();
    fn test_field_displayPrimary_y0() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_y0) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_y0)
            )
        );
    }
    test_field_displayPrimary_y0();
    fn test_field_displayPrimary_x1() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_x1) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_x1)
            )
        );
    }
    test_field_displayPrimary_x1();
    fn test_field_displayPrimary_y1() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_y1) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_y1)
            )
        );
    }
    test_field_displayPrimary_y1();
    fn test_field_displayPrimary_x2() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_x2) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_x2)
            )
        );
    }
    test_field_displayPrimary_x2();
    fn test_field_displayPrimary_y2() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_y2) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_y2)
            )
        );
    }
    test_field_displayPrimary_y2();
    fn test_field_displayWhitePoint_x() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayWhitePoint_x) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
                "::",
                stringify!(displayWhitePoint_x)
            )
        );
    }
    test_field_displayWhitePoint_x();
    fn test_field_displayWhitePoint_y() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayWhitePoint_y) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
                "::",
                stringify!(displayWhitePoint_y)
            )
        );
    }
    test_field_displayWhitePoint_y();
    fn test_field_desired_content_max_luminance() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).desired_content_max_luminance) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
                "::",
                stringify!(desired_content_max_luminance)
            )
        );
    }
    test_field_desired_content_max_luminance();
    fn test_field_desired_content_min_luminance() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).desired_content_min_luminance) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
                "::",
                stringify!(desired_content_min_luminance)
            )
        );
    }
    test_field_desired_content_min_luminance();
    fn test_field_desired_content_max_frame_average_luminance() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).desired_content_max_frame_average_luminance) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
                "::",
                stringify!(desired_content_max_frame_average_luminance)
            )
        );
    }
    test_field_desired_content_max_frame_average_luminance();
}
#[test]
fn bindgen_test_layout__NV_HDR_CAPABILITIES_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_CAPABILITIES_V1>(),
        36usize,
        concat!("Size of: ", stringify!(_NV_HDR_CAPABILITIES_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_CAPABILITIES_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_HDR_CAPABILITIES_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_static_metadata_descriptor_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).static_metadata_descriptor_id) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V1),
                "::",
                stringify!(static_metadata_descriptor_id)
            )
        );
    }
    test_field_static_metadata_descriptor_id();
    fn test_field_display_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).display_data) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V1),
                "::",
                stringify!(display_data)
            )
        );
    }
    test_field_display_data();
}
impl Default for _NV_HDR_CAPABILITIES_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_HDR_CAPABILITIES_V1 {
    #[inline]
    pub fn isST2084EotfSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isST2084EotfSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isTraditionalHdrGammaSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isTraditionalHdrGammaSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isEdrSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEdrSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn driverExpandDefaultHdrParameters(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_driverExpandDefaultHdrParameters(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isTraditionalSdrGammaSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isTraditionalSdrGammaSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isST2084EotfSupported: NvU32,
        isTraditionalHdrGammaSupported: NvU32,
        isEdrSupported: NvU32,
        driverExpandDefaultHdrParameters: NvU32,
        isTraditionalSdrGammaSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isST2084EotfSupported: u32 =
                unsafe { ::std::mem::transmute(isST2084EotfSupported) };
            isST2084EotfSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isTraditionalHdrGammaSupported: u32 =
                unsafe { ::std::mem::transmute(isTraditionalHdrGammaSupported) };
            isTraditionalHdrGammaSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isEdrSupported: u32 = unsafe { ::std::mem::transmute(isEdrSupported) };
            isEdrSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let driverExpandDefaultHdrParameters: u32 =
                unsafe { ::std::mem::transmute(driverExpandDefaultHdrParameters) };
            driverExpandDefaultHdrParameters as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isTraditionalSdrGammaSupported: u32 =
                unsafe { ::std::mem::transmute(isTraditionalSdrGammaSupported) };
            isTraditionalSdrGammaSupported as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_HDR_CAPABILITIES_V1 = _NV_HDR_CAPABILITIES_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V2 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Static Metadata Descriptor Id (0 for static metadata type 1)"]
    pub static_metadata_descriptor_id: NV_STATIC_METADATA_DESCRIPTOR_ID,
    pub display_data: _NV_HDR_CAPABILITIES_V2__bindgen_ty_1,
    pub dv_static_metadata: _NV_HDR_CAPABILITIES_V2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V2__bindgen_ty_1 {
    #[doc = "!< x coordinate of color primary 0 (e.g. Red) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x0: NvU16,
    #[doc = "!< y coordinate of color primary 0 (e.g. Red) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y0: NvU16,
    #[doc = "!< x coordinate of color primary 1 (e.g. Green) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x1: NvU16,
    #[doc = "!< y coordinate of color primary 1 (e.g. Green) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y1: NvU16,
    #[doc = "!< x coordinate of color primary 2 (e.g. Blue) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x2: NvU16,
    #[doc = "!< y coordinate of color primary 2 (e.g. Blue) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y2: NvU16,
    #[doc = "!< x coordinate of white point of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayWhitePoint_x: NvU16,
    #[doc = "!< y coordinate of white point of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayWhitePoint_y: NvU16,
    #[doc = "!< Maximum display luminance = desired max luminance of HDR content ([0x0001-0xFFFF] = [1.0 - 65535.0] cd/m^2)"]
    pub desired_content_max_luminance: NvU16,
    #[doc = "!< Minimum display luminance = desired min luminance of HDR content ([0x0001-0xFFFF] = [1.0 - 6.55350] cd/m^2)"]
    pub desired_content_min_luminance: NvU16,
    #[doc = "!< Desired maximum Frame-Average Light Level (MaxFALL) of HDR content ([0x0001-0xFFFF] = [1.0 - 65535.0] cd/m^2)"]
    pub desired_content_max_frame_average_luminance: NvU16,
}
#[test]
fn bindgen_test_layout__NV_HDR_CAPABILITIES_V2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_1>(),
        22usize,
        concat!(
            "Size of: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1)
        )
    );
    fn test_field_displayPrimary_x0() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_x0) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_x0)
            )
        );
    }
    test_field_displayPrimary_x0();
    fn test_field_displayPrimary_y0() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_y0) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_y0)
            )
        );
    }
    test_field_displayPrimary_y0();
    fn test_field_displayPrimary_x1() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_x1) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_x1)
            )
        );
    }
    test_field_displayPrimary_x1();
    fn test_field_displayPrimary_y1() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_y1) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_y1)
            )
        );
    }
    test_field_displayPrimary_y1();
    fn test_field_displayPrimary_x2() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_x2) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_x2)
            )
        );
    }
    test_field_displayPrimary_x2();
    fn test_field_displayPrimary_y2() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_y2) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_y2)
            )
        );
    }
    test_field_displayPrimary_y2();
    fn test_field_displayWhitePoint_x() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayWhitePoint_x) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
                "::",
                stringify!(displayWhitePoint_x)
            )
        );
    }
    test_field_displayWhitePoint_x();
    fn test_field_displayWhitePoint_y() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayWhitePoint_y) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
                "::",
                stringify!(displayWhitePoint_y)
            )
        );
    }
    test_field_displayWhitePoint_y();
    fn test_field_desired_content_max_luminance() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).desired_content_max_luminance) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
                "::",
                stringify!(desired_content_max_luminance)
            )
        );
    }
    test_field_desired_content_max_luminance();
    fn test_field_desired_content_min_luminance() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).desired_content_min_luminance) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
                "::",
                stringify!(desired_content_min_luminance)
            )
        );
    }
    test_field_desired_content_min_luminance();
    fn test_field_desired_content_max_frame_average_luminance() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).desired_content_max_frame_average_luminance) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
                "::",
                stringify!(desired_content_max_frame_average_luminance)
            )
        );
    }
    test_field_desired_content_max_frame_average_luminance();
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V2__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Represents min luminance level of Sink"]
    pub target_min_luminance: NvU16,
    #[doc = "!< Represents max luminance level of sink"]
    pub target_max_luminance: NvU16,
    #[doc = "!< Red primary chromaticity coordinate x"]
    pub cc_red_x: NvU16,
    #[doc = "!< Red primary chromaticity coordinate y"]
    pub cc_red_y: NvU16,
    #[doc = "!< Green primary chromaticity coordinate x"]
    pub cc_green_x: NvU16,
    #[doc = "!< Green primary chromaticity coordinate Y"]
    pub cc_green_y: NvU16,
    #[doc = "!< Blue primary chromaticity coordinate x"]
    pub cc_blue_x: NvU16,
    #[doc = "!< Blue primary chromaticity coordinate y"]
    pub cc_blue_y: NvU16,
    #[doc = "!< White primary chromaticity coordinate x"]
    pub cc_white_x: NvU16,
    #[doc = "!< White primary chromaticity coordinate y"]
    pub cc_white_y: NvU16,
}
#[test]
fn bindgen_test_layout__NV_HDR_CAPABILITIES_V2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2)
        )
    );
    fn test_field_target_min_luminance() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).target_min_luminance) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2),
                "::",
                stringify!(target_min_luminance)
            )
        );
    }
    test_field_target_min_luminance();
    fn test_field_target_max_luminance() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).target_max_luminance) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2),
                "::",
                stringify!(target_max_luminance)
            )
        );
    }
    test_field_target_max_luminance();
    fn test_field_cc_red_x() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cc_red_x) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2),
                "::",
                stringify!(cc_red_x)
            )
        );
    }
    test_field_cc_red_x();
    fn test_field_cc_red_y() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cc_red_y) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2),
                "::",
                stringify!(cc_red_y)
            )
        );
    }
    test_field_cc_red_y();
    fn test_field_cc_green_x() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cc_green_x) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2),
                "::",
                stringify!(cc_green_x)
            )
        );
    }
    test_field_cc_green_x();
    fn test_field_cc_green_y() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cc_green_y) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2),
                "::",
                stringify!(cc_green_y)
            )
        );
    }
    test_field_cc_green_y();
    fn test_field_cc_blue_x() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cc_blue_x) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2),
                "::",
                stringify!(cc_blue_x)
            )
        );
    }
    test_field_cc_blue_x();
    fn test_field_cc_blue_y() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cc_blue_y) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2),
                "::",
                stringify!(cc_blue_y)
            )
        );
    }
    test_field_cc_blue_y();
    fn test_field_cc_white_x() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cc_white_x) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2),
                "::",
                stringify!(cc_white_x)
            )
        );
    }
    test_field_cc_white_x();
    fn test_field_cc_white_y() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cc_white_y) as usize - ptr as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2),
                "::",
                stringify!(cc_white_y)
            )
        );
    }
    test_field_cc_white_y();
}
impl _NV_HDR_CAPABILITIES_V2__bindgen_ty_2 {
    #[inline]
    pub fn VSVDB_version(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_VSVDB_version(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dm_version(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dm_version(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_2160p60hz(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supports_2160p60hz(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_YUV422_12bit(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supports_YUV422_12bit(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_global_dimming(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supports_global_dimming(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn colorimetry(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_colorimetry(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_backlight_control(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_supports_backlight_control(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn backlt_min_luma(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_backlt_min_luma(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn interface_supported_by_sink(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_interface_supported_by_sink(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_10b_12b_444(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_supports_10b_12b_444(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VSVDB_version: NvU32,
        dm_version: NvU32,
        supports_2160p60hz: NvU32,
        supports_YUV422_12bit: NvU32,
        supports_global_dimming: NvU32,
        colorimetry: NvU32,
        supports_backlight_control: NvU32,
        backlt_min_luma: NvU32,
        interface_supported_by_sink: NvU32,
        supports_10b_12b_444: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let VSVDB_version: u32 = unsafe { ::std::mem::transmute(VSVDB_version) };
            VSVDB_version as u64
        });
        __bindgen_bitfield_unit.set(3usize, 8u8, {
            let dm_version: u32 = unsafe { ::std::mem::transmute(dm_version) };
            dm_version as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let supports_2160p60hz: u32 = unsafe { ::std::mem::transmute(supports_2160p60hz) };
            supports_2160p60hz as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let supports_YUV422_12bit: u32 =
                unsafe { ::std::mem::transmute(supports_YUV422_12bit) };
            supports_YUV422_12bit as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let supports_global_dimming: u32 =
                unsafe { ::std::mem::transmute(supports_global_dimming) };
            supports_global_dimming as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let colorimetry: u32 = unsafe { ::std::mem::transmute(colorimetry) };
            colorimetry as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let supports_backlight_control: u32 =
                unsafe { ::std::mem::transmute(supports_backlight_control) };
            supports_backlight_control as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let backlt_min_luma: u32 = unsafe { ::std::mem::transmute(backlt_min_luma) };
            backlt_min_luma as u64
        });
        __bindgen_bitfield_unit.set(19usize, 2u8, {
            let interface_supported_by_sink: u32 =
                unsafe { ::std::mem::transmute(interface_supported_by_sink) };
            interface_supported_by_sink as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let supports_10b_12b_444: u32 = unsafe { ::std::mem::transmute(supports_10b_12b_444) };
            supports_10b_12b_444 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__NV_HDR_CAPABILITIES_V2() {
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_CAPABILITIES_V2>(),
        60usize,
        concat!("Size of: ", stringify!(_NV_HDR_CAPABILITIES_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_CAPABILITIES_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_HDR_CAPABILITIES_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_static_metadata_descriptor_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).static_metadata_descriptor_id) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2),
                "::",
                stringify!(static_metadata_descriptor_id)
            )
        );
    }
    test_field_static_metadata_descriptor_id();
    fn test_field_display_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).display_data) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2),
                "::",
                stringify!(display_data)
            )
        );
    }
    test_field_display_data();
    fn test_field_dv_static_metadata() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDR_CAPABILITIES_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dv_static_metadata) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_CAPABILITIES_V2),
                "::",
                stringify!(dv_static_metadata)
            )
        );
    }
    test_field_dv_static_metadata();
}
impl Default for _NV_HDR_CAPABILITIES_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_HDR_CAPABILITIES_V2 {
    #[inline]
    pub fn isST2084EotfSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isST2084EotfSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isTraditionalHdrGammaSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isTraditionalHdrGammaSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isEdrSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEdrSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn driverExpandDefaultHdrParameters(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_driverExpandDefaultHdrParameters(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isTraditionalSdrGammaSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isTraditionalSdrGammaSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isDolbyVisionSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isDolbyVisionSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isST2084EotfSupported: NvU32,
        isTraditionalHdrGammaSupported: NvU32,
        isEdrSupported: NvU32,
        driverExpandDefaultHdrParameters: NvU32,
        isTraditionalSdrGammaSupported: NvU32,
        isDolbyVisionSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isST2084EotfSupported: u32 =
                unsafe { ::std::mem::transmute(isST2084EotfSupported) };
            isST2084EotfSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isTraditionalHdrGammaSupported: u32 =
                unsafe { ::std::mem::transmute(isTraditionalHdrGammaSupported) };
            isTraditionalHdrGammaSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isEdrSupported: u32 = unsafe { ::std::mem::transmute(isEdrSupported) };
            isEdrSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let driverExpandDefaultHdrParameters: u32 =
                unsafe { ::std::mem::transmute(driverExpandDefaultHdrParameters) };
            driverExpandDefaultHdrParameters as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isTraditionalSdrGammaSupported: u32 =
                unsafe { ::std::mem::transmute(isTraditionalSdrGammaSupported) };
            isTraditionalSdrGammaSupported as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let isDolbyVisionSupported: u32 =
                unsafe { ::std::mem::transmute(isDolbyVisionSupported) };
            isDolbyVisionSupported as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_HDR_CAPABILITIES_V2 = _NV_HDR_CAPABILITIES_V2;
pub type NV_HDR_CAPABILITIES = NV_HDR_CAPABILITIES_V2;
extern "C" {
    #[doc = ""]
    pub fn NvAPI_Disp_GetHdrCapabilities(
        displayId: NvU32,
        pHdrCapabilities: *mut NV_HDR_CAPABILITIES,
    ) -> NvAPI_Status;
}
#[doc = "!< Get current HDR output configuration"]
pub const NV_HDR_CMD_NV_HDR_CMD_GET: NV_HDR_CMD = 0;
#[doc = "!< Set HDR output configuration"]
pub const NV_HDR_CMD_NV_HDR_CMD_SET: NV_HDR_CMD = 1;
#[doc = "! @}"]
pub type NV_HDR_CMD = ::std::os::raw::c_int;
#[doc = "!< Turn off HDR"]
pub const NV_HDR_MODE_NV_HDR_MODE_OFF: NV_HDR_MODE = 0;
#[doc = "!< Source: CCCS [a.k.a FP16 scRGB, linear, sRGB primaries, [-65504,0, 65504] range, RGB(1,1,1) = 80nits]  Output : UHDA HDR [a.k.a HDR10, RGB/YCC 10/12bpc ST2084(PQ) EOTF RGB(1,1,1) = 10000 nits, Rec2020 color primaries, ST2086 static HDR metadata]. This is the only supported production HDR mode."]
pub const NV_HDR_MODE_NV_HDR_MODE_UHDA: NV_HDR_MODE = 2;
#[doc = "!< Experimental mode only, not for production! Source: HDR10 RGB 10bpc Output: HDR10 RGB 10 bpc - signal UHDA HDR mode (PQ + Rec2020) to the sink but send source pixel values unmodified (no PQ or Rec2020 conversions) - assumes source is already in HDR10 format."]
pub const NV_HDR_MODE_NV_HDR_MODE_UHDA_PASSTHROUGH: NV_HDR_MODE = 5;
#[doc = "!< Experimental mode only, not for production! Source: RGB8 Dolby Vision encoded (12 bpc YCbCr422 packed into RGB8) Output: Dolby Vision encoded : Application is to encoded frames in DV format and embed DV dynamic metadata as described in Dolby Vision specification."]
pub const NV_HDR_MODE_NV_HDR_MODE_DOLBY_VISION: NV_HDR_MODE = 7;
#[doc = "!< Do not use! Internal test mode only, to be removed. Source: CCCS (a.k.a FP16 scRGB) Output : EDR (Extended Dynamic Range) - HDR content is tonemapped and gamut mapped to output on regular SDR display set to max luminance ( ~300 nits )."]
pub const NV_HDR_MODE_NV_HDR_MODE_EDR: NV_HDR_MODE = 3;
#[doc = "!< Do not use! Internal test mode only, to be removed. Source: any Output: SDR (Standard Dynamic Range), we continuously send SDR EOTF InfoFrame signaling, HDMI compliance testing."]
pub const NV_HDR_MODE_NV_HDR_MODE_SDR: NV_HDR_MODE = 4;
#[doc = "!< Do not use! Internal test mode only, to be removed. Source: CCCS (a.k.a FP16 scRGB) Output : notebook HDR"]
pub const NV_HDR_MODE_NV_HDR_MODE_UHDA_NB: NV_HDR_MODE = 6;
#[doc = "!< Do not use! Obsolete, to be removed. NV_HDR_MODE_UHDBD == NV_HDR_MODE_UHDA, reflects obsolete pre-UHDA naming convention."]
pub const NV_HDR_MODE_NV_HDR_MODE_UHDBD: NV_HDR_MODE = 2;
pub type NV_HDR_MODE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_HDR_COLOR_DATA_V1 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Command get/set"]
    pub cmd: NV_HDR_CMD,
    #[doc = "!< HDR mode"]
    pub hdrMode: NV_HDR_MODE,
    #[doc = "!< Static Metadata Descriptor Id (0 for static metadata type 1)"]
    pub static_metadata_descriptor_id: NV_STATIC_METADATA_DESCRIPTOR_ID,
    pub mastering_display_data: _NV_HDR_COLOR_DATA_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_HDR_COLOR_DATA_V1__bindgen_ty_1 {
    #[doc = "!< x coordinate of color primary 0 (e.g. Red) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x0: NvU16,
    #[doc = "!< y coordinate of color primary 0 (e.g. Red) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y0: NvU16,
    #[doc = "!< x coordinate of color primary 1 (e.g. Green) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x1: NvU16,
    #[doc = "!< y coordinate of color primary 1 (e.g. Green) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y1: NvU16,
    #[doc = "!< x coordinate of color primary 2 (e.g. Blue) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x2: NvU16,
    #[doc = "!< y coordinate of color primary 2 (e.g. Blue) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y2: NvU16,
    #[doc = "!< x coordinate of white point of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayWhitePoint_x: NvU16,
    #[doc = "!< y coordinate of white point of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayWhitePoint_y: NvU16,
    #[doc = "!< Maximum display mastering luminance ([0x0001-0xFFFF] = [1.0 - 65535.0] cd/m^2)"]
    pub max_display_mastering_luminance: NvU16,
    #[doc = "!< Minimum display mastering luminance ([0x0001-0xFFFF] = [1.0 - 6.55350] cd/m^2)"]
    pub min_display_mastering_luminance: NvU16,
    #[doc = "!< Maximum Content Light level (MaxCLL) ([0x0001-0xFFFF] = [1.0 - 65535.0] cd/m^2)"]
    pub max_content_light_level: NvU16,
    #[doc = "!< Maximum Frame-Average Light Level (MaxFALL) ([0x0001-0xFFFF] = [1.0 - 65535.0] cd/m^2)"]
    pub max_frame_average_light_level: NvU16,
}
#[test]
fn bindgen_test_layout__NV_HDR_COLOR_DATA_V1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_COLOR_DATA_V1__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_COLOR_DATA_V1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1)
        )
    );
    fn test_field_displayPrimary_x0() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_x0) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_x0)
            )
        );
    }
    test_field_displayPrimary_x0();
    fn test_field_displayPrimary_y0() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_y0) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_y0)
            )
        );
    }
    test_field_displayPrimary_y0();
    fn test_field_displayPrimary_x1() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_x1) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_x1)
            )
        );
    }
    test_field_displayPrimary_x1();
    fn test_field_displayPrimary_y1() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_y1) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_y1)
            )
        );
    }
    test_field_displayPrimary_y1();
    fn test_field_displayPrimary_x2() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_x2) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_x2)
            )
        );
    }
    test_field_displayPrimary_x2();
    fn test_field_displayPrimary_y2() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_y2) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_y2)
            )
        );
    }
    test_field_displayPrimary_y2();
    fn test_field_displayWhitePoint_x() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayWhitePoint_x) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
                "::",
                stringify!(displayWhitePoint_x)
            )
        );
    }
    test_field_displayWhitePoint_x();
    fn test_field_displayWhitePoint_y() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayWhitePoint_y) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
                "::",
                stringify!(displayWhitePoint_y)
            )
        );
    }
    test_field_displayWhitePoint_y();
    fn test_field_max_display_mastering_luminance() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_display_mastering_luminance) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
                "::",
                stringify!(max_display_mastering_luminance)
            )
        );
    }
    test_field_max_display_mastering_luminance();
    fn test_field_min_display_mastering_luminance() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).min_display_mastering_luminance) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
                "::",
                stringify!(min_display_mastering_luminance)
            )
        );
    }
    test_field_min_display_mastering_luminance();
    fn test_field_max_content_light_level() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_content_light_level) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
                "::",
                stringify!(max_content_light_level)
            )
        );
    }
    test_field_max_content_light_level();
    fn test_field_max_frame_average_light_level() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_frame_average_light_level) as usize - ptr as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
                "::",
                stringify!(max_frame_average_light_level)
            )
        );
    }
    test_field_max_frame_average_light_level();
}
#[test]
fn bindgen_test_layout__NV_HDR_COLOR_DATA_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_COLOR_DATA_V1>(),
        40usize,
        concat!("Size of: ", stringify!(_NV_HDR_COLOR_DATA_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_COLOR_DATA_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_HDR_COLOR_DATA_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V1),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_hdrMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hdrMode) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V1),
                "::",
                stringify!(hdrMode)
            )
        );
    }
    test_field_hdrMode();
    fn test_field_static_metadata_descriptor_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).static_metadata_descriptor_id) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V1),
                "::",
                stringify!(static_metadata_descriptor_id)
            )
        );
    }
    test_field_static_metadata_descriptor_id();
    fn test_field_mastering_display_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mastering_display_data) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V1),
                "::",
                stringify!(mastering_display_data)
            )
        );
    }
    test_field_mastering_display_data();
}
impl Default for _NV_HDR_COLOR_DATA_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_HDR_COLOR_DATA_V1 = _NV_HDR_COLOR_DATA_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_HDR_COLOR_DATA_V2 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Command get/set"]
    pub cmd: NV_HDR_CMD,
    #[doc = "!< HDR mode"]
    pub hdrMode: NV_HDR_MODE,
    #[doc = "!< Static Metadata Descriptor Id (0 for static metadata type 1)"]
    pub static_metadata_descriptor_id: NV_STATIC_METADATA_DESCRIPTOR_ID,
    pub mastering_display_data: _NV_HDR_COLOR_DATA_V2__bindgen_ty_1,
    #[doc = "!< Optional, One of NV_COLOR_FORMAT enum values, if set it will apply requested color format for HDR session"]
    pub hdrColorFormat: NV_COLOR_FORMAT,
    #[doc = "!< Optional, One of NV_DYNAMIC_RANGE enum values, if set it will apply requested dynamic range for HDR session"]
    pub hdrDynamicRange: NV_DYNAMIC_RANGE,
    #[doc = "!< Optional, One of NV_BPC enum values, if set it will apply requested color depth"]
    #[doc = "!< Dolby Vision mode: DV supports specific combinations of colorformat, dynamic range and bpc. Please refer Dolby Vision specification."]
    #[doc = "!<                    If invalid or no combination is passed driver will force default combination of RGB format + full range + 8bpc."]
    #[doc = "!< HDR mode: These fields are ignored in hdr mode"]
    pub hdrBpc: NV_BPC,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_HDR_COLOR_DATA_V2__bindgen_ty_1 {
    #[doc = "!< x coordinate of color primary 0 (e.g. Red) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x0: NvU16,
    #[doc = "!< y coordinate of color primary 0 (e.g. Red) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y0: NvU16,
    #[doc = "!< x coordinate of color primary 1 (e.g. Green) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x1: NvU16,
    #[doc = "!< y coordinate of color primary 1 (e.g. Green) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y1: NvU16,
    #[doc = "!< x coordinate of color primary 2 (e.g. Blue) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x2: NvU16,
    #[doc = "!< y coordinate of color primary 2 (e.g. Blue) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y2: NvU16,
    #[doc = "!< x coordinate of white point of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayWhitePoint_x: NvU16,
    #[doc = "!< y coordinate of white point of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayWhitePoint_y: NvU16,
    #[doc = "!< Maximum display mastering luminance ([0x0001-0xFFFF] = [1.0 - 65535.0] cd/m^2)"]
    pub max_display_mastering_luminance: NvU16,
    #[doc = "!< Minimum display mastering luminance ([0x0001-0xFFFF] = [1.0 - 6.55350] cd/m^2)"]
    pub min_display_mastering_luminance: NvU16,
    #[doc = "!< Maximum Content Light level (MaxCLL) ([0x0001-0xFFFF] = [1.0 - 65535.0] cd/m^2)"]
    pub max_content_light_level: NvU16,
    #[doc = "!< Maximum Frame-Average Light Level (MaxFALL) ([0x0001-0xFFFF] = [1.0 - 65535.0] cd/m^2)"]
    pub max_frame_average_light_level: NvU16,
}
#[test]
fn bindgen_test_layout__NV_HDR_COLOR_DATA_V2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_COLOR_DATA_V2__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_COLOR_DATA_V2__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1)
        )
    );
    fn test_field_displayPrimary_x0() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_x0) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_x0)
            )
        );
    }
    test_field_displayPrimary_x0();
    fn test_field_displayPrimary_y0() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_y0) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_y0)
            )
        );
    }
    test_field_displayPrimary_y0();
    fn test_field_displayPrimary_x1() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_x1) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_x1)
            )
        );
    }
    test_field_displayPrimary_x1();
    fn test_field_displayPrimary_y1() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_y1) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_y1)
            )
        );
    }
    test_field_displayPrimary_y1();
    fn test_field_displayPrimary_x2() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_x2) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_x2)
            )
        );
    }
    test_field_displayPrimary_x2();
    fn test_field_displayPrimary_y2() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimary_y2) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
                "::",
                stringify!(displayPrimary_y2)
            )
        );
    }
    test_field_displayPrimary_y2();
    fn test_field_displayWhitePoint_x() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayWhitePoint_x) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
                "::",
                stringify!(displayWhitePoint_x)
            )
        );
    }
    test_field_displayWhitePoint_x();
    fn test_field_displayWhitePoint_y() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayWhitePoint_y) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
                "::",
                stringify!(displayWhitePoint_y)
            )
        );
    }
    test_field_displayWhitePoint_y();
    fn test_field_max_display_mastering_luminance() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_display_mastering_luminance) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
                "::",
                stringify!(max_display_mastering_luminance)
            )
        );
    }
    test_field_max_display_mastering_luminance();
    fn test_field_min_display_mastering_luminance() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).min_display_mastering_luminance) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
                "::",
                stringify!(min_display_mastering_luminance)
            )
        );
    }
    test_field_min_display_mastering_luminance();
    fn test_field_max_content_light_level() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_content_light_level) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
                "::",
                stringify!(max_content_light_level)
            )
        );
    }
    test_field_max_content_light_level();
    fn test_field_max_frame_average_light_level() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_frame_average_light_level) as usize - ptr as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
                "::",
                stringify!(max_frame_average_light_level)
            )
        );
    }
    test_field_max_frame_average_light_level();
}
#[test]
fn bindgen_test_layout__NV_HDR_COLOR_DATA_V2() {
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_COLOR_DATA_V2>(),
        52usize,
        concat!("Size of: ", stringify!(_NV_HDR_COLOR_DATA_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_COLOR_DATA_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_HDR_COLOR_DATA_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V2),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_hdrMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hdrMode) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V2),
                "::",
                stringify!(hdrMode)
            )
        );
    }
    test_field_hdrMode();
    fn test_field_static_metadata_descriptor_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).static_metadata_descriptor_id) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V2),
                "::",
                stringify!(static_metadata_descriptor_id)
            )
        );
    }
    test_field_static_metadata_descriptor_id();
    fn test_field_mastering_display_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mastering_display_data) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V2),
                "::",
                stringify!(mastering_display_data)
            )
        );
    }
    test_field_mastering_display_data();
    fn test_field_hdrColorFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hdrColorFormat) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V2),
                "::",
                stringify!(hdrColorFormat)
            )
        );
    }
    test_field_hdrColorFormat();
    fn test_field_hdrDynamicRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hdrDynamicRange) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V2),
                "::",
                stringify!(hdrDynamicRange)
            )
        );
    }
    test_field_hdrDynamicRange();
    fn test_field_hdrBpc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_HDR_COLOR_DATA_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hdrBpc) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_HDR_COLOR_DATA_V2),
                "::",
                stringify!(hdrBpc)
            )
        );
    }
    test_field_hdrBpc();
}
impl Default for _NV_HDR_COLOR_DATA_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_HDR_COLOR_DATA_V2 = _NV_HDR_COLOR_DATA_V2;
pub type NV_HDR_COLOR_DATA = NV_HDR_COLOR_DATA_V2;
extern "C" {
    #[doc = ""]
    pub fn NvAPI_Disp_HdrColorControl(
        displayId: NvU32,
        pHdrColorData: *mut NV_HDR_COLOR_DATA,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NvAPI_DISP_GetTiming()."]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct NV_TIMING_FLAG {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_anon_1: NV_TIMING_FLAG__bindgen_ty_1,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 5usize],
}
#[repr(C)]
#[repr(align(1))]
#[derive(Copy, Clone)]
pub union NV_TIMING_FLAG__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
}
#[test]
fn bindgen_test_layout_NV_TIMING_FLAG__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_TIMING_FLAG__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(NV_TIMING_FLAG__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_TIMING_FLAG__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(NV_TIMING_FLAG__bindgen_ty_1))
    );
}
impl Default for NV_TIMING_FLAG__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl NV_TIMING_FLAG__bindgen_ty_1 {
    #[inline]
    pub fn tvFormat(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tvFormat(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ceaId(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ceaId(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn nvPsfId(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_nvPsfId(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tvFormat: NvU32,
        ceaId: NvU32,
        nvPsfId: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let tvFormat: u32 = unsafe { ::std::mem::transmute(tvFormat) };
            tvFormat as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let ceaId: u32 = unsafe { ::std::mem::transmute(ceaId) };
            ceaId as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let nvPsfId: u32 = unsafe { ::std::mem::transmute(nvPsfId) };
            nvPsfId as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NV_TIMING_FLAG() {
    assert_eq!(
        ::std::mem::size_of::<NV_TIMING_FLAG>(),
        12usize,
        concat!("Size of: ", stringify!(NV_TIMING_FLAG))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_TIMING_FLAG>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_TIMING_FLAG))
    );
}
impl Default for NV_TIMING_FLAG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl NV_TIMING_FLAG {
    #[inline]
    pub fn isInterlaced(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_isInterlaced(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isInterlaced: NvU32,
        reserved0: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let isInterlaced: u32 = unsafe { ::std::mem::transmute(isInterlaced) };
            isInterlaced as u64
        });
        __bindgen_bitfield_unit.set(4usize, 12u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn scaling(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_scaling(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(scaling: NvU32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let scaling: u32 = unsafe { ::std::mem::transmute(scaling) };
            scaling as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NvAPI_DISP_GetTiming()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_TIMING_INPUT {
    #[doc = "!< (IN)     structure version"]
    pub version: NvU32,
    #[doc = "!< Visible horizontal size"]
    pub width: NvU32,
    #[doc = "!< Visible vertical size"]
    pub height: NvU32,
    #[doc = "!< Timing refresh rate"]
    pub rr: f32,
    #[doc = "!< Flag containing additional info for timing calculation."]
    pub flag: NV_TIMING_FLAG,
    #[doc = "!< Timing type(formula) to use for calculating the timing"]
    pub type_: NV_TIMING_OVERRIDE,
}
#[test]
fn bindgen_test_layout__NV_TIMING_INPUT() {
    assert_eq!(
        ::std::mem::size_of::<_NV_TIMING_INPUT>(),
        32usize,
        concat!("Size of: ", stringify!(_NV_TIMING_INPUT))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_TIMING_INPUT>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_TIMING_INPUT))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_TIMING_INPUT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_TIMING_INPUT),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_TIMING_INPUT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_TIMING_INPUT),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_TIMING_INPUT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_TIMING_INPUT),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_rr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_TIMING_INPUT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rr) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_TIMING_INPUT),
                "::",
                stringify!(rr)
            )
        );
    }
    test_field_rr();
    fn test_field_flag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_TIMING_INPUT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flag) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_TIMING_INPUT),
                "::",
                stringify!(flag)
            )
        );
    }
    test_field_flag();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_TIMING_INPUT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_TIMING_INPUT),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
}
impl Default for _NV_TIMING_INPUT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NvAPI_DISP_GetTiming()."]
pub type NV_TIMING_INPUT = _NV_TIMING_INPUT;
extern "C" {
    #[doc = "! DESCRIPTION:  This function calculates the timing from the visible width/height/refresh-rate and timing type info."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 313"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]   displayId     Display ID of the display."]
    #[doc = "! \\param [in]   timingInput   Inputs used for calculating the timing."]
    #[doc = "! \\param [out]  pTiming       Pointer to the NV_TIMING structure."]
    #[doc = "!"]
    #[doc = "! \\return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with"]
    #[doc = "!                specific meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_DISP_GetTiming(
        displayId: NvU32,
        timingInput: *mut NV_TIMING_INPUT,
        pTiming: *mut NV_TIMING,
    ) -> NvAPI_Status;
}
pub const NV_MONITOR_CAPS_TYPE_NV_MONITOR_CAPS_TYPE_HDMI_VSDB: NV_MONITOR_CAPS_TYPE = 4096;
pub const NV_MONITOR_CAPS_TYPE_NV_MONITOR_CAPS_TYPE_HDMI_VCDB: NV_MONITOR_CAPS_TYPE = 4097;
#[doc = "! HDMI-related and extended CAPs"]
pub type NV_MONITOR_CAPS_TYPE = ::std::os::raw::c_int;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_MONITOR_CAPS_VCDB {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout__NV_MONITOR_CAPS_VCDB() {
    assert_eq!(
        ::std::mem::size_of::<_NV_MONITOR_CAPS_VCDB>(),
        1usize,
        concat!("Size of: ", stringify!(_NV_MONITOR_CAPS_VCDB))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MONITOR_CAPS_VCDB>(),
        1usize,
        concat!("Alignment of ", stringify!(_NV_MONITOR_CAPS_VCDB))
    );
}
impl _NV_MONITOR_CAPS_VCDB {
    #[inline]
    pub fn quantizationRangeYcc(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_quantizationRangeYcc(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn quantizationRangeRgb(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_quantizationRangeRgb(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scanInfoPreferredVideoFormat(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_scanInfoPreferredVideoFormat(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn scanInfoITVideoFormats(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_scanInfoITVideoFormats(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn scanInfoCEVideoFormats(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_scanInfoCEVideoFormats(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        quantizationRangeYcc: NvU8,
        quantizationRangeRgb: NvU8,
        scanInfoPreferredVideoFormat: NvU8,
        scanInfoITVideoFormats: NvU8,
        scanInfoCEVideoFormats: NvU8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let quantizationRangeYcc: u8 = unsafe { ::std::mem::transmute(quantizationRangeYcc) };
            quantizationRangeYcc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let quantizationRangeRgb: u8 = unsafe { ::std::mem::transmute(quantizationRangeRgb) };
            quantizationRangeRgb as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let scanInfoPreferredVideoFormat: u8 =
                unsafe { ::std::mem::transmute(scanInfoPreferredVideoFormat) };
            scanInfoPreferredVideoFormat as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let scanInfoITVideoFormats: u8 =
                unsafe { ::std::mem::transmute(scanInfoITVideoFormats) };
            scanInfoITVideoFormats as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let scanInfoCEVideoFormats: u8 =
                unsafe { ::std::mem::transmute(scanInfoCEVideoFormats) };
            scanInfoCEVideoFormats as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_MONITOR_CAPS_VCDB = _NV_MONITOR_CAPS_VCDB;
#[doc = "! See NvAPI_DISP_GetMonitorCapabilities()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_MONITOR_CAPS_VSDB {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    #[doc = "!< Bye 4"]
    pub maxTmdsClock: NvU8,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "!< Byte 6"]
    pub videoLatency: NvU8,
    #[doc = "!< Byte 7"]
    pub audioLatency: NvU8,
    #[doc = "!< Byte 8"]
    pub interlacedVideoLatency: NvU8,
    #[doc = "!< Byte 9"]
    pub interlacedAudioLatency: NvU8,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "!< Keeping maximum length for 3 bits"]
    pub hdmi_vic: [NvU8; 7usize],
    #[doc = "!< Keeping maximum length for 5 bits"]
    pub hdmi_3d: [NvU8; 31usize],
}
#[test]
fn bindgen_test_layout__NV_MONITOR_CAPS_VSDB() {
    assert_eq!(
        ::std::mem::size_of::<_NV_MONITOR_CAPS_VSDB>(),
        49usize,
        concat!("Size of: ", stringify!(_NV_MONITOR_CAPS_VSDB))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MONITOR_CAPS_VSDB>(),
        1usize,
        concat!("Alignment of ", stringify!(_NV_MONITOR_CAPS_VSDB))
    );
    fn test_field_maxTmdsClock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MONITOR_CAPS_VSDB>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTmdsClock) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MONITOR_CAPS_VSDB),
                "::",
                stringify!(maxTmdsClock)
            )
        );
    }
    test_field_maxTmdsClock();
    fn test_field_videoLatency() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MONITOR_CAPS_VSDB>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).videoLatency) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MONITOR_CAPS_VSDB),
                "::",
                stringify!(videoLatency)
            )
        );
    }
    test_field_videoLatency();
    fn test_field_audioLatency() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MONITOR_CAPS_VSDB>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).audioLatency) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MONITOR_CAPS_VSDB),
                "::",
                stringify!(audioLatency)
            )
        );
    }
    test_field_audioLatency();
    fn test_field_interlacedVideoLatency() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MONITOR_CAPS_VSDB>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).interlacedVideoLatency) as usize - ptr as usize
            },
            7usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MONITOR_CAPS_VSDB),
                "::",
                stringify!(interlacedVideoLatency)
            )
        );
    }
    test_field_interlacedVideoLatency();
    fn test_field_interlacedAudioLatency() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MONITOR_CAPS_VSDB>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).interlacedAudioLatency) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MONITOR_CAPS_VSDB),
                "::",
                stringify!(interlacedAudioLatency)
            )
        );
    }
    test_field_interlacedAudioLatency();
    fn test_field_hdmi_vic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MONITOR_CAPS_VSDB>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hdmi_vic) as usize - ptr as usize
            },
            11usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MONITOR_CAPS_VSDB),
                "::",
                stringify!(hdmi_vic)
            )
        );
    }
    test_field_hdmi_vic();
    fn test_field_hdmi_3d() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MONITOR_CAPS_VSDB>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hdmi_3d) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MONITOR_CAPS_VSDB),
                "::",
                stringify!(hdmi_3d)
            )
        );
    }
    test_field_hdmi_3d();
}
impl _NV_MONITOR_CAPS_VSDB {
    #[inline]
    pub fn sourcePhysicalAddressB(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_sourcePhysicalAddressB(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sourcePhysicalAddressA(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_sourcePhysicalAddressA(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sourcePhysicalAddressD(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_sourcePhysicalAddressD(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sourcePhysicalAddressC(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_sourcePhysicalAddressC(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn supportDualDviOperation(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportDualDviOperation(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn supportDeepColorYCbCr444(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportDeepColorYCbCr444(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supportDeepColor30bits(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportDeepColor30bits(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supportDeepColor36bits(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportDeepColor36bits(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supportDeepColor48bits(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportDeepColor48bits(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supportAI(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportAI(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sourcePhysicalAddressB: NvU8,
        sourcePhysicalAddressA: NvU8,
        sourcePhysicalAddressD: NvU8,
        sourcePhysicalAddressC: NvU8,
        supportDualDviOperation: NvU8,
        reserved6: NvU8,
        supportDeepColorYCbCr444: NvU8,
        supportDeepColor30bits: NvU8,
        supportDeepColor36bits: NvU8,
        supportDeepColor48bits: NvU8,
        supportAI: NvU8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let sourcePhysicalAddressB: u8 =
                unsafe { ::std::mem::transmute(sourcePhysicalAddressB) };
            sourcePhysicalAddressB as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let sourcePhysicalAddressA: u8 =
                unsafe { ::std::mem::transmute(sourcePhysicalAddressA) };
            sourcePhysicalAddressA as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let sourcePhysicalAddressD: u8 =
                unsafe { ::std::mem::transmute(sourcePhysicalAddressD) };
            sourcePhysicalAddressD as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let sourcePhysicalAddressC: u8 =
                unsafe { ::std::mem::transmute(sourcePhysicalAddressC) };
            sourcePhysicalAddressC as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let supportDualDviOperation: u8 =
                unsafe { ::std::mem::transmute(supportDualDviOperation) };
            supportDualDviOperation as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let reserved6: u8 = unsafe { ::std::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let supportDeepColorYCbCr444: u8 =
                unsafe { ::std::mem::transmute(supportDeepColorYCbCr444) };
            supportDeepColorYCbCr444 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let supportDeepColor30bits: u8 =
                unsafe { ::std::mem::transmute(supportDeepColor30bits) };
            supportDeepColor30bits as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let supportDeepColor36bits: u8 =
                unsafe { ::std::mem::transmute(supportDeepColor36bits) };
            supportDeepColor36bits as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let supportDeepColor48bits: u8 =
                unsafe { ::std::mem::transmute(supportDeepColor48bits) };
            supportDeepColor48bits as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let supportAI: u8 = unsafe { ::std::mem::transmute(supportAI) };
            supportAI as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn cnc0SupportGraphicsTextContent(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cnc0SupportGraphicsTextContent(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnc1SupportPhotoContent(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cnc1SupportPhotoContent(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnc2SupportCinemaContent(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cnc2SupportCinemaContent(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnc3SupportGameContent(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cnc3SupportGameContent(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasVicEntries(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hasVicEntries(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasInterlacedLatencyField(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hasInterlacedLatencyField(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasLatencyField(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hasLatencyField(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        cnc0SupportGraphicsTextContent: NvU8,
        cnc1SupportPhotoContent: NvU8,
        cnc2SupportCinemaContent: NvU8,
        cnc3SupportGameContent: NvU8,
        reserved8: NvU8,
        hasVicEntries: NvU8,
        hasInterlacedLatencyField: NvU8,
        hasLatencyField: NvU8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cnc0SupportGraphicsTextContent: u8 =
                unsafe { ::std::mem::transmute(cnc0SupportGraphicsTextContent) };
            cnc0SupportGraphicsTextContent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cnc1SupportPhotoContent: u8 =
                unsafe { ::std::mem::transmute(cnc1SupportPhotoContent) };
            cnc1SupportPhotoContent as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cnc2SupportCinemaContent: u8 =
                unsafe { ::std::mem::transmute(cnc2SupportCinemaContent) };
            cnc2SupportCinemaContent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cnc3SupportGameContent: u8 =
                unsafe { ::std::mem::transmute(cnc3SupportGameContent) };
            cnc3SupportGameContent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let reserved8: u8 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let hasVicEntries: u8 = unsafe { ::std::mem::transmute(hasVicEntries) };
            hasVicEntries as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let hasInterlacedLatencyField: u8 =
                unsafe { ::std::mem::transmute(hasInterlacedLatencyField) };
            hasInterlacedLatencyField as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let hasLatencyField: u8 = unsafe { ::std::mem::transmute(hasLatencyField) };
            hasLatencyField as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn reserved13(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved13(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn has3dEntries(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_has3dEntries(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hdmi3dLength(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(8usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_hdmi3dLength(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn hdmiVicLength(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(13usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_hdmiVicLength(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        reserved13: NvU8,
        has3dEntries: NvU8,
        hdmi3dLength: NvU8,
        hdmiVicLength: NvU8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let reserved13: u8 = unsafe { ::std::mem::transmute(reserved13) };
            reserved13 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let has3dEntries: u8 = unsafe { ::std::mem::transmute(has3dEntries) };
            has3dEntries as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let hdmi3dLength: u8 = unsafe { ::std::mem::transmute(hdmi3dLength) };
            hdmi3dLength as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let hdmiVicLength: u8 = unsafe { ::std::mem::transmute(hdmiVicLength) };
            hdmiVicLength as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! See NvAPI_DISP_GetMonitorCapabilities()."]
pub type NV_MONITOR_CAPS_VSDB = _NV_MONITOR_CAPS_VSDB;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_MONITOR_CAPS_GENERIC {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout__NV_MONITOR_CAPS_GENERIC() {
    assert_eq!(
        ::std::mem::size_of::<_NV_MONITOR_CAPS_GENERIC>(),
        1usize,
        concat!("Size of: ", stringify!(_NV_MONITOR_CAPS_GENERIC))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MONITOR_CAPS_GENERIC>(),
        1usize,
        concat!("Alignment of ", stringify!(_NV_MONITOR_CAPS_GENERIC))
    );
}
impl _NV_MONITOR_CAPS_GENERIC {
    #[inline]
    pub fn supportVRR(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportVRR(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supportULMB(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportULMB(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isTrueGsync(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isTrueGsync(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isRLACapable(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isRLACapable(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        supportVRR: NvU8,
        supportULMB: NvU8,
        isTrueGsync: NvU8,
        isRLACapable: NvU8,
        reserved: NvU8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let supportVRR: u8 = unsafe { ::std::mem::transmute(supportVRR) };
            supportVRR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let supportULMB: u8 = unsafe { ::std::mem::transmute(supportULMB) };
            supportULMB as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isTrueGsync: u8 = unsafe { ::std::mem::transmute(isTrueGsync) };
            isTrueGsync as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let isRLACapable: u8 = unsafe { ::std::mem::transmute(isRLACapable) };
            isRLACapable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_MONITOR_CAPS_GENERIC = _NV_MONITOR_CAPS_GENERIC;
#[doc = "! See NvAPI_DISP_GetMonitorCapabilities()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_MONITOR_CAPABILITIES_V1 {
    pub version: NvU32,
    pub size: NvU16,
    pub infoType: NvU32,
    #[doc = "!< Out: VGA, TV, DVI, HDMI, DP"]
    pub connectorType: NvU32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub data: _NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1 {
    pub vsdb: NV_MONITOR_CAPS_VSDB,
    pub vcdb: NV_MONITOR_CAPS_VCDB,
    pub caps: NV_MONITOR_CAPS_GENERIC,
}
#[test]
fn bindgen_test_layout__NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1>(),
        49usize,
        concat!(
            "Size of: ",
            stringify!(_NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1)
        )
    );
    fn test_field_vsdb() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vsdb) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1),
                "::",
                stringify!(vsdb)
            )
        );
    }
    test_field_vsdb();
    fn test_field_vcdb() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vcdb) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1),
                "::",
                stringify!(vcdb)
            )
        );
    }
    test_field_vcdb();
    fn test_field_caps() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).caps) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1),
                "::",
                stringify!(caps)
            )
        );
    }
    test_field_caps();
}
impl Default for _NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__NV_MONITOR_CAPABILITIES_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_MONITOR_CAPABILITIES_V1>(),
        68usize,
        concat!("Size of: ", stringify!(_NV_MONITOR_CAPABILITIES_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MONITOR_CAPABILITIES_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_MONITOR_CAPABILITIES_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MONITOR_CAPABILITIES_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MONITOR_CAPABILITIES_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MONITOR_CAPABILITIES_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MONITOR_CAPABILITIES_V1),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_infoType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MONITOR_CAPABILITIES_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).infoType) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MONITOR_CAPABILITIES_V1),
                "::",
                stringify!(infoType)
            )
        );
    }
    test_field_infoType();
    fn test_field_connectorType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MONITOR_CAPABILITIES_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).connectorType) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MONITOR_CAPABILITIES_V1),
                "::",
                stringify!(connectorType)
            )
        );
    }
    test_field_connectorType();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MONITOR_CAPABILITIES_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            17usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MONITOR_CAPABILITIES_V1),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
impl Default for _NV_MONITOR_CAPABILITIES_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_MONITOR_CAPABILITIES_V1 {
    #[inline]
    pub fn bIsValidInfo(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bIsValidInfo(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(bIsValidInfo: NvU8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsValidInfo: u8 = unsafe { ::std::mem::transmute(bIsValidInfo) };
            bIsValidInfo as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! See NvAPI_DISP_GetMonitorCapabilities()."]
pub type NV_MONITOR_CAPABILITIES_V1 = _NV_MONITOR_CAPABILITIES_V1;
#[doc = "! See NvAPI_DISP_GetMonitorCapabilities()."]
pub type NV_MONITOR_CAPABILITIES = NV_MONITOR_CAPABILITIES_V1;
extern "C" {
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "! \\ingroup dispcontrol"]
    pub fn NvAPI_DISP_GetMonitorCapabilities(
        displayId: NvU32,
        pMonitorCapabilities: *mut NV_MONITOR_CAPABILITIES,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup dispcontrol"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MONITOR_COLOR_DATA {
    pub version: NvU32,
    #[doc = "!< One of the supported color formats"]
    pub colorFormat: NV_DP_COLOR_FORMAT,
    #[doc = "!< One of the supported bit depths"]
    pub backendBitDepths: NV_DP_BPC,
}
#[test]
fn bindgen_test_layout__NV_MONITOR_COLOR_DATA() {
    assert_eq!(
        ::std::mem::size_of::<_NV_MONITOR_COLOR_DATA>(),
        12usize,
        concat!("Size of: ", stringify!(_NV_MONITOR_COLOR_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MONITOR_COLOR_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_MONITOR_COLOR_DATA))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MONITOR_COLOR_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MONITOR_COLOR_DATA),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_colorFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MONITOR_COLOR_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MONITOR_COLOR_DATA),
                "::",
                stringify!(colorFormat)
            )
        );
    }
    test_field_colorFormat();
    fn test_field_backendBitDepths() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MONITOR_COLOR_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).backendBitDepths) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MONITOR_COLOR_DATA),
                "::",
                stringify!(backendBitDepths)
            )
        );
    }
    test_field_backendBitDepths();
}
impl Default for _NV_MONITOR_COLOR_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup dispcontrol"]
pub type NV_MONITOR_COLOR_CAPS_V1 = _NV_MONITOR_COLOR_DATA;
#[doc = "! \\ingroup dispcontrol"]
pub type NV_MONITOR_COLOR_CAPS = NV_MONITOR_COLOR_CAPS_V1;
extern "C" {
    #[doc = "! DESCRIPTION:    This API returns all the color formats and bit depth values supported by a given DP monitor."]
    #[doc = "!"]
    #[doc = "! USAGE:         Sequence of calls which caller should make to get the information."]
    #[doc = "!                1. First call NvAPI_DISP_GetMonitorColorCapabilities() with pMonitorColorCapabilities as NULL to get the count."]
    #[doc = "!                2. Allocate memory for color caps(NV_MONITOR_COLOR_CAPS) array."]
    #[doc = "!                3. Call NvAPI_DISP_GetMonitorColorCapabilities() again with the pointer to the memory allocated to get all the"]
    #[doc = "!                   color capabilities."]
    #[doc = "!"]
    #[doc = "!                Note :"]
    #[doc = "!                1. pColorCapsCount should never be NULL, else the API will fail with NVAPI_INVALID_ARGUMENT."]
    #[doc = "!                2. *pColorCapsCount returned from the API will always be the actual count in any/every call."]
    #[doc = "!                3. Memory size to be allocated should be (*pColorCapsCount * sizeof(NV_MONITOR_COLOR_CAPS))."]
    #[doc = "!                4. If the memory allocated is less than what is required to return all the timings, this API will return the"]
    #[doc = "!                   amount of information which can fit in user provided buffer and API will return NVAPI_INSUFFICIENT_BUFFER."]
    #[doc = "!                5. If the caller specifies a greater value for *pColorCapsCount in second call to NvAPI_DISP_GetMonitorColorCapabilities()"]
    #[doc = "!                   than what was returned from first call, the API will return only the actual number of elements in the color"]
    #[doc = "!                   capabilities array and the extra buffer will remain unused."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]      displayId                  Monitor Identifier"]
    #[doc = "! \\param [in, out] pMonitorColorCapabilities  The monitor color capabilities information"]
    #[doc = "! \\param [in, out] pColorCapsCount            - During input, the number of elements allocated for the pMonitorColorCapabilities pointer"]
    #[doc = "!                                             - During output, the actual number of color data elements the monitor supports"]
    #[doc = "!"]
    #[doc = "! \\return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with"]
    #[doc = "!            specific meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\retval         NVAPI_INSUFFICIENT_BUFFER   The input buffer size is not sufficient to hold the total contents. In this case"]
    #[doc = "!                                             *pColorCapsCount will hold the required amount of elements."]
    #[doc = "! \\retval         NVAPI_INVALID_DISPLAY_ID    The input monitor is either not connected or is not a DP panel."]
    #[doc = "!"]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = "!"]
    #[doc = ""]
    pub fn NvAPI_DISP_GetMonitorColorCapabilities(
        displayId: NvU32,
        pMonitorColorCapabilities: *mut NV_MONITOR_COLOR_CAPS,
        pColorCapsCount: *mut NvU32,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup dispcontrol"]
#[doc = "! Used in NvAPI_DISP_EnumCustomDisplay() and NvAPI_DISP_TryCustomDisplay()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_CUSTOM_DISPLAY {
    pub version: NvU32,
    #[doc = "!< Source surface(source mode) width"]
    pub width: NvU32,
    #[doc = "!< Source surface(source mode) height"]
    pub height: NvU32,
    #[doc = "!< Source surface color depth.\"0\" means all 8/16/32bpp"]
    pub depth: NvU32,
    #[doc = "!< Color format (optional)"]
    pub colorFormat: NV_FORMAT,
    #[doc = "!< For multimon support, should be set to (0,0,1.0,1.0) for now."]
    pub srcPartition: NV_VIEWPORTF,
    #[doc = "!< Horizontal scaling ratio"]
    pub xRatio: f32,
    #[doc = "!< Vertical scaling ratio"]
    pub yRatio: f32,
    #[doc = "!< Timing used to program TMDS/DAC/LVDS/HDMI/TVEncoder, etc."]
    pub timing: NV_TIMING,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_NV_CUSTOM_DISPLAY() {
    assert_eq!(
        ::std::mem::size_of::<NV_CUSTOM_DISPLAY>(),
        144usize,
        concat!("Size of: ", stringify!(NV_CUSTOM_DISPLAY))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_CUSTOM_DISPLAY>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_CUSTOM_DISPLAY))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CUSTOM_DISPLAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CUSTOM_DISPLAY),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CUSTOM_DISPLAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CUSTOM_DISPLAY),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CUSTOM_DISPLAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CUSTOM_DISPLAY),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CUSTOM_DISPLAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CUSTOM_DISPLAY),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
    fn test_field_colorFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CUSTOM_DISPLAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CUSTOM_DISPLAY),
                "::",
                stringify!(colorFormat)
            )
        );
    }
    test_field_colorFormat();
    fn test_field_srcPartition() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CUSTOM_DISPLAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcPartition) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CUSTOM_DISPLAY),
                "::",
                stringify!(srcPartition)
            )
        );
    }
    test_field_srcPartition();
    fn test_field_xRatio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CUSTOM_DISPLAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xRatio) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CUSTOM_DISPLAY),
                "::",
                stringify!(xRatio)
            )
        );
    }
    test_field_xRatio();
    fn test_field_yRatio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CUSTOM_DISPLAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).yRatio) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CUSTOM_DISPLAY),
                "::",
                stringify!(yRatio)
            )
        );
    }
    test_field_yRatio();
    fn test_field_timing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CUSTOM_DISPLAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timing) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CUSTOM_DISPLAY),
                "::",
                stringify!(timing)
            )
        );
    }
    test_field_timing();
}
impl Default for NV_CUSTOM_DISPLAY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl NV_CUSTOM_DISPLAY {
    #[inline]
    pub fn hwModeSetOnly(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hwModeSetOnly(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(hwModeSetOnly: NvU32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hwModeSetOnly: u32 = unsafe { ::std::mem::transmute(hwModeSetOnly) };
            hwModeSetOnly as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = "! DESCRIPTION:    This API enumerates the custom timing specified by the enum index."]
    #[doc = "!                 The client should keep enumerating until it returns NVAPI_END_ENUMERATION."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 313"]
    #[doc = "!"]
    #[doc = "! \\param [in]     displayId   Dispaly ID of the display."]
    #[doc = "! \\param [in]     index       Enum index"]
    #[doc = "! \\param [inout]  pCustDisp   Pointer to the NV_CUSTOM_DISPLAY structure"]
    #[doc = "!"]
    #[doc = "! \\return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with"]
    #[doc = "!                specific meaning for this API, they are listed below."]
    #[doc = "! \\retval        NVAPI_INVALID_DISPLAY_ID:   Custom Timing is not supported on the Display, whose display id is passed"]
    #[doc = "!"]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_DISP_EnumCustomDisplay(
        displayId: NvU32,
        index: NvU32,
        pCustDisp: *mut NV_CUSTOM_DISPLAY,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:    This API is used to set up a custom display without saving the configuration on multiple displays."]
    #[doc = "!"]
    #[doc = "! \\note"]
    #[doc = "!  All the members of srcPartition, present in NV_CUSTOM_DISPLAY structure, should have their range in (0.0,1.0)."]
    #[doc = "!  In clone mode the timings can applied to both the target monitors but only one target at a time. \\n"]
    #[doc = "!  For the secondary target the applied timings works under the following conditions:"]
    #[doc = "!  - If the secondary monitor EDID supports the selected timing, OR"]
    #[doc = "!  - If the selected custom timings can be scaled by the secondary monitor for the selected source resolution on the primary, OR"]
    #[doc = "!  - If the selected custom timings matches the existing source resolution on the primary."]
    #[doc = "!  Setting up a custom display on non-active but connected monitors is supported only for Win7 and above."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 313"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]    pDisplayIds    Array of the target display Dispaly IDs - See \\ref handles."]
    #[doc = "! \\param [in]    count          Total number of the incoming Display IDs and corresponding NV_CUSTOM_DISPLAY structure. This is for the multi-head support."]
    #[doc = "! \\param [in]    pCustDisp      Pointer to the NV_CUSTOM_DISPLAY structure array."]
    #[doc = "!"]
    #[doc = "! \\return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with"]
    #[doc = "!                specific meaning for this API, they are listed below."]
    #[doc = "! \\retval        NVAPI_INVALID_DISPLAY_ID:   Custom Timing is not supported on the Display, whose display id is passed"]
    #[doc = "!"]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_DISP_TryCustomDisplay(
        pDisplayIds: *mut NvU32,
        count: NvU32,
        pCustDisp: *mut NV_CUSTOM_DISPLAY,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:    This function deletes the custom display configuration, specified from the registry for  all the displays whose display IDs are passed."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 313"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]     pDisplayIds     Array of Dispaly IDs on which custom display configuration is to be saved."]
    #[doc = "! \\param [in]     count           Total number of the incoming Dispaly IDs. This is for the multi-head support."]
    #[doc = "! \\param [in]     pCustDisp       Pointer to the NV_CUSTOM_DISPLAY structure"]
    #[doc = "!"]
    #[doc = "! \\return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with"]
    #[doc = "!                specific meaning for this API, they are listed below."]
    #[doc = "! \\retval        NVAPI_INVALID_DISPLAY_ID:   Custom Timing is not supported on the Display, whose display id is passed"]
    #[doc = "!"]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_DISP_DeleteCustomDisplay(
        pDisplayIds: *mut NvU32,
        count: NvU32,
        pCustDisp: *mut NV_CUSTOM_DISPLAY,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:    This function saves the current hardware display configuration on the specified Display IDs as a custom display configuration."]
    #[doc = "!                 This function should be called right after NvAPI_DISP_TryCustomDisplay() to save the custom display from the current"]
    #[doc = "!                 hardware context. This function will not do anything if the custom display configuration is not tested on the hardware."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 313"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]     pDisplayIds         Array of Dispaly IDs on which custom display configuration is to be saved."]
    #[doc = "! \\param [in]     count               Total number of the incoming Dispaly IDs. This is for the multi-head support."]
    #[doc = "! \\param [in]     isThisOutputIdOnly  If set, the saved custom display will only be applied on the monitor with the same outputId (see \\ref handles)."]
    #[doc = "! \\param [in]     isThisMonitorIdOnly If set, the saved custom display will only be applied on the monitor with the same EDID ID or"]
    #[doc = "!                                     the same TV connector in case of analog TV."]
    #[doc = "!"]
    #[doc = "! \\return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with"]
    #[doc = "!                specific meaning for this API, they are listed below."]
    #[doc = "! \\retval        NVAPI_INVALID_DISPLAY_ID:   Custom Timing is not supported on the Display, whose display id is passed"]
    #[doc = "!"]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_DISP_SaveCustomDisplay(
        pDisplayIds: *mut NvU32,
        count: NvU32,
        isThisOutputIdOnly: NvU32,
        isThisMonitorIdOnly: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:    This API is used to restore the display configuration, that was changed by calling NvAPI_DISP_TryCustomDisplay(). This function"]
    #[doc = "!                 must be called only after a custom display configuration is tested on the hardware, using NvAPI_DISP_TryCustomDisplay(),"]
    #[doc = "!                 otherwise no action is taken. On Vista, NvAPI_DISP_RevertCustomDisplayTrial should be called with an active display that"]
    #[doc = "!                 was affected during the NvAPI_DISP_TryCustomDisplay() call, per GPU."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 313"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]    pDisplayIds   Pointer to display Id, of an active display."]
    #[doc = "! \\param [in]    count         Total number of incoming Display IDs. For future use only. Currently it is expected to be passed as 1."]
    #[doc = "!"]
    #[doc = "! \\return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with"]
    #[doc = "!                specific meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_DISP_RevertCustomDisplayTrial(
        pDisplayIds: *mut NvU32,
        count: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This API lets caller retrieve the target display arrangement for selected source display handle."]
    #[doc = "! \\note Display PATH with this API is limited to single GPU. DUALVIEW across GPUs will be returned as STANDARD VIEW."]
    #[doc = "!       Use NvAPI_SYS_GetDisplayTopologies() to query views across GPUs."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_DISP_GetDisplayConfig."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 85"]
    #[doc = "!"]
    #[doc = "!  \\param [in]     hNvDisplay             NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or a handle enumerated from"]
    #[doc = "!                                         NvAPI_EnumNVidiaDisplayHandle()."]
    #[doc = "!  \\param [out]    pTargets               User allocated storage to retrieve an array of  NV_VIEW_TARGET_INFO. Can be NULL to retrieve"]
    #[doc = "!                                         the targetCount."]
    #[doc = "!  \\param [in,out] targetMaskCount        Count of target device mask specified in pTargetMask."]
    #[doc = "!  \\param [out]    targetView             Target view selected from NV_TARGET_VIEW_MODE."]
    #[doc = "!"]
    #[doc = "!  \\retval         NVAPI_OK               Completed request"]
    #[doc = "!  \\retval         NVAPI_ERROR            Miscellaneous error occurred"]
    #[doc = "!  \\retval         NVAPI_INVALID_ARGUMENT Invalid input parameter."]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_GetView(
        hNvDisplay: NvDisplayHandle,
        pTargets: *mut NV_VIEW_TARGET_INFO,
        pTargetMaskCount: *mut NvU32,
        pTargetView: *mut NV_TARGET_VIEW_MODE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:    This API lets caller retrieve the target display arrangement for selected source display handle."]
    #[doc = "!                 \\note Display PATH with this API is limited to single GPU. DUALVIEW across GPUs will be returned as STANDARD VIEW."]
    #[doc = "!                       Use NvAPI_SYS_GetDisplayTopologies() to query views across GPUs."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_DISP_GetDisplayConfig."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 165"]
    #[doc = "!"]
    #[doc = "! \\param [in]     hNvDisplay       NVIDIA Display selection. #NVAPI_DEFAULT_HANDLE is not allowed, it has to be a handle enumerated with"]
    #[doc = "!                                  NvAPI_EnumNVidiaDisplayHandle()."]
    #[doc = "! \\param [in,out] pPathInfo        Count field should be set to NVAPI_MAX_DISPLAY_PATH. Can be NULL to retrieve just the pathCount."]
    #[doc = "! \\param [in,out] pPathCount       Number of elements in array pPathInfo->path."]
    #[doc = "! \\param [out]    pTargetViewMode  Display view selected from NV_TARGET_VIEW_MODE."]
    #[doc = "!"]
    #[doc = "! \\retval         NVAPI_OK                      Completed request"]
    #[doc = "! \\retval         NVAPI_API_NOT_INTIALIZED      NVAPI not initialized"]
    #[doc = "! \\retval         NVAPI_ERROR                   Miscellaneous error occurred"]
    #[doc = "! \\retval         NVAPI_INVALID_ARGUMENT        Invalid input parameter."]
    #[doc = "! \\retval         NVAPI_EXPECTED_DISPLAY_HANDLE hNvDisplay is not a valid display handle."]
    #[doc = "!"]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_GetViewEx(
        hNvDisplay: NvDisplayHandle,
        pPathInfo: *mut NV_DISPLAY_PATH_INFO,
        pPathCount: *mut NvU32,
        pTargetViewMode: *mut NV_TARGET_VIEW_MODE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This API lets caller enumerate all the supported NVIDIA display views - nView and Dualview modes."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 85"]
    #[doc = "!"]
    #[doc = "!  \\param [in]     hNvDisplay             NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or a handle enumerated from"]
    #[doc = "!                                         NvAPI_EnumNVidiaDisplayHandle()."]
    #[doc = "!  \\param [out]    pTargetViews           Array of supported views. Can be NULL to retrieve the pViewCount first."]
    #[doc = "!  \\param [in,out] pViewCount             Count of supported views."]
    #[doc = "!"]
    #[doc = "!  \\retval         NVAPI_OK               Completed request"]
    #[doc = "!  \\retval         NVAPI_ERROR            Miscellaneous error occurred"]
    #[doc = "!  \\retval         NVAPI_INVALID_ARGUMENT Invalid input parameter."]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_GetSupportedViews(
        hNvDisplay: NvDisplayHandle,
        pTargetViews: *mut NV_TARGET_VIEW_MODE,
        pViewCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API retrieves the Display Id of a given display by"]
    #[doc = "!                  display name. The display must be active to retrieve the"]
    #[doc = "!                  displayId. In the case of clone mode or Surround gaming,"]
    #[doc = "!                  the primary or top-left display will be returned."]
    #[doc = "!"]
    #[doc = "! \\param [in]     displayName  Name of display (Eg: \"\\\\DISPLAY1\" to"]
    #[doc = "!                              retrieve the displayId for."]
    #[doc = "! \\param [out]    displayId    Display ID of the requested display."]
    #[doc = "!"]
    #[doc = "! retval ::NVAPI_OK:                          Capabilties have been returned."]
    #[doc = "! retval ::NVAPI_INVALID_ARGUMENT:            One or more args passed in are invalid."]
    #[doc = "! retval ::NVAPI_API_NOT_INTIALIZED:          The NvAPI API needs to be initialized first"]
    #[doc = "! retval ::NVAPI_NO_IMPLEMENTATION:           This entrypoint not available"]
    #[doc = "! retval ::NVAPI_ERROR:                       Miscellaneous error occurred"]
    #[doc = "!"]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_DISP_GetDisplayIdByDisplayName(
        displayName: *const ::std::os::raw::c_char,
        displayId: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API lets caller retrieve the current global display"]
    #[doc = "!                  configuration."]
    #[doc = "!       USAGE:     The caller might have to call this three times to fetch all the required configuration details as follows:"]
    #[doc = "!                  First  Pass: Caller should Call NvAPI_DISP_GetDisplayConfig() with pathInfo set to NULL to fetch pathInfoCount."]
    #[doc = "!                  Second Pass: Allocate memory for pathInfo with respect to the number of pathInfoCount(from First Pass) to fetch"]
    #[doc = "!                               targetInfoCount. If sourceModeInfo is needed allocate memory or it can be initialized to NULL."]
    #[doc = "!             Third  Pass(Optional, only required if target information is required): Allocate memory for targetInfo with respect"]
    #[doc = "!                               to number of targetInfoCount(from Second Pass)."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in,out]  pathInfoCount    Number of elements in pathInfo array, returns number of valid topologies, this cannot be null."]
    #[doc = "! \\param [in,out]  pathInfo         Array of path information"]
    #[doc = "!"]
    #[doc = "! \\return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with"]
    #[doc = "!            specific meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\retval    NVAPI_INVALID_ARGUMENT  -   Invalid input parameter. Following can be the reason for this return value:"]
    #[doc = "!                                        -# pathInfoCount is NULL."]
    #[doc = "!                                        -# *pathInfoCount is 0 and pathInfo is not NULL."]
    #[doc = "!                                        -# *pathInfoCount is not 0 and pathInfo is NULL."]
    #[doc = "! \\retval    NVAPI_DEVICE_BUSY       -   ModeSet has not yet completed. Please wait and call it again."]
    #[doc = "!"]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_DISP_GetDisplayConfig(
        pathInfoCount: *mut NvU32,
        pathInfo: *mut NV_DISPLAYCONFIG_PATH_INFO,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API lets caller apply a global display configuration"]
    #[doc = "!                  across multiple GPUs."]
    #[doc = "!"]
    #[doc = "!                  If all sourceIds are zero, then NvAPI will pick up sourceId's based on the following criteria :"]
    #[doc = "!                  - If user provides sourceModeInfo then we are trying to assign 0th sourceId always to GDIPrimary."]
    #[doc = "!                     This is needed since active windows always moves along with 0th sourceId."]
    #[doc = "!                  - For rest of the paths, we are incrementally assigning the sourceId per adapter basis."]
    #[doc = "!                  - If user doesn't provide sourceModeInfo then NVAPI just picks up some default sourceId's in incremental order."]
    #[doc = "!                  Note : NVAPI will not intelligently choose the sourceIDs for any configs that does not need a modeset."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]      pathInfoCount   Number of supplied elements in pathInfo"]
    #[doc = "! \\param [in]      pathInfo        Array of path information"]
    #[doc = "! \\param [in]      flags           Flags for applying settings"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK - completed request"]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized"]
    #[doc = "! \\retval ::NVAPI_ERROR - miscellaneous error occurred"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT - Invalid input parameter."]
    #[doc = "!"]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_DISP_SetDisplayConfig(
        pathInfoCount: NvU32,
        pathInfo: *mut NV_DISPLAYCONFIG_PATH_INFO,
        flags: NvU32,
    ) -> NvAPI_Status;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_GET_ADAPTIVE_SYNC_DATA_V1 {
    #[doc = "!< [in]    structure version"]
    pub version: NvU32,
    #[doc = "!< [out]   maximum frame interval in micro seconds as set previously using NvAPI_DISP_SetAdaptiveSyncData function."]
    #[doc = "!<         If default values from EDID are used, this parameter returns 0."]
    pub maxFrameInterval: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< [out]   Number of times the last flip was shown on the screen"]
    pub lastFlipRefreshCount: NvU32,
    #[doc = "!< [out]   Timestamp for the lastest flip on the screen"]
    pub lastFlipTimeStamp: NvU64,
    #[doc = "!< reserved for future use."]
    pub reservedEx: [NvU32; 4usize],
}
#[test]
fn bindgen_test_layout__NV_GET_ADAPTIVE_SYNC_DATA_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GET_ADAPTIVE_SYNC_DATA_V1>(),
        40usize,
        concat!("Size of: ", stringify!(_NV_GET_ADAPTIVE_SYNC_DATA_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GET_ADAPTIVE_SYNC_DATA_V1>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_GET_ADAPTIVE_SYNC_DATA_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GET_ADAPTIVE_SYNC_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GET_ADAPTIVE_SYNC_DATA_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_maxFrameInterval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GET_ADAPTIVE_SYNC_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxFrameInterval) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GET_ADAPTIVE_SYNC_DATA_V1),
                "::",
                stringify!(maxFrameInterval)
            )
        );
    }
    test_field_maxFrameInterval();
    fn test_field_lastFlipRefreshCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GET_ADAPTIVE_SYNC_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lastFlipRefreshCount) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GET_ADAPTIVE_SYNC_DATA_V1),
                "::",
                stringify!(lastFlipRefreshCount)
            )
        );
    }
    test_field_lastFlipRefreshCount();
    fn test_field_lastFlipTimeStamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GET_ADAPTIVE_SYNC_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lastFlipTimeStamp) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GET_ADAPTIVE_SYNC_DATA_V1),
                "::",
                stringify!(lastFlipTimeStamp)
            )
        );
    }
    test_field_lastFlipTimeStamp();
    fn test_field_reservedEx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GET_ADAPTIVE_SYNC_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reservedEx) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GET_ADAPTIVE_SYNC_DATA_V1),
                "::",
                stringify!(reservedEx)
            )
        );
    }
    test_field_reservedEx();
}
impl _NV_GET_ADAPTIVE_SYNC_DATA_V1 {
    #[inline]
    pub fn bDisableAdaptiveSync(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bDisableAdaptiveSync(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bDisableFrameSplitting(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bDisableFrameSplitting(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bDisableAdaptiveSync: NvU32,
        bDisableFrameSplitting: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bDisableAdaptiveSync: u32 = unsafe { ::std::mem::transmute(bDisableAdaptiveSync) };
            bDisableAdaptiveSync as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bDisableFrameSplitting: u32 =
                unsafe { ::std::mem::transmute(bDisableFrameSplitting) };
            bDisableFrameSplitting as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GET_ADAPTIVE_SYNC_DATA_V1 = _NV_GET_ADAPTIVE_SYNC_DATA_V1;
pub type NV_GET_ADAPTIVE_SYNC_DATA = NV_GET_ADAPTIVE_SYNC_DATA_V1;
extern "C" {
    #[doc = "! \\fn NvAPI_DISP_GetAdaptiveSyncData(__in NvU32 displayId, __inout NV_GET_ADAPTIVE_SYNC_DATA *pAdaptiveSyncData)"]
    #[doc = "! \\code"]
    #[doc = "! DESCRIPTION:    This function is used to get data for the Adaptive Sync Display."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 10 and higher"]
    #[doc = "!"]
    #[doc = "! \\since Release: 415"]
    #[doc = "!"]
    #[doc = "! \\param [in]       displayId            - display id of the display"]
    #[doc = "! \\param [inout]    pAdaptiveSyncData    - A pointer to NV_GET_ADAPTIVE_SYNC_DATA, containing the information about the values of parameters that are to be retrieved on given display."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in"]
    #[doc = "!          #NvAPI_Status. If there are return error codes with specific"]
    #[doc = "!          meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\endcode"]
    #[doc = ""]
    #[doc = "! \\ingroup dispcontrol"]
    pub fn NvAPI_DISP_GetAdaptiveSyncData(
        displayId: NvU32,
        pAdaptiveSyncData: *mut NV_GET_ADAPTIVE_SYNC_DATA,
    ) -> NvAPI_Status;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_SET_ADAPTIVE_SYNC_DATA_V1 {
    #[doc = "!< [in]    structure version"]
    pub version: NvU32,
    #[doc = "!< [in]    maximum frame interval in micro seconds."]
    #[doc = "!<         If maxFrameInterval is send as 0, default values from EDID will be used."]
    pub maxFrameInterval: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< reserved for future use."]
    pub reservedEx: [NvU32; 7usize],
}
#[test]
fn bindgen_test_layout__NV_SET_ADAPTIVE_SYNC_DATA_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_SET_ADAPTIVE_SYNC_DATA_V1>(),
        40usize,
        concat!("Size of: ", stringify!(_NV_SET_ADAPTIVE_SYNC_DATA_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_SET_ADAPTIVE_SYNC_DATA_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_SET_ADAPTIVE_SYNC_DATA_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_SET_ADAPTIVE_SYNC_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SET_ADAPTIVE_SYNC_DATA_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_maxFrameInterval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_SET_ADAPTIVE_SYNC_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxFrameInterval) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SET_ADAPTIVE_SYNC_DATA_V1),
                "::",
                stringify!(maxFrameInterval)
            )
        );
    }
    test_field_maxFrameInterval();
    fn test_field_reservedEx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_SET_ADAPTIVE_SYNC_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reservedEx) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SET_ADAPTIVE_SYNC_DATA_V1),
                "::",
                stringify!(reservedEx)
            )
        );
    }
    test_field_reservedEx();
}
impl _NV_SET_ADAPTIVE_SYNC_DATA_V1 {
    #[inline]
    pub fn bDisableAdaptiveSync(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bDisableAdaptiveSync(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bDisableFrameSplitting(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bDisableFrameSplitting(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bDisableAdaptiveSync: NvU32,
        bDisableFrameSplitting: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bDisableAdaptiveSync: u32 = unsafe { ::std::mem::transmute(bDisableAdaptiveSync) };
            bDisableAdaptiveSync as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bDisableFrameSplitting: u32 =
                unsafe { ::std::mem::transmute(bDisableFrameSplitting) };
            bDisableFrameSplitting as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_SET_ADAPTIVE_SYNC_DATA_V1 = _NV_SET_ADAPTIVE_SYNC_DATA_V1;
pub type NV_SET_ADAPTIVE_SYNC_DATA = NV_SET_ADAPTIVE_SYNC_DATA_V1;
extern "C" {
    #[doc = "! \\fn NvAPI_DISP_SetAdaptiveSyncData(__in NvU32 displayId, __in NV_SET_ADAPTIVE_SYNC_DATA *pAdaptiveSyncData)"]
    #[doc = "! \\code"]
    #[doc = "! DESCRIPTION:    This function is used to set data for Adaptive Sync Display."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 10 and higher"]
    #[doc = "!"]
    #[doc = "! \\since Release: 415"]
    #[doc = "!"]
    #[doc = "! \\param [in]       displayId            - display id of the display"]
    #[doc = "! \\param [in]       pAdaptiveSyncData    - A pointer to NV_SET_ADAPTIVE_SYNC_DATA, containing the information about the values of parameters that are to be set on given display."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in"]
    #[doc = "!          #NvAPI_Status. If there are return error codes with specific"]
    #[doc = "!          meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\endcode"]
    #[doc = ""]
    #[doc = "! \\ingroup dispcontrol"]
    pub fn NvAPI_DISP_SetAdaptiveSyncData(
        displayId: NvU32,
        pAdaptiveSyncData: *mut NV_SET_ADAPTIVE_SYNC_DATA,
    ) -> NvAPI_Status;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1 {
    #[doc = "!< [in]    structure version"]
    pub version: NvU32,
    #[doc = "!< [out]   frame interval in micro seconds if Virtual RR is currently applied"]
    pub frameIntervalUs: NvU32,
    #[doc = "!< reserved for future use."]
    pub reservedEx: [NvU32; 8usize],
}
#[test]
fn bindgen_test_layout__NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_frameIntervalUs() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frameIntervalUs) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1),
                "::",
                stringify!(frameIntervalUs)
            )
        );
    }
    test_field_frameIntervalUs();
    fn test_field_reservedEx() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reservedEx) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1),
                "::",
                stringify!(reservedEx)
            )
        );
    }
    test_field_reservedEx();
}
pub type NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1 = _NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1;
pub type NV_GET_VIRTUAL_REFRESH_RATE_DATA = NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1;
extern "C" {
    #[doc = "! \\fn NvAPI_DISP_GetVirtualRefreshRateData(__in NvU32 displayId, __inout NV_GET_VIRTUAL_REFRESH_RATE_DATA *pVirtualRefreshRateData)"]
    #[doc = "! \\code"]
    #[doc = "! DESCRIPTION:    This function is used to get Virtual Refresh Rate data for a VRR Capable Display."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 10 and higher"]
    #[doc = "!"]
    #[doc = "! \\since Release: 510"]
    #[doc = "!"]
    #[doc = "! \\param [in]       displayId                  - display id of the display"]
    #[doc = "! \\param [inout]    pVirtualRefreshRateData    - A pointer to NV_GET_VIRTUAL_REFRESH_RATE_DATA, containing the information about the values of parameters that are to be retrieved on given display."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in"]
    #[doc = "!          #NvAPI_Status. If there are return error codes with specific"]
    #[doc = "!          meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\endcode"]
    #[doc = ""]
    #[doc = "! \\ingroup dispcontrol"]
    pub fn NvAPI_DISP_GetVirtualRefreshRateData(
        displayId: NvU32,
        pVirtualRefreshRateData: *mut NV_GET_VIRTUAL_REFRESH_RATE_DATA,
    ) -> NvAPI_Status;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1 {
    #[doc = "!< [in]   structure version"]
    pub version: NvU32,
    #[doc = "!< [in]   frame interval in micro seconds if Virtual RR is currently applied"]
    pub frameIntervalUs: NvU32,
    #[doc = "!< reserved for future use."]
    pub reservedEx: [NvU32; 8usize],
}
#[test]
fn bindgen_test_layout__NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_frameIntervalUs() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frameIntervalUs) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1),
                "::",
                stringify!(frameIntervalUs)
            )
        );
    }
    test_field_frameIntervalUs();
    fn test_field_reservedEx() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reservedEx) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1),
                "::",
                stringify!(reservedEx)
            )
        );
    }
    test_field_reservedEx();
}
pub type NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1 = _NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1;
pub type NV_SET_VIRTUAL_REFRESH_RATE_DATA = NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1;
extern "C" {
    #[doc = "! \\fn NvAPI_DISP_SetVirtualRefreshRateData(__in NvU32 displayId, __in NV_SET_VIRTUAL_REFRESH_RATE_DATA *pVirtualRefreshRateData)"]
    #[doc = "! \\code"]
    #[doc = "! DESCRIPTION:    This function is used to set Virtual Refresh Rate data for a VRR Capable Display."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 10 and higher"]
    #[doc = "!"]
    #[doc = "! \\since Release: 510"]
    #[doc = "!"]
    #[doc = "! \\param [in]       displayId                  - display id of the display"]
    #[doc = "! \\param [inout]    pVirtualRefreshRateData    - A pointer to NV_SET_VIRTUAL_REFRESH_RATE_DATA, containing the information about the values of parameters that are to be retrieved on given display."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in"]
    #[doc = "!          #NvAPI_Status. If there are return error codes with specific"]
    #[doc = "!          meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\endcode"]
    #[doc = ""]
    #[doc = "! \\ingroup dispcontrol"]
    pub fn NvAPI_DISP_SetVirtualRefreshRateData(
        displayId: NvU32,
        pVirtualRefreshRateData: *mut NV_SET_VIRTUAL_REFRESH_RATE_DATA,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup dispcontrol"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_SET_PREFERRED_STEREO_DISPLAY_V1 {
    #[doc = "!< [in] Structure version"]
    pub version: NvU32,
    #[doc = "!< [in] Monitor Identifier to be set"]
    pub displayId: NvU32,
    #[doc = "!< Reserved for future use without adding versioning"]
    pub reserved: NvU32,
}
#[test]
fn bindgen_test_layout_NV_SET_PREFERRED_STEREO_DISPLAY_V1() {
    assert_eq!(
        ::std::mem::size_of::<NV_SET_PREFERRED_STEREO_DISPLAY_V1>(),
        12usize,
        concat!("Size of: ", stringify!(NV_SET_PREFERRED_STEREO_DISPLAY_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_SET_PREFERRED_STEREO_DISPLAY_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_SET_PREFERRED_STEREO_DISPLAY_V1)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_SET_PREFERRED_STEREO_DISPLAY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_SET_PREFERRED_STEREO_DISPLAY_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_displayId() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_SET_PREFERRED_STEREO_DISPLAY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayId) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_SET_PREFERRED_STEREO_DISPLAY_V1),
                "::",
                stringify!(displayId)
            )
        );
    }
    test_field_displayId();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_SET_PREFERRED_STEREO_DISPLAY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_SET_PREFERRED_STEREO_DISPLAY_V1),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[doc = "! \\ingroup dispcontrol"]
pub type NV_SET_PREFERRED_STEREO_DISPLAY = NV_SET_PREFERRED_STEREO_DISPLAY_V1;
extern "C" {
    #[doc = "! DESCRIPTION: Specifies a display output that drives the 3pin DIN output signal"]
    #[doc = "!              in a workstation stereo system environment."]
    #[doc = "!              If display output is specified as a displayId of 0, the preferred"]
    #[doc = "!              stereo display target is reset to the driver default selection."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 10 and higher"]
    #[doc = "!"]
    #[doc = "! \\since Release: 470"]
    #[doc = "!"]
    #[doc = "! \\param [in]      pPreferredStereoDisplay        Pointer to a NV_SET_PREFERRED_STEREO_DISPLAY structure"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK  completed request"]
    #[doc = "! \\retval ::NVAPI_ERROR  miscellaneous error occurred"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT  Invalid input parameter."]
    #[doc = "! \\retval ::NVAPI_INVALID_USER_PRIVILEGE       - The application will require Administrator privileges to access this API."]
    #[doc = "!                                                The application can be elevated to a higher permission level by selecting \"Run as Administrator\"."]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_DISP_SetPreferredStereoDisplay(
        pPreferredStereoDisplay: *mut NV_SET_PREFERRED_STEREO_DISPLAY,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup dispcontrol"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_GET_PREFERRED_STEREO_DISPLAY_V1 {
    #[doc = "!< [in] Structure version"]
    pub version: NvU32,
    #[doc = "!< [out] The queried stereo display"]
    pub displayId: NvU32,
    #[doc = "!< Reserved for future use without adding versioning"]
    pub reserved: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GET_PREFERRED_STEREO_DISPLAY_V1() {
    assert_eq!(
        ::std::mem::size_of::<NV_GET_PREFERRED_STEREO_DISPLAY_V1>(),
        12usize,
        concat!("Size of: ", stringify!(NV_GET_PREFERRED_STEREO_DISPLAY_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GET_PREFERRED_STEREO_DISPLAY_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GET_PREFERRED_STEREO_DISPLAY_V1)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GET_PREFERRED_STEREO_DISPLAY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GET_PREFERRED_STEREO_DISPLAY_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_displayId() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GET_PREFERRED_STEREO_DISPLAY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayId) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GET_PREFERRED_STEREO_DISPLAY_V1),
                "::",
                stringify!(displayId)
            )
        );
    }
    test_field_displayId();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_GET_PREFERRED_STEREO_DISPLAY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_GET_PREFERRED_STEREO_DISPLAY_V1),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[doc = "! \\ingroup dispcontrol"]
pub type NV_GET_PREFERRED_STEREO_DISPLAY = NV_GET_PREFERRED_STEREO_DISPLAY_V1;
extern "C" {
    #[doc = "! DESCRIPTION: Queries the displayId of the display output driving the 3pin"]
    #[doc = "!              DIN stereo signal, if any."]
    #[doc = "! SUPPORTED OS:  Windows 10 and higher"]
    #[doc = "!"]
    #[doc = "! \\since Release: 470"]
    #[doc = "!"]
    #[doc = "! \\param [inout]     pPreferredStereoDisplay        Pointer to a NV_GET_PREFERRED_STEREO_DISPLAY structure"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK  completed request"]
    #[doc = "! \\retval ::NVAPI_ERROR  miscellaneous error occurred"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT  Invalid input parameter."]
    #[doc = "! \\retval ::NVAPI_INVALID_POINTER   An invalid pointer was passed as an argument (probably NULL)."]
    #[doc = "! \\ingroup dispcontrol"]
    #[doc = ""]
    pub fn NvAPI_DISP_GetPreferredStereoDisplay(
        pPreferredStereoDisplay: *mut NV_GET_PREFERRED_STEREO_DISPLAY,
    ) -> NvAPI_Status;
}
#[doc = "! This structure defines the topology details."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_MOSAIC_TOPO_DETAILS {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Logical GPU for this topology"]
    pub hLogicalGPU: NvLogicalGpuHandle,
    #[doc = "!< 0 means topology is valid with the current hardware."]
    pub validityMask: NvU32,
    #[doc = "!< Number of displays in a row"]
    pub rowCount: NvU32,
    #[doc = "!< Number of displays in a column"]
    pub colCount: NvU32,
    pub gpuLayout: [[NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1; 8usize]; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1 {
    #[doc = "!< Physical GPU to be used in the topology (0 if GPU missing)"]
    pub hPhysicalGPU: NvPhysicalGpuHandle,
    #[doc = "!< Connected display target (0 if no display connected)"]
    pub displayOutputId: NvU32,
    #[doc = "!< Pixels of overlap on left of target: (+overlap, -gap)"]
    pub overlapX: NvS32,
    #[doc = "!< Pixels of overlap on top of target: (+overlap, -gap)"]
    pub overlapY: NvS32,
}
#[test]
fn bindgen_test_layout_NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1)
        )
    );
    fn test_field_hPhysicalGPU() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hPhysicalGPU) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1),
                "::",
                stringify!(hPhysicalGPU)
            )
        );
    }
    test_field_hPhysicalGPU();
    fn test_field_displayOutputId() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayOutputId) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1),
                "::",
                stringify!(displayOutputId)
            )
        );
    }
    test_field_displayOutputId();
    fn test_field_overlapX() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).overlapX) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1),
                "::",
                stringify!(overlapX)
            )
        );
    }
    test_field_overlapX();
    fn test_field_overlapY() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).overlapY) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1),
                "::",
                stringify!(overlapY)
            )
        );
    }
    test_field_overlapY();
}
impl Default for NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NV_MOSAIC_TOPO_DETAILS() {
    assert_eq!(
        ::std::mem::size_of::<NV_MOSAIC_TOPO_DETAILS>(),
        1568usize,
        concat!("Size of: ", stringify!(NV_MOSAIC_TOPO_DETAILS))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_MOSAIC_TOPO_DETAILS>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_MOSAIC_TOPO_DETAILS))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPO_DETAILS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPO_DETAILS),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_hLogicalGPU() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPO_DETAILS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hLogicalGPU) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPO_DETAILS),
                "::",
                stringify!(hLogicalGPU)
            )
        );
    }
    test_field_hLogicalGPU();
    fn test_field_validityMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPO_DETAILS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).validityMask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPO_DETAILS),
                "::",
                stringify!(validityMask)
            )
        );
    }
    test_field_validityMask();
    fn test_field_rowCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPO_DETAILS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rowCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPO_DETAILS),
                "::",
                stringify!(rowCount)
            )
        );
    }
    test_field_rowCount();
    fn test_field_colCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPO_DETAILS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colCount) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPO_DETAILS),
                "::",
                stringify!(colCount)
            )
        );
    }
    test_field_colCount();
    fn test_field_gpuLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPO_DETAILS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gpuLayout) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPO_DETAILS),
                "::",
                stringify!(gpuLayout)
            )
        );
    }
    test_field_gpuLayout();
}
impl Default for NV_MOSAIC_TOPO_DETAILS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "!< All mosaic topologies"]
pub const NV_MOSAIC_TOPO_TYPE_NV_MOSAIC_TOPO_TYPE_ALL: NV_MOSAIC_TOPO_TYPE = 0;
#[doc = "!< Basic Mosaic topologies"]
pub const NV_MOSAIC_TOPO_TYPE_NV_MOSAIC_TOPO_TYPE_BASIC: NV_MOSAIC_TOPO_TYPE = 1;
#[doc = "!< Passive Stereo topologies"]
pub const NV_MOSAIC_TOPO_TYPE_NV_MOSAIC_TOPO_TYPE_PASSIVE_STEREO: NV_MOSAIC_TOPO_TYPE = 2;
#[doc = "!< Not supported at this time"]
pub const NV_MOSAIC_TOPO_TYPE_NV_MOSAIC_TOPO_TYPE_SCALED_CLONE: NV_MOSAIC_TOPO_TYPE = 3;
#[doc = "!< Not supported at this time"]
pub const NV_MOSAIC_TOPO_TYPE_NV_MOSAIC_TOPO_TYPE_PASSIVE_STEREO_SCALED_CLONE: NV_MOSAIC_TOPO_TYPE =
    4;
#[doc = "!< Always leave this at end of the enum"]
pub const NV_MOSAIC_TOPO_TYPE_NV_MOSAIC_TOPO_TYPE_MAX: NV_MOSAIC_TOPO_TYPE = 5;
#[doc = "! These values refer to the different types of Mosaic topologies that are possible.  When"]
#[doc = "! getting the supported Mosaic topologies, you can specify one of these types to narrow down"]
#[doc = "! the returned list to only those that match the given type."]
pub type NV_MOSAIC_TOPO_TYPE = ::std::os::raw::c_int;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_NONE: NV_MOSAIC_TOPO = 0;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_BEGIN_BASIC: NV_MOSAIC_TOPO = 1;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_1x2_BASIC: NV_MOSAIC_TOPO = 1;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_2x1_BASIC: NV_MOSAIC_TOPO = 2;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_1x3_BASIC: NV_MOSAIC_TOPO = 3;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_3x1_BASIC: NV_MOSAIC_TOPO = 4;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_1x4_BASIC: NV_MOSAIC_TOPO = 5;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_4x1_BASIC: NV_MOSAIC_TOPO = 6;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_2x2_BASIC: NV_MOSAIC_TOPO = 7;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_2x3_BASIC: NV_MOSAIC_TOPO = 8;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_2x4_BASIC: NV_MOSAIC_TOPO = 9;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_3x2_BASIC: NV_MOSAIC_TOPO = 10;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_4x2_BASIC: NV_MOSAIC_TOPO = 11;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_1x5_BASIC: NV_MOSAIC_TOPO = 12;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_1x6_BASIC: NV_MOSAIC_TOPO = 13;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_7x1_BASIC: NV_MOSAIC_TOPO = 14;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_END_BASIC: NV_MOSAIC_TOPO = 23;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_BEGIN_PASSIVE_STEREO: NV_MOSAIC_TOPO = 24;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_1x2_PASSIVE_STEREO: NV_MOSAIC_TOPO = 24;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_2x1_PASSIVE_STEREO: NV_MOSAIC_TOPO = 25;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_1x3_PASSIVE_STEREO: NV_MOSAIC_TOPO = 26;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_3x1_PASSIVE_STEREO: NV_MOSAIC_TOPO = 27;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_1x4_PASSIVE_STEREO: NV_MOSAIC_TOPO = 28;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_4x1_PASSIVE_STEREO: NV_MOSAIC_TOPO = 29;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_2x2_PASSIVE_STEREO: NV_MOSAIC_TOPO = 30;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_END_PASSIVE_STEREO: NV_MOSAIC_TOPO = 34;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_MAX: NV_MOSAIC_TOPO = 35;
#[doc = "! This is a complete list of supported Mosaic topologies."]
#[doc = "!"]
#[doc = "! Using a \"Basic\" topology combines multiple monitors to create a single desktop."]
#[doc = "!"]
#[doc = "! Using a \"Passive\" topology combines multiples monitors to create a passive stereo desktop."]
#[doc = "! In passive stereo, two identical topologies combine - one topology is used for the right eye and the other identical //! topology (targeting different displays) is used for the left eye.  \\n"]
#[doc = "! NOTE: common\\inc\\nvEscDef.h shadows a couple PASSIVE_STEREO enums.  If this"]
#[doc = "!       enum list changes and effects the value of NV_MOSAIC_TOPO_BEGIN_PASSIVE_STEREO"]
#[doc = "!       please update the corresponding value in nvEscDef.h"]
pub type NV_MOSAIC_TOPO = ::std::os::raw::c_int;
#[doc = "! This is a \"topology brief\" structure.  It tells you what you need to know about"]
#[doc = "! a topology at a high level. A list of these is returned when you query for the"]
#[doc = "! supported Mosaic information."]
#[doc = "!"]
#[doc = "! If you need more detailed information about the topology, call"]
#[doc = "! NvAPI_Mosaic_GetTopoGroup() with the topology value from this structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_MOSAIC_TOPO_BRIEF {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< The topology"]
    pub topo: NV_MOSAIC_TOPO,
    #[doc = "!< 1 if topo is enabled, else 0"]
    pub enabled: NvU32,
    #[doc = "!< 1 if topo *can* be enabled, else 0"]
    pub isPossible: NvU32,
}
#[test]
fn bindgen_test_layout_NV_MOSAIC_TOPO_BRIEF() {
    assert_eq!(
        ::std::mem::size_of::<NV_MOSAIC_TOPO_BRIEF>(),
        16usize,
        concat!("Size of: ", stringify!(NV_MOSAIC_TOPO_BRIEF))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_MOSAIC_TOPO_BRIEF>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_MOSAIC_TOPO_BRIEF))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPO_BRIEF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPO_BRIEF),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_topo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPO_BRIEF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).topo) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPO_BRIEF),
                "::",
                stringify!(topo)
            )
        );
    }
    test_field_topo();
    fn test_field_enabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPO_BRIEF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPO_BRIEF),
                "::",
                stringify!(enabled)
            )
        );
    }
    test_field_enabled();
    fn test_field_isPossible() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPO_BRIEF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).isPossible) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPO_BRIEF),
                "::",
                stringify!(isPossible)
            )
        );
    }
    test_field_isPossible();
}
impl Default for NV_MOSAIC_TOPO_BRIEF {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Basic per-display settings that are used in setting/getting the Mosaic mode"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_MOSAIC_DISPLAY_SETTING_V1 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Per-display width"]
    pub width: NvU32,
    #[doc = "!< Per-display height"]
    pub height: NvU32,
    #[doc = "!< Bits per pixel"]
    pub bpp: NvU32,
    #[doc = "!< Display frequency"]
    pub freq: NvU32,
}
#[test]
fn bindgen_test_layout__NV_MOSAIC_DISPLAY_SETTING_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_MOSAIC_DISPLAY_SETTING_V1>(),
        20usize,
        concat!("Size of: ", stringify!(_NV_MOSAIC_DISPLAY_SETTING_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MOSAIC_DISPLAY_SETTING_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_MOSAIC_DISPLAY_SETTING_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_DISPLAY_SETTING_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_DISPLAY_SETTING_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_DISPLAY_SETTING_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_DISPLAY_SETTING_V1),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_DISPLAY_SETTING_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_DISPLAY_SETTING_V1),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_bpp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_DISPLAY_SETTING_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bpp) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_DISPLAY_SETTING_V1),
                "::",
                stringify!(bpp)
            )
        );
    }
    test_field_bpp();
    fn test_field_freq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_DISPLAY_SETTING_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).freq) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_DISPLAY_SETTING_V1),
                "::",
                stringify!(freq)
            )
        );
    }
    test_field_freq();
}
#[doc = "! Basic per-display settings that are used in setting/getting the Mosaic mode"]
pub type NV_MOSAIC_DISPLAY_SETTING_V1 = _NV_MOSAIC_DISPLAY_SETTING_V1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_MOSAIC_DISPLAY_SETTING_V2 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Per-display width"]
    pub width: NvU32,
    #[doc = "!< Per-display height"]
    pub height: NvU32,
    #[doc = "!< Bits per pixel"]
    pub bpp: NvU32,
    #[doc = "!< Display frequency"]
    pub freq: NvU32,
    #[doc = "!< Display frequency in x1k"]
    pub rrx1k: NvU32,
}
#[test]
fn bindgen_test_layout_NV_MOSAIC_DISPLAY_SETTING_V2() {
    assert_eq!(
        ::std::mem::size_of::<NV_MOSAIC_DISPLAY_SETTING_V2>(),
        24usize,
        concat!("Size of: ", stringify!(NV_MOSAIC_DISPLAY_SETTING_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_MOSAIC_DISPLAY_SETTING_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_MOSAIC_DISPLAY_SETTING_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_DISPLAY_SETTING_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_DISPLAY_SETTING_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_DISPLAY_SETTING_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_DISPLAY_SETTING_V2),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_DISPLAY_SETTING_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_DISPLAY_SETTING_V2),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_bpp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_DISPLAY_SETTING_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bpp) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_DISPLAY_SETTING_V2),
                "::",
                stringify!(bpp)
            )
        );
    }
    test_field_bpp();
    fn test_field_freq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_DISPLAY_SETTING_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).freq) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_DISPLAY_SETTING_V2),
                "::",
                stringify!(freq)
            )
        );
    }
    test_field_freq();
    fn test_field_rrx1k() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_DISPLAY_SETTING_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rrx1k) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_DISPLAY_SETTING_V2),
                "::",
                stringify!(rrx1k)
            )
        );
    }
    test_field_rrx1k();
}
pub type NV_MOSAIC_DISPLAY_SETTING = NV_MOSAIC_DISPLAY_SETTING_V2;
#[doc = "! This structure is used to contain a list of supported Mosaic topologies"]
#[doc = "! along with the display settings that can be used."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MOSAIC_SUPPORTED_TOPO_INFO_V1 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Number of topologies in below array"]
    pub topoBriefsCount: NvU32,
    #[doc = "!< List of supported topologies with only brief details"]
    pub topoBriefs: [NV_MOSAIC_TOPO_BRIEF; 35usize],
    #[doc = "!< Number of display settings in below array"]
    pub displaySettingsCount: NvU32,
    #[doc = "!< List of per display settings possible"]
    pub displaySettings: [NV_MOSAIC_DISPLAY_SETTING_V1; 40usize],
}
#[test]
fn bindgen_test_layout__NV_MOSAIC_SUPPORTED_TOPO_INFO_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1>(),
        1372usize,
        concat!("Size of: ", stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_topoBriefsCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).topoBriefsCount) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1),
                "::",
                stringify!(topoBriefsCount)
            )
        );
    }
    test_field_topoBriefsCount();
    fn test_field_topoBriefs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).topoBriefs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1),
                "::",
                stringify!(topoBriefs)
            )
        );
    }
    test_field_topoBriefs();
    fn test_field_displaySettingsCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displaySettingsCount) as usize - ptr as usize
            },
            568usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1),
                "::",
                stringify!(displaySettingsCount)
            )
        );
    }
    test_field_displaySettingsCount();
    fn test_field_displaySettings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displaySettings) as usize - ptr as usize
            },
            572usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1),
                "::",
                stringify!(displaySettings)
            )
        );
    }
    test_field_displaySettings();
}
impl Default for _NV_MOSAIC_SUPPORTED_TOPO_INFO_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! This structure is used to contain a list of supported Mosaic topologies"]
#[doc = "! along with the display settings that can be used."]
pub type NV_MOSAIC_SUPPORTED_TOPO_INFO_V1 = _NV_MOSAIC_SUPPORTED_TOPO_INFO_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MOSAIC_SUPPORTED_TOPO_INFO_V2 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Number of topologies in below array"]
    pub topoBriefsCount: NvU32,
    #[doc = "!< List of supported topologies with only brief details"]
    pub topoBriefs: [NV_MOSAIC_TOPO_BRIEF; 35usize],
    #[doc = "!< Number of display settings in below array"]
    pub displaySettingsCount: NvU32,
    #[doc = "!< List of per display settings possible"]
    pub displaySettings: [NV_MOSAIC_DISPLAY_SETTING_V2; 40usize],
}
#[test]
fn bindgen_test_layout__NV_MOSAIC_SUPPORTED_TOPO_INFO_V2() {
    assert_eq!(
        ::std::mem::size_of::<_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2>(),
        1532usize,
        concat!("Size of: ", stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_topoBriefsCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).topoBriefsCount) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2),
                "::",
                stringify!(topoBriefsCount)
            )
        );
    }
    test_field_topoBriefsCount();
    fn test_field_topoBriefs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).topoBriefs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2),
                "::",
                stringify!(topoBriefs)
            )
        );
    }
    test_field_topoBriefs();
    fn test_field_displaySettingsCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displaySettingsCount) as usize - ptr as usize
            },
            568usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2),
                "::",
                stringify!(displaySettingsCount)
            )
        );
    }
    test_field_displaySettingsCount();
    fn test_field_displaySettings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displaySettings) as usize - ptr as usize
            },
            572usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2),
                "::",
                stringify!(displaySettings)
            )
        );
    }
    test_field_displaySettings();
}
impl Default for _NV_MOSAIC_SUPPORTED_TOPO_INFO_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_MOSAIC_SUPPORTED_TOPO_INFO_V2 = _NV_MOSAIC_SUPPORTED_TOPO_INFO_V2;
pub type NV_MOSAIC_SUPPORTED_TOPO_INFO = NV_MOSAIC_SUPPORTED_TOPO_INFO_V2;
#[doc = "! This structure defines a group of topologies that work together to create one"]
#[doc = "! overall layout.  All of the supported topologies are represented with this"]
#[doc = "! structure."]
#[doc = "!"]
#[doc = "! For example, a 'Passive Stereo' topology would be represented with this"]
#[doc = "! structure, and would have separate topology details for the left and right eyes."]
#[doc = "! The count would be 2.  A 'Basic' topology is also represented by this structure,"]
#[doc = "! with a count of 1."]
#[doc = "!"]
#[doc = "! The structure is primarily used internally, but is exposed to applications in a"]
#[doc = "! read-only fashion because there are some details in it that might be useful"]
#[doc = "! (like the number of rows/cols, or connected display information).  A user can"]
#[doc = "! get the filled-in structure by calling NvAPI_Mosaic_GetTopoGroup()."]
#[doc = "!"]
#[doc = "! You can then look at the detailed values within the structure.  There are no"]
#[doc = "! entrypoints which take this structure as input (effectively making it read-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_MOSAIC_TOPO_GROUP {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< The brief details of this topo"]
    pub brief: NV_MOSAIC_TOPO_BRIEF,
    #[doc = "!< Number of topos in array below"]
    pub count: NvU32,
    pub topos: [NV_MOSAIC_TOPO_DETAILS; 2usize],
}
#[test]
fn bindgen_test_layout_NV_MOSAIC_TOPO_GROUP() {
    assert_eq!(
        ::std::mem::size_of::<NV_MOSAIC_TOPO_GROUP>(),
        3160usize,
        concat!("Size of: ", stringify!(NV_MOSAIC_TOPO_GROUP))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_MOSAIC_TOPO_GROUP>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_MOSAIC_TOPO_GROUP))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPO_GROUP>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPO_GROUP),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_brief() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPO_GROUP>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).brief) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPO_GROUP),
                "::",
                stringify!(brief)
            )
        );
    }
    test_field_brief();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPO_GROUP>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPO_GROUP),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_topos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPO_GROUP>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).topos) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPO_GROUP),
                "::",
                stringify!(topos)
            )
        );
    }
    test_field_topos();
}
impl Default for NV_MOSAIC_TOPO_GROUP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "! \\retval ::NVAPI_ERROR:                      Miscellaneous error occurred."]
    #[doc = "!"]
    #[doc = "! \\ingroup mosaicapi"]
    #[doc = ""]
    pub fn NvAPI_Mosaic_GetSupportedTopoInfo(
        pSupportedTopoInfo: *mut NV_MOSAIC_SUPPORTED_TOPO_INFO,
        type_: NV_MOSAIC_TOPO_TYPE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! \\retval ::NVAPI_ERROR:                      Miscellaneous error occurred."]
    #[doc = "!"]
    #[doc = "! \\ingroup mosaicapi"]
    #[doc = ""]
    pub fn NvAPI_Mosaic_GetTopoGroup(
        pTopoBrief: *mut NV_MOSAIC_TOPO_BRIEF,
        pTopoGroup: *mut NV_MOSAIC_TOPO_GROUP,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API returns the X and Y overlap limits required if"]
    #[doc = "!                  the given Mosaic topology and display settings are to be used."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 185"]
    #[doc = "!"]
    #[doc = "! \\param [in]   pTopoBrief          The topology for getting limits"]
    #[doc = "!                                   This must be one of the topo briefs"]
    #[doc = "!                                   returned from NvAPI_Mosaic_GetSupportedTopoInfo()."]
    #[doc = "! \\param [in]   pDisplaySetting     The display settings for getting the limits."]
    #[doc = "!                                   This must be one of the settings"]
    #[doc = "!                                   returned from NvAPI_Mosaic_GetSupportedTopoInfo()."]
    #[doc = "! \\param [out]  pMinOverlapX        X overlap minimum"]
    #[doc = "! \\param [out]  pMaxOverlapX        X overlap maximum"]
    #[doc = "! \\param [out]  pMinOverlapY        Y overlap minimum"]
    #[doc = "! \\param [out]  pMaxOverlapY        Y overlap maximum"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                          Details were retrieved successfully."]
    #[doc = "! \\retval ::NVAPI_NOT_SUPPORTED               Mosaic is not supported with the existing hardware."]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT            One or more argumentss passed in are invalid."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first."]
    #[doc = "! \\retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available."]
    #[doc = "! \\retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION The version of the structure passed in is not"]
    #[doc = "!                                             compatible with this entry point."]
    #[doc = "! \\retval ::NVAPI_ERROR                       Miscellaneous error occurred."]
    #[doc = "!"]
    #[doc = "! \\ingroup mosaicapi"]
    #[doc = ""]
    pub fn NvAPI_Mosaic_GetOverlapLimits(
        pTopoBrief: *mut NV_MOSAIC_TOPO_BRIEF,
        pDisplaySetting: *mut NV_MOSAIC_DISPLAY_SETTING,
        pMinOverlapX: *mut NvS32,
        pMaxOverlapX: *mut NvS32,
        pMinOverlapY: *mut NvS32,
        pMaxOverlapY: *mut NvS32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API sets the Mosaic topology and performs a mode switch"]
    #[doc = "!                  using the given display settings."]
    #[doc = "!"]
    #[doc = "!                  If NVAPI_OK is returned, the current Mosaic topology was set"]
    #[doc = "!                  correctly.  Any other status returned means the"]
    #[doc = "!                  topology was not set, and remains what it was before this"]
    #[doc = "!                  function was called."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 185"]
    #[doc = "!"]
    #[doc = "! \\param [in]     pTopoBrief        The topology to set. This must be one of the topologies returned from"]
    #[doc = "!                                   NvAPI_Mosaic_GetSupportedTopoInfo(), and it must have an isPossible value of 1."]
    #[doc = "! \\param [in]     pDisplaySetting   The per display settings to be used in the Mosaic mode. This must be one of the"]
    #[doc = "!                                   settings returned from NvAPI_Mosaic_GetSupportedTopoInfo()."]
    #[doc = "! \\param [in]     overlapX          The pixel overlap to use between horizontal displays (use positive a number for"]
    #[doc = "!                                   overlap, or a negative number to create a gap.) If the overlap is out of bounds"]
    #[doc = "!                                   for what is possible given the topo and display setting, the overlap will be clamped."]
    #[doc = "! \\param [in]     overlapY          The pixel overlap to use between vertical displays (use positive a number for"]
    #[doc = "!                                   overlap, or a negative number to create a gap.) If the overlap is out of bounds for"]
    #[doc = "!                                   what is possible given the topo and display setting, the overlap will be clamped."]
    #[doc = "! \\param [in]     enable            If 1, the topology being set will also be enabled, meaning that the mode set will"]
    #[doc = "!                                   occur.  \\n"]
    #[doc = "!                                   If 0, you don't want to be in Mosaic mode right now, but want to set the current"]
    #[doc = "!                                   Mosaic topology so you can enable it later with NvAPI_Mosaic_EnableCurrentTopo()."]
    #[doc = "!"]
    #[doc = "! \\retval  ::NVAPI_OK                          The Mosaic topology was set."]
    #[doc = "! \\retval  ::NVAPI_NOT_SUPPORTED               Mosaic is not supported with the existing hardware."]
    #[doc = "! \\retval  ::NVAPI_INVALID_ARGUMENT            One or more argumentss passed in are invalid."]
    #[doc = "! \\retval  ::NVAPI_TOPO_NOT_POSSIBLE           The topology passed in is not currently possible."]
    #[doc = "! \\retval  ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first."]
    #[doc = "! \\retval  ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available."]
    #[doc = "! \\retval  ::NVAPI_INCOMPATIBLE_STRUCT_VERSION The version of the structure passed in is not"]
    #[doc = "!                                              compatible with this entrypoint."]
    #[doc = "! \\retval  ::NVAPI_MODE_CHANGE_FAILED          There was an error changing the display mode."]
    #[doc = "! \\retval  ::NVAPI_ERROR                       Miscellaneous error occurred."]
    #[doc = "!"]
    #[doc = "! \\ingroup mosaicapi"]
    #[doc = ""]
    pub fn NvAPI_Mosaic_SetCurrentTopo(
        pTopoBrief: *mut NV_MOSAIC_TOPO_BRIEF,
        pDisplaySetting: *mut NV_MOSAIC_DISPLAY_SETTING,
        overlapX: NvS32,
        overlapY: NvS32,
        enable: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API returns information for the current Mosaic topology."]
    #[doc = "!                  This includes topology, display settings, and overlap values."]
    #[doc = "!"]
    #[doc = "!                  You can call NvAPI_Mosaic_GetTopoGroup() with the topology"]
    #[doc = "!                  if you require more information."]
    #[doc = "!"]
    #[doc = "!                  If there isn't a current topology, then pTopoBrief->topo will"]
    #[doc = "!                  be NV_MOSAIC_TOPO_NONE."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 185"]
    #[doc = "!"]
    #[doc = "! \\param [out]     pTopoBrief       The current Mosaic topology"]
    #[doc = "! \\param [out]     pDisplaySetting  The current per-display settings"]
    #[doc = "! \\param [out]     pOverlapX        The pixel overlap between horizontal displays"]
    #[doc = "! \\param [out]     pOverlapY        The pixel overlap between vertical displays"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                          Success getting current info."]
    #[doc = "! \\retval ::NVAPI_NOT_SUPPORTED               Mosaic is not supported with the existing hardware."]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT            One or more argumentss passed in are invalid."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first."]
    #[doc = "! \\retval ::NVAPI_NO_IMPLEMENTATION           This entry point not available."]
    #[doc = "! \\retval ::NVAPI_ERROR                       Miscellaneous error occurred."]
    #[doc = "!"]
    #[doc = "! \\ingroup mosaicapi"]
    #[doc = ""]
    pub fn NvAPI_Mosaic_GetCurrentTopo(
        pTopoBrief: *mut NV_MOSAIC_TOPO_BRIEF,
        pDisplaySetting: *mut NV_MOSAIC_DISPLAY_SETTING,
        pOverlapX: *mut NvS32,
        pOverlapY: *mut NvS32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API enables or disables the current Mosaic topology"]
    #[doc = "!                  based on the setting of the incoming 'enable' parameter."]
    #[doc = "!"]
    #[doc = "!                  An \"enable\" setting enables the current (previously set) Mosaic topology."]
    #[doc = "!                  Note that when the current Mosaic topology is retrieved, it must have an isPossible value of 1 or"]
    #[doc = "!                  an error will occur."]
    #[doc = "!"]
    #[doc = "!                  A \"disable\" setting disables the current Mosaic topology."]
    #[doc = "!                  The topology information will persist, even across reboots."]
    #[doc = "!                  To re-enable the Mosaic topology, call this function"]
    #[doc = "!                  again with the enable parameter set to 1."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 185"]
    #[doc = "!"]
    #[doc = "! \\param [in]   enable               1 to enable the current Mosaic topo, 0 to disable it."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                 The Mosaic topo was enabled/disabled."]
    #[doc = "! \\retval ::NVAPI_NOT_SUPPORTED      Mosaic is not supported with the existing hardware."]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT   One or more arguments passed in are invalid."]
    #[doc = "! \\retval ::NVAPI_TOPO_NOT_POSSIBLE  The current topology is not currently possible."]
    #[doc = "! \\retval ::NVAPI_MODE_CHANGE_FAILED There was an error changing the display mode."]
    #[doc = "! \\retval ::NVAPI_ERROR:             Miscellaneous error occurred."]
    #[doc = "!"]
    #[doc = "! \\ingroup mosaicapi"]
    #[doc = ""]
    pub fn NvAPI_Mosaic_EnableCurrentTopo(enable: NvU32) -> NvAPI_Status;
}
#[doc = "! \\ingroup mosaicapi"]
#[doc = "! @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MOSAIC_GRID_TOPO_DISPLAY_V1 {
    #[doc = "!< DisplayID of the display"]
    pub displayId: NvU32,
    #[doc = "!< (+overlap, -gap)"]
    pub overlapX: NvS32,
    #[doc = "!< (+overlap, -gap)"]
    pub overlapY: NvS32,
    #[doc = "!< Rotation of display"]
    pub rotation: NV_ROTATE,
    #[doc = "!< Reserved, must be 0"]
    pub cloneGroup: NvU32,
}
#[test]
fn bindgen_test_layout__NV_MOSAIC_GRID_TOPO_DISPLAY_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_MOSAIC_GRID_TOPO_DISPLAY_V1>(),
        20usize,
        concat!("Size of: ", stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MOSAIC_GRID_TOPO_DISPLAY_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V1))
    );
    fn test_field_displayId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_DISPLAY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayId) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V1),
                "::",
                stringify!(displayId)
            )
        );
    }
    test_field_displayId();
    fn test_field_overlapX() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_DISPLAY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).overlapX) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V1),
                "::",
                stringify!(overlapX)
            )
        );
    }
    test_field_overlapX();
    fn test_field_overlapY() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_DISPLAY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).overlapY) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V1),
                "::",
                stringify!(overlapY)
            )
        );
    }
    test_field_overlapY();
    fn test_field_rotation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_DISPLAY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rotation) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V1),
                "::",
                stringify!(rotation)
            )
        );
    }
    test_field_rotation();
    fn test_field_cloneGroup() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_DISPLAY_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cloneGroup) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V1),
                "::",
                stringify!(cloneGroup)
            )
        );
    }
    test_field_cloneGroup();
}
impl Default for _NV_MOSAIC_GRID_TOPO_DISPLAY_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup mosaicapi"]
#[doc = "! @{"]
pub type NV_MOSAIC_GRID_TOPO_DISPLAY_V1 = _NV_MOSAIC_GRID_TOPO_DISPLAY_V1;
#[doc = "!< No pixel shift will be applied to this display."]
pub const _NV_PIXEL_SHIFT_TYPE_NV_PIXEL_SHIFT_TYPE_NO_PIXEL_SHIFT: _NV_PIXEL_SHIFT_TYPE = 0;
#[doc = "!< This display will be used to scanout top left pixels in 2x2 PixelShift configuration"]
pub const _NV_PIXEL_SHIFT_TYPE_NV_PIXEL_SHIFT_TYPE_2x2_TOP_LEFT_PIXELS: _NV_PIXEL_SHIFT_TYPE = 1;
#[doc = "!< This display will be used to scanout bottom right pixels in 2x2 PixelShift configuration"]
pub const _NV_PIXEL_SHIFT_TYPE_NV_PIXEL_SHIFT_TYPE_2x2_BOTTOM_RIGHT_PIXELS: _NV_PIXEL_SHIFT_TYPE =
    2;
#[doc = "!< This display will be used to scanout top right pixels in 2x2 PixelShift configuration"]
pub const _NV_PIXEL_SHIFT_TYPE_NV_PIXEL_SHIFT_TYPE_2x2_TOP_RIGHT_PIXELS: _NV_PIXEL_SHIFT_TYPE = 4;
#[doc = "!< This display will be used to scanout bottom left pixels in 2x2 PixelShift configuration"]
pub const _NV_PIXEL_SHIFT_TYPE_NV_PIXEL_SHIFT_TYPE_2x2_BOTTOM_LEFT_PIXELS: _NV_PIXEL_SHIFT_TYPE = 8;
pub type _NV_PIXEL_SHIFT_TYPE = ::std::os::raw::c_int;
pub use self::_NV_PIXEL_SHIFT_TYPE as NV_PIXEL_SHIFT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MOSAIC_GRID_TOPO_DISPLAY_V2 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< DisplayID of the display"]
    pub displayId: NvU32,
    #[doc = "!< (+overlap, -gap)"]
    pub overlapX: NvS32,
    #[doc = "!< (+overlap, -gap)"]
    pub overlapY: NvS32,
    #[doc = "!< Rotation of display"]
    pub rotation: NV_ROTATE,
    #[doc = "!< Reserved, must be 0"]
    pub cloneGroup: NvU32,
    #[doc = "!< Type of the pixel shift enabled display"]
    pub pixelShiftType: NV_PIXEL_SHIFT_TYPE,
}
#[test]
fn bindgen_test_layout__NV_MOSAIC_GRID_TOPO_DISPLAY_V2() {
    assert_eq!(
        ::std::mem::size_of::<_NV_MOSAIC_GRID_TOPO_DISPLAY_V2>(),
        28usize,
        concat!("Size of: ", stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MOSAIC_GRID_TOPO_DISPLAY_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_DISPLAY_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_displayId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_DISPLAY_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayId) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V2),
                "::",
                stringify!(displayId)
            )
        );
    }
    test_field_displayId();
    fn test_field_overlapX() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_DISPLAY_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).overlapX) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V2),
                "::",
                stringify!(overlapX)
            )
        );
    }
    test_field_overlapX();
    fn test_field_overlapY() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_DISPLAY_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).overlapY) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V2),
                "::",
                stringify!(overlapY)
            )
        );
    }
    test_field_overlapY();
    fn test_field_rotation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_DISPLAY_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rotation) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V2),
                "::",
                stringify!(rotation)
            )
        );
    }
    test_field_rotation();
    fn test_field_cloneGroup() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_DISPLAY_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cloneGroup) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V2),
                "::",
                stringify!(cloneGroup)
            )
        );
    }
    test_field_cloneGroup();
    fn test_field_pixelShiftType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_DISPLAY_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixelShiftType) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V2),
                "::",
                stringify!(pixelShiftType)
            )
        );
    }
    test_field_pixelShiftType();
}
impl Default for _NV_MOSAIC_GRID_TOPO_DISPLAY_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_MOSAIC_GRID_TOPO_DISPLAY_V2 = _NV_MOSAIC_GRID_TOPO_DISPLAY_V2;
#[doc = "! \\ingroup mosaicapi"]
#[doc = "! @{"]
pub type NV_MOSAIC_GRID_TOPO_DISPLAY = NV_MOSAIC_GRID_TOPO_DISPLAY_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MOSAIC_GRID_TOPO_V1 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Number of rows"]
    pub rows: NvU32,
    #[doc = "!< Number of columns"]
    pub columns: NvU32,
    #[doc = "!< Number of display details"]
    pub displayCount: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Displays are done as [(row * columns) + column]"]
    pub displays: [NV_MOSAIC_GRID_TOPO_DISPLAY_V1; 64usize],
    #[doc = "!< Display settings"]
    pub displaySettings: NV_MOSAIC_DISPLAY_SETTING_V1,
}
#[test]
fn bindgen_test_layout__NV_MOSAIC_GRID_TOPO_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_MOSAIC_GRID_TOPO_V1>(),
        1320usize,
        concat!("Size of: ", stringify!(_NV_MOSAIC_GRID_TOPO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MOSAIC_GRID_TOPO_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_MOSAIC_GRID_TOPO_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_rows() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rows) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_V1),
                "::",
                stringify!(rows)
            )
        );
    }
    test_field_rows();
    fn test_field_columns() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).columns) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_V1),
                "::",
                stringify!(columns)
            )
        );
    }
    test_field_columns();
    fn test_field_displayCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayCount) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_V1),
                "::",
                stringify!(displayCount)
            )
        );
    }
    test_field_displayCount();
    fn test_field_displays() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displays) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_V1),
                "::",
                stringify!(displays)
            )
        );
    }
    test_field_displays();
    fn test_field_displaySettings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displaySettings) as usize - ptr as usize
            },
            1300usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_V1),
                "::",
                stringify!(displaySettings)
            )
        );
    }
    test_field_displaySettings();
}
impl Default for _NV_MOSAIC_GRID_TOPO_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_MOSAIC_GRID_TOPO_V1 {
    #[inline]
    pub fn applyWithBezelCorrect(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_applyWithBezelCorrect(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn immersiveGaming(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_immersiveGaming(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn baseMosaic(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_baseMosaic(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn driverReloadAllowed(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_driverReloadAllowed(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn acceleratePrimaryDisplay(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_acceleratePrimaryDisplay(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        applyWithBezelCorrect: NvU32,
        immersiveGaming: NvU32,
        baseMosaic: NvU32,
        driverReloadAllowed: NvU32,
        acceleratePrimaryDisplay: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let applyWithBezelCorrect: u32 =
                unsafe { ::std::mem::transmute(applyWithBezelCorrect) };
            applyWithBezelCorrect as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let immersiveGaming: u32 = unsafe { ::std::mem::transmute(immersiveGaming) };
            immersiveGaming as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let baseMosaic: u32 = unsafe { ::std::mem::transmute(baseMosaic) };
            baseMosaic as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let driverReloadAllowed: u32 = unsafe { ::std::mem::transmute(driverReloadAllowed) };
            driverReloadAllowed as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let acceleratePrimaryDisplay: u32 =
                unsafe { ::std::mem::transmute(acceleratePrimaryDisplay) };
            acceleratePrimaryDisplay as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_MOSAIC_GRID_TOPO_V1 = _NV_MOSAIC_GRID_TOPO_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MOSAIC_GRID_TOPO_V2 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Number of rows"]
    pub rows: NvU32,
    #[doc = "!< Number of columns"]
    pub columns: NvU32,
    #[doc = "!< Number of display details"]
    pub displayCount: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Displays are done as [(row * columns) + column]"]
    pub displays: [NV_MOSAIC_GRID_TOPO_DISPLAY_V2; 64usize],
    #[doc = "!< Display settings"]
    pub displaySettings: NV_MOSAIC_DISPLAY_SETTING_V1,
}
#[test]
fn bindgen_test_layout__NV_MOSAIC_GRID_TOPO_V2() {
    assert_eq!(
        ::std::mem::size_of::<_NV_MOSAIC_GRID_TOPO_V2>(),
        1832usize,
        concat!("Size of: ", stringify!(_NV_MOSAIC_GRID_TOPO_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MOSAIC_GRID_TOPO_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_MOSAIC_GRID_TOPO_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_rows() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rows) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_V2),
                "::",
                stringify!(rows)
            )
        );
    }
    test_field_rows();
    fn test_field_columns() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).columns) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_V2),
                "::",
                stringify!(columns)
            )
        );
    }
    test_field_columns();
    fn test_field_displayCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayCount) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_V2),
                "::",
                stringify!(displayCount)
            )
        );
    }
    test_field_displayCount();
    fn test_field_displays() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displays) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_V2),
                "::",
                stringify!(displays)
            )
        );
    }
    test_field_displays();
    fn test_field_displaySettings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MOSAIC_GRID_TOPO_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displaySettings) as usize - ptr as usize
            },
            1812usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MOSAIC_GRID_TOPO_V2),
                "::",
                stringify!(displaySettings)
            )
        );
    }
    test_field_displaySettings();
}
impl Default for _NV_MOSAIC_GRID_TOPO_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_MOSAIC_GRID_TOPO_V2 {
    #[inline]
    pub fn applyWithBezelCorrect(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_applyWithBezelCorrect(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn immersiveGaming(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_immersiveGaming(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn baseMosaic(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_baseMosaic(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn driverReloadAllowed(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_driverReloadAllowed(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn acceleratePrimaryDisplay(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_acceleratePrimaryDisplay(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pixelShift(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pixelShift(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        applyWithBezelCorrect: NvU32,
        immersiveGaming: NvU32,
        baseMosaic: NvU32,
        driverReloadAllowed: NvU32,
        acceleratePrimaryDisplay: NvU32,
        pixelShift: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let applyWithBezelCorrect: u32 =
                unsafe { ::std::mem::transmute(applyWithBezelCorrect) };
            applyWithBezelCorrect as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let immersiveGaming: u32 = unsafe { ::std::mem::transmute(immersiveGaming) };
            immersiveGaming as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let baseMosaic: u32 = unsafe { ::std::mem::transmute(baseMosaic) };
            baseMosaic as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let driverReloadAllowed: u32 = unsafe { ::std::mem::transmute(driverReloadAllowed) };
            driverReloadAllowed as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let acceleratePrimaryDisplay: u32 =
                unsafe { ::std::mem::transmute(acceleratePrimaryDisplay) };
            acceleratePrimaryDisplay as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let pixelShift: u32 = unsafe { ::std::mem::transmute(pixelShift) };
            pixelShift as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_MOSAIC_GRID_TOPO_V2 = _NV_MOSAIC_GRID_TOPO_V2;
pub type NV_MOSAIC_GRID_TOPO = NV_MOSAIC_GRID_TOPO_V2;
extern "C" {
    #[doc = "! DESCRIPTION:     Sets a new display topology, replacing any existing topologies"]
    #[doc = "!                  that use the same displays."]
    #[doc = "!"]
    #[doc = "!                  This function will look for an SLI configuration that will"]
    #[doc = "!                  allow the display topology to work."]
    #[doc = "!"]
    #[doc = "!                  To revert to a single display, specify that display as a 1x1"]
    #[doc = "!                  grid."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]      pGridTopologies    The topology details to set."]
    #[doc = "! \\param [in]      gridCount          The number of elements in the pGridTopologies array."]
    #[doc = "! \\param [in]      setTopoFlags       Zero or more of the NVAPI_MOSAIC_SETDISPLAYTOPO_FLAG_*"]
    #[doc = "!                                     flags."]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                          Capabilities have been returned."]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT            One or more args passed in are invalid."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first"]
    #[doc = "! \\retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available"]
    #[doc = "! \\retval ::NVAPI_NO_ACTIVE_SLI_TOPOLOGY      No matching GPU topologies could be found."]
    #[doc = "! \\retval ::NVAPI_TOPO_NOT_POSSIBLE           One or more of the display grids are not valid."]
    #[doc = "! \\retval ::NVAPI_ERROR                       Miscellaneous error occurred"]
    #[doc = "! \\ingroup mosaicapi"]
    #[doc = ""]
    pub fn NvAPI_Mosaic_SetDisplayGrids(
        pGridTopologies: *mut NV_MOSAIC_GRID_TOPO,
        gridCount: NvU32,
        setTopoFlags: NvU32,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup mosaicapi"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_MOSAIC_DISPLAY_TOPO_STATUS {
    pub version: NvU32,
    #[doc = "!< (OUT) Any of the NV_MOSAIC_DISPLAYTOPO_ERROR_* flags."]
    pub errorFlags: NvU32,
    #[doc = "!< (OUT) Any of the NV_MOSAIC_DISPLAYTOPO_WARNING_* flags."]
    pub warningFlags: NvU32,
    #[doc = "!< (OUT) The number of valid entries in the displays array."]
    pub displayCount: NvU32,
    pub displays: [NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1; 128usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1 {
    #[doc = "!< (OUT) The DisplayID of this display."]
    pub displayId: NvU32,
    #[doc = "!< (OUT) Any of the NV_MOSAIC_DISPLAYCAPS_PROBLEM_* flags."]
    pub errorFlags: NvU32,
    #[doc = "!< (OUT) Any of the NV_MOSAIC_DISPLAYTOPO_WARNING_* flags."]
    pub warningFlags: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1)
        )
    );
    fn test_field_displayId() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayId) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1),
                "::",
                stringify!(displayId)
            )
        );
    }
    test_field_displayId();
    fn test_field_errorFlags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).errorFlags) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1),
                "::",
                stringify!(errorFlags)
            )
        );
    }
    test_field_errorFlags();
    fn test_field_warningFlags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).warningFlags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1),
                "::",
                stringify!(warningFlags)
            )
        );
    }
    test_field_warningFlags();
}
impl NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn supportsRotation(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supportsRotation(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        supportsRotation: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let supportsRotation: u32 = unsafe { ::std::mem::transmute(supportsRotation) };
            supportsRotation as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NV_MOSAIC_DISPLAY_TOPO_STATUS() {
    assert_eq!(
        ::std::mem::size_of::<NV_MOSAIC_DISPLAY_TOPO_STATUS>(),
        2064usize,
        concat!("Size of: ", stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_MOSAIC_DISPLAY_TOPO_STATUS>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_DISPLAY_TOPO_STATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_errorFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_DISPLAY_TOPO_STATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).errorFlags) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS),
                "::",
                stringify!(errorFlags)
            )
        );
    }
    test_field_errorFlags();
    fn test_field_warningFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_DISPLAY_TOPO_STATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).warningFlags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS),
                "::",
                stringify!(warningFlags)
            )
        );
    }
    test_field_warningFlags();
    fn test_field_displayCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_DISPLAY_TOPO_STATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayCount) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS),
                "::",
                stringify!(displayCount)
            )
        );
    }
    test_field_displayCount();
    fn test_field_displays() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_DISPLAY_TOPO_STATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displays) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS),
                "::",
                stringify!(displays)
            )
        );
    }
    test_field_displays();
}
impl Default for NV_MOSAIC_DISPLAY_TOPO_STATUS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "! DESCRIPTION:     Determines if a list of grid topologies is valid. It will choose an SLI"]
    #[doc = "!                  configuration in the same way that NvAPI_Mosaic_SetDisplayGrids() does."]
    #[doc = "!"]
    #[doc = "!                  On return, each element in the pTopoStatus array will contain any errors or"]
    #[doc = "!                  warnings about each grid topology. If any error flags are set, then the topology"]
    #[doc = "!                  is not valid. If any warning flags are set, then the topology is valid, but"]
    #[doc = "!                  sub-optimal."]
    #[doc = "!"]
    #[doc = "!                  If the ALLOW_INVALID flag is set, then it will continue to validate the grids"]
    #[doc = "!                  even if no SLI configuration will allow all of the grids. In this case, a grid"]
    #[doc = "!                  grid with no matching GPU topology will have the error"]
    #[doc = "!                  flags NO_GPU_TOPOLOGY or NOT_SUPPORTED set."]
    #[doc = "!"]
    #[doc = "!                  If the ALLOW_INVALID flag is not set and no matching SLI configuration is"]
    #[doc = "!                  found, then it will skip the rest of the validation and return"]
    #[doc = "!                  NVAPI_NO_ACTIVE_SLI_TOPOLOGY."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]      setTopoFlags       Zero or more of the NVAPI_MOSAIC_SETDISPLAYTOPO_FLAG_*"]
    #[doc = "!                                     flags."]
    #[doc = "! \\param [in]      pGridTopologies    The array of grid topologies to verify."]
    #[doc = "! \\param [in,out]  pTopoStatus        The array of problems and warnings with each grid topology."]
    #[doc = "! \\param [in]      gridCount          The number of elements in the pGridTopologies and"]
    #[doc = "!                                     pTopoStatus arrays."]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK:                          Capabilities have been returned."]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT:            One or more args passed in are invalid."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED:          The NvAPI API needs to be initialized first"]
    #[doc = "! \\retval ::NVAPI_NO_IMPLEMENTATION:           This entrypoint not available"]
    #[doc = "! \\retval ::NVAPI_NO_ACTIVE_SLI_TOPOLOGY:      No matching GPU topologies could be found."]
    #[doc = "! \\retval ::NVAPI_ERROR:                       Miscellaneous error occurred"]
    #[doc = "!"]
    #[doc = "! \\ingroup mosaicapi"]
    #[doc = ""]
    pub fn NvAPI_Mosaic_ValidateDisplayGrids(
        setTopoFlags: NvU32,
        pGridTopologies: *mut NV_MOSAIC_GRID_TOPO,
        pTopoStatus: *mut NV_MOSAIC_DISPLAY_TOPO_STATUS,
        gridCount: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     Determines the set of available display modes for a given grid topology."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]      pGridTopology         The grid topology to use."]
    #[doc = "! \\param [in,out]  pDisplaySettings      A pointer to an array of display settings to populate,"]
    #[doc = "!                                        or NULL to find out the total number of available modes."]
    #[doc = "! \\param [in,out]  pDisplayCount         If pDisplaySettings is not NULL, then pDisplayCount"]
    #[doc = "!                                        should point to the number of elements in the"]
    #[doc = "!                                        pDisplaySettings array. On return, it will contain the"]
    #[doc = "!                                        number of modes that were actually returned. If"]
    #[doc = "!                                        pDisplaySettings is NULL, then pDisplayCount will receive"]
    #[doc = "!                                        the total number of modes that are available."]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                          Capabilities have been returned."]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT            One or more args passed in are invalid."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first"]
    #[doc = "! \\retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available"]
    #[doc = "! \\retval ::NVAPI_ERROR                       Miscellaneous error occurred"]
    #[doc = "!"]
    #[doc = "! \\ingroup mosaciapi"]
    #[doc = ""]
    pub fn NvAPI_Mosaic_EnumDisplayModes(
        pGridTopology: *mut NV_MOSAIC_GRID_TOPO,
        pDisplaySettings: *mut NV_MOSAIC_DISPLAY_SETTING,
        pDisplayCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     Enumerates the current active grid topologies. This includes Mosaic, IG, and"]
    #[doc = "!                  Panoramic topologies, as well as single displays."]
    #[doc = "!"]
    #[doc = "!                  If pGridTopologies is NULL, then pGridCount will be set to the number of active"]
    #[doc = "!                  grid topologies."]
    #[doc = "!"]
    #[doc = "!                  If pGridTopologies is not NULL, then pGridCount contains the maximum number of"]
    #[doc = "!                  grid topologies to return. On return, pGridCount will be set to the number of"]
    #[doc = "!                  grid topologies that were returned."]
    #[doc = "!"]
    #[doc = "! \\param [out]     pGridTopologies   The list of active grid topologies."]
    #[doc = "! \\param [in,out]  pGridCount        A pointer to the number of grid topologies returned."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                          Capabilties have been returned."]
    #[doc = "! \\retval ::NVAPI_END_ENUMERATION             There are no more topologies to return."]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT            One or more args passed in are invalid."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first"]
    #[doc = "! \\retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available"]
    #[doc = "! \\retval ::NVAPI_ERROR                       Miscellaneous error occurred"]
    #[doc = "!"]
    #[doc = "! \\ingroup mosaicapi"]
    #[doc = ""]
    pub fn NvAPI_Mosaic_EnumDisplayGrids(
        pGridTopologies: *mut NV_MOSAIC_GRID_TOPO,
        pGridCount: *mut NvU32,
    ) -> NvAPI_Status;
}
#[doc = "! Used in NvAPI_GetCurrentMosaicTopology() and NvAPI_SetCurrentMosaicTopology()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_MOSAIC_TOPOLOGY {
    #[doc = "!< Version number of the mosaic topology"]
    pub version: NvU32,
    #[doc = "!< Horizontal display count"]
    pub rowCount: NvU32,
    #[doc = "!< Vertical display count"]
    pub colCount: NvU32,
    pub gpuLayout: [[NV_MOSAIC_TOPOLOGY__bindgen_ty_1; 8usize]; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_MOSAIC_TOPOLOGY__bindgen_ty_1 {
    #[doc = "!< Physical GPU to be used in the topology"]
    pub hPhysicalGPU: NvPhysicalGpuHandle,
    #[doc = "!< Connected display target"]
    pub displayOutputId: NvU32,
    #[doc = "!< Pixels of overlap on the left of target: (+overlap, -gap)"]
    pub overlapX: NvS32,
    #[doc = "!< Pixels of overlap on the top of target: (+overlap, -gap)"]
    pub overlapY: NvS32,
}
#[test]
fn bindgen_test_layout_NV_MOSAIC_TOPOLOGY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_MOSAIC_TOPOLOGY__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(NV_MOSAIC_TOPOLOGY__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_MOSAIC_TOPOLOGY__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NV_MOSAIC_TOPOLOGY__bindgen_ty_1)
        )
    );
    fn test_field_hPhysicalGPU() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPOLOGY__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hPhysicalGPU) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPOLOGY__bindgen_ty_1),
                "::",
                stringify!(hPhysicalGPU)
            )
        );
    }
    test_field_hPhysicalGPU();
    fn test_field_displayOutputId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPOLOGY__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayOutputId) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPOLOGY__bindgen_ty_1),
                "::",
                stringify!(displayOutputId)
            )
        );
    }
    test_field_displayOutputId();
    fn test_field_overlapX() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPOLOGY__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).overlapX) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPOLOGY__bindgen_ty_1),
                "::",
                stringify!(overlapX)
            )
        );
    }
    test_field_overlapX();
    fn test_field_overlapY() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPOLOGY__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).overlapY) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPOLOGY__bindgen_ty_1),
                "::",
                stringify!(overlapY)
            )
        );
    }
    test_field_overlapY();
}
impl Default for NV_MOSAIC_TOPOLOGY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NV_MOSAIC_TOPOLOGY() {
    assert_eq!(
        ::std::mem::size_of::<NV_MOSAIC_TOPOLOGY>(),
        1552usize,
        concat!("Size of: ", stringify!(NV_MOSAIC_TOPOLOGY))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_MOSAIC_TOPOLOGY>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_MOSAIC_TOPOLOGY))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPOLOGY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPOLOGY),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_rowCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPOLOGY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rowCount) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPOLOGY),
                "::",
                stringify!(rowCount)
            )
        );
    }
    test_field_rowCount();
    fn test_field_colCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPOLOGY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPOLOGY),
                "::",
                stringify!(colCount)
            )
        );
    }
    test_field_colCount();
    fn test_field_gpuLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_TOPOLOGY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gpuLayout) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_TOPOLOGY),
                "::",
                stringify!(gpuLayout)
            )
        );
    }
    test_field_gpuLayout();
}
impl Default for NV_MOSAIC_TOPOLOGY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Used in NvAPI_GetSupportedMosaicTopologies()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_MOSAIC_SUPPORTED_TOPOLOGIES {
    pub version: NvU32,
    #[doc = "!< Count of valid topologies"]
    pub totalCount: NvU32,
    #[doc = "!< Maximum number of topologies"]
    pub topos: [NV_MOSAIC_TOPOLOGY; 16usize],
}
#[test]
fn bindgen_test_layout_NV_MOSAIC_SUPPORTED_TOPOLOGIES() {
    assert_eq!(
        ::std::mem::size_of::<NV_MOSAIC_SUPPORTED_TOPOLOGIES>(),
        24840usize,
        concat!("Size of: ", stringify!(NV_MOSAIC_SUPPORTED_TOPOLOGIES))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_MOSAIC_SUPPORTED_TOPOLOGIES>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_MOSAIC_SUPPORTED_TOPOLOGIES))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_SUPPORTED_TOPOLOGIES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_SUPPORTED_TOPOLOGIES),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_totalCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_SUPPORTED_TOPOLOGIES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).totalCount) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_SUPPORTED_TOPOLOGIES),
                "::",
                stringify!(totalCount)
            )
        );
    }
    test_field_totalCount();
    fn test_field_topos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_MOSAIC_SUPPORTED_TOPOLOGIES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).topos) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_MOSAIC_SUPPORTED_TOPOLOGIES),
                "::",
                stringify!(topos)
            )
        );
    }
    test_field_topos();
}
impl Default for NV_MOSAIC_SUPPORTED_TOPOLOGIES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API returns all valid Mosaic topologies."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows XP"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 177"]
    #[doc = "!"]
    #[doc = "! \\param [out] pMosaicTopos                   An array of valid Mosaic topologies."]
    #[doc = "!"]
    #[doc = "! \\retval      NVAPI_OK                       Call succeeded; 1 or more topologies were returned"]
    #[doc = "! \\retval      NVAPI_INVALID_ARGUMENT         One or more arguments are invalid"]
    #[doc = "! \\retval      NVAPI_MIXED_TARGET_TYPES       Mosaic topology is only possible with all targets of the same NV_GPU_OUTPUT_TYPE."]
    #[doc = "! \\retval      NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found"]
    #[doc = "! \\retval      NVAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system."]
    #[doc = "! \\retval      NVAPI_NO_ACTIVE_SLI_TOPOLOGY   SLI is not enabled, yet needs to be, in order for this function to succeed."]
    #[doc = "!"]
    #[doc = "! \\ingroup     mosaicapi"]
    #[doc = ""]
    pub fn NvAPI_GetSupportedMosaicTopologies(
        pMosaicTopos: *mut NV_MOSAIC_SUPPORTED_TOPOLOGIES,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API gets the current Mosaic topology."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows XP"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 177"]
    #[doc = "!"]
    #[doc = "! \\param [out] pMosaicTopo                    The current Mosaic topology"]
    #[doc = "! \\param [out] pEnabled                       TRUE if returned topology is currently enabled, else FALSE"]
    #[doc = "!"]
    #[doc = "! \\retval      NVAPI_OK                       Call succeeded"]
    #[doc = "! \\retval      NVAPI_INVALID_ARGUMENT         One or more arguments are invalid"]
    #[doc = "! \\retval      NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found"]
    #[doc = "! \\retval      NVAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system."]
    #[doc = "! \\retval      NVAPI_NO_ACTIVE_SLI_TOPOLOGY   SLI is not enabled, yet needs to be, in order for this function to succeed."]
    #[doc = "!"]
    #[doc = "! \\ingroup     mosaicapi"]
    #[doc = ""]
    pub fn NvAPI_GetCurrentMosaicTopology(
        pMosaicTopo: *mut NV_MOSAIC_TOPOLOGY,
        pEnabled: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API sets the Mosaic topology, and enables it so that the"]
    #[doc = "!                  Mosaic display settings are enumerated upon request."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows XP"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 177"]
    #[doc = "!"]
    #[doc = "! \\param [in]  pMosaicTopo                    A valid Mosaic topology"]
    #[doc = "!"]
    #[doc = "! \\retval      NVAPI_OK                       Call succeeded"]
    #[doc = "! \\retval      NVAPI_INVALID_ARGUMENT         One or more arguments are invalid"]
    #[doc = "! \\retval      NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found"]
    #[doc = "! \\retval      NVAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system."]
    #[doc = "! \\retval      NVAPI_NO_ACTIVE_SLI_TOPOLOGY   SLI is not enabled, yet needs to be, in order for this function to succeed."]
    #[doc = "!"]
    #[doc = "! \\ingroup     mosaicapi"]
    #[doc = ""]
    pub fn NvAPI_SetCurrentMosaicTopology(pMosaicTopo: *mut NV_MOSAIC_TOPOLOGY) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:    This API enables or disables the current Mosaic topology."]
    #[doc = "!                 When enabling, the last Mosaic topology will be set."]
    #[doc = "!"]
    #[doc = "!                  - If enabled, enumeration of display settings will include valid Mosaic resolutions."]
    #[doc = "!                  - If disabled, enumeration of display settings will not include Mosaic resolutions."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows XP"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 177"]
    #[doc = "!"]
    #[doc = "! \\param [in]  enable                         TRUE to enable the Mosaic Topology, FALSE to disable it."]
    #[doc = "!"]
    #[doc = "! \\retval      NVAPI_OK                       Call succeeded"]
    #[doc = "! \\retval      NVAPI_INVALID_ARGUMENT         One or more arguments are invalid"]
    #[doc = "! \\retval      NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found"]
    #[doc = "! \\retval      NVAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system."]
    #[doc = "! \\retval      NVAPI_NO_ACTIVE_SLI_TOPOLOGY   SLI is not enabled, yet needs to be, in order for this function to succeed."]
    #[doc = "!"]
    #[doc = "! \\ingroup     mosaicapi"]
    #[doc = ""]
    pub fn NvAPI_EnableCurrentMosaicTopology(enable: NvU32) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API returns an array of Sync device handles. A Sync device handle represents a"]
    #[doc = "!                single Sync device on the system."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 313"]
    #[doc = "!"]
    #[doc = "! \\param [out] nvGSyncHandles-  The caller provides an array of handles, which must contain at least"]
    #[doc = "!                               NVAPI_MAX_GSYNC_DEVICES elements. The API will zero out the entire array and then fill in one"]
    #[doc = "!                               or more handles. If an error occurs, the array is invalid."]
    #[doc = "! \\param [out] *gsyncCount-     The caller provides the storage space. NvAPI_GSync_EnumSyncDevices"]
    #[doc = "!                               sets *gsyncCount to indicate how many of the elements in the nvGSyncHandles[] array are valid."]
    #[doc = "!                               If an error occurs, *gsyncCount will be set to zero."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!          If there are return error codes with specific meaning for this API, they are listed below."]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT         nvGSyncHandles or gsyncCount is NULL."]
    #[doc = "! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any Sync Device."]
    #[doc = "!"]
    #[doc = "! \\ingroup gsyncapi"]
    #[doc = ""]
    pub fn NvAPI_GSync_EnumSyncDevices(
        nvGSyncHandles: *mut NvGSyncDeviceHandle,
        gsyncCount: *mut NvU32,
    ) -> NvAPI_Status;
}
#[doc = "! Used in NvAPI_GSync_QueryCapabilities()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_GSYNC_CAPABILITIES_V1 {
    #[doc = "!< Version of the structure"]
    pub version: NvU32,
    #[doc = "!< Board ID"]
    pub boardId: NvU32,
    #[doc = "!< FPGA Revision"]
    pub revision: NvU32,
    #[doc = "!< Capabilities of the Sync board. Reserved for future use"]
    pub capFlags: NvU32,
}
#[test]
fn bindgen_test_layout__NV_GSYNC_CAPABILITIES_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GSYNC_CAPABILITIES_V1>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_GSYNC_CAPABILITIES_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GSYNC_CAPABILITIES_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GSYNC_CAPABILITIES_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_CAPABILITIES_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_CAPABILITIES_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_boardId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_CAPABILITIES_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).boardId) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_CAPABILITIES_V1),
                "::",
                stringify!(boardId)
            )
        );
    }
    test_field_boardId();
    fn test_field_revision() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_CAPABILITIES_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).revision) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_CAPABILITIES_V1),
                "::",
                stringify!(revision)
            )
        );
    }
    test_field_revision();
    fn test_field_capFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_CAPABILITIES_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).capFlags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_CAPABILITIES_V1),
                "::",
                stringify!(capFlags)
            )
        );
    }
    test_field_capFlags();
}
#[doc = "! Used in NvAPI_GSync_QueryCapabilities()."]
pub type NV_GSYNC_CAPABILITIES_V1 = _NV_GSYNC_CAPABILITIES_V1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_GSYNC_CAPABILITIES_V2 {
    #[doc = "!< Version of the structure"]
    pub version: NvU32,
    #[doc = "!< Board ID"]
    pub boardId: NvU32,
    #[doc = "!< FPGA major revision"]
    pub revision: NvU32,
    #[doc = "!< Capabilities of the Sync board. Reserved for future use"]
    pub capFlags: NvU32,
    #[doc = "!< FPGA minor revision"]
    pub extendedRevision: NvU32,
}
#[test]
fn bindgen_test_layout__NV_GSYNC_CAPABILITIES_V2() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GSYNC_CAPABILITIES_V2>(),
        20usize,
        concat!("Size of: ", stringify!(_NV_GSYNC_CAPABILITIES_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GSYNC_CAPABILITIES_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GSYNC_CAPABILITIES_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_CAPABILITIES_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_CAPABILITIES_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_boardId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_CAPABILITIES_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).boardId) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_CAPABILITIES_V2),
                "::",
                stringify!(boardId)
            )
        );
    }
    test_field_boardId();
    fn test_field_revision() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_CAPABILITIES_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).revision) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_CAPABILITIES_V2),
                "::",
                stringify!(revision)
            )
        );
    }
    test_field_revision();
    fn test_field_capFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_CAPABILITIES_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).capFlags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_CAPABILITIES_V2),
                "::",
                stringify!(capFlags)
            )
        );
    }
    test_field_capFlags();
    fn test_field_extendedRevision() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_CAPABILITIES_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedRevision) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_CAPABILITIES_V2),
                "::",
                stringify!(extendedRevision)
            )
        );
    }
    test_field_extendedRevision();
}
pub type NV_GSYNC_CAPABILITIES_V2 = _NV_GSYNC_CAPABILITIES_V2;
pub type NV_GSYNC_CAPABILITIES = NV_GSYNC_CAPABILITIES_V2;
extern "C" {
    #[doc = "!   DESCRIPTION: This API returns the capabilities of the Sync device."]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 313"]
    #[doc = "!"]
    #[doc = "! \\param [in]    hNvGSyncDevice-        The handle for a Sync device for which the capabilities will be queried."]
    #[doc = "! \\param [inout] *pNvGSyncCapabilities- The caller provides the storage space. NvAPI_GSync_QueryCapabilities() sets"]
    #[doc = "!                                       *pNvGSyncCapabilities to the version and capabilities details of the Sync device"]
    #[doc = "!                                       If an error occurs, *pNvGSyncCapabilities will be set to NULL."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!          If there are return error codes with specific meaning for this API, they are listed below."]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT         hNvGSyncDevice is NULL."]
    #[doc = "! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any Sync Device."]
    #[doc = "!"]
    #[doc = "! \\ingroup gsyncapi"]
    #[doc = ""]
    pub fn NvAPI_GSync_QueryCapabilities(
        hNvGSyncDevice: NvGSyncDeviceHandle,
        pNvGSyncCapabilities: *mut NV_GSYNC_CAPABILITIES,
    ) -> NvAPI_Status;
}
pub const _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_NONE:
    _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR = 0;
pub const _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_PRIMARY:
    _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR = 1;
pub const _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_SECONDARY:
    _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR = 2;
pub const _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_TERTIARY:
    _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR = 3;
pub const _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_QUARTERNARY:
    _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR = 4;
#[doc = "! Connector values for a GPU. Used in NV_GSYNC_GPU."]
pub type _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR = ::std::os::raw::c_int;
#[doc = "! Connector values for a GPU. Used in NV_GSYNC_GPU."]
pub use self::_NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR as NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR;
pub const _NVAPI_GSYNC_DISPLAY_SYNC_STATE_NVAPI_GSYNC_DISPLAY_SYNC_STATE_UNSYNCED:
    _NVAPI_GSYNC_DISPLAY_SYNC_STATE = 0;
pub const _NVAPI_GSYNC_DISPLAY_SYNC_STATE_NVAPI_GSYNC_DISPLAY_SYNC_STATE_SLAVE:
    _NVAPI_GSYNC_DISPLAY_SYNC_STATE = 1;
pub const _NVAPI_GSYNC_DISPLAY_SYNC_STATE_NVAPI_GSYNC_DISPLAY_SYNC_STATE_MASTER:
    _NVAPI_GSYNC_DISPLAY_SYNC_STATE = 2;
#[doc = "! Display sync states. Used in NV_GSYNC_DISPLAY."]
pub type _NVAPI_GSYNC_DISPLAY_SYNC_STATE = ::std::os::raw::c_int;
#[doc = "! Display sync states. Used in NV_GSYNC_DISPLAY."]
pub use self::_NVAPI_GSYNC_DISPLAY_SYNC_STATE as NVAPI_GSYNC_DISPLAY_SYNC_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GSYNC_GPU {
    #[doc = "!< Version of the structure"]
    pub version: NvU32,
    #[doc = "!< GPU handle"]
    pub hPhysicalGpu: NvPhysicalGpuHandle,
    #[doc = "!< Indicates which connector on the device the GPU is connected to."]
    pub connector: NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR,
    #[doc = "!< GPU through which hPhysicalGpu is connected to the Sync device (if not directly connected)"]
    #[doc = "!<  - this is NULL otherwise"]
    pub hProxyPhysicalGpu: NvPhysicalGpuHandle,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout__NV_GSYNC_GPU() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GSYNC_GPU>(),
        40usize,
        concat!("Size of: ", stringify!(_NV_GSYNC_GPU))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GSYNC_GPU>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_GSYNC_GPU))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_GPU>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_GPU),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_hPhysicalGpu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_GPU>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hPhysicalGpu) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_GPU),
                "::",
                stringify!(hPhysicalGpu)
            )
        );
    }
    test_field_hPhysicalGpu();
    fn test_field_connector() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_GPU>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).connector) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_GPU),
                "::",
                stringify!(connector)
            )
        );
    }
    test_field_connector();
    fn test_field_hProxyPhysicalGpu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_GPU>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hProxyPhysicalGpu) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_GPU),
                "::",
                stringify!(hProxyPhysicalGpu)
            )
        );
    }
    test_field_hProxyPhysicalGpu();
}
impl Default for _NV_GSYNC_GPU {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_GSYNC_GPU {
    #[inline]
    pub fn isSynced(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isSynced(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isSynced: NvU32, reserved: NvU32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isSynced: u32 = unsafe { ::std::mem::transmute(isSynced) };
            isSynced as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GSYNC_GPU = _NV_GSYNC_GPU;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GSYNC_DISPLAY {
    #[doc = "!< Version of the structure"]
    pub version: NvU32,
    #[doc = "!< display identifier for displays.The GPU to which it is connected, can be retireved from NvAPI_SYS_GetPhysicalGpuFromDisplayId"]
    pub displayId: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Is this display slave/master"]
    #[doc = "!< (Retrieved with topology or set by caller for enable/disable sync)"]
    pub syncState: NVAPI_GSYNC_DISPLAY_SYNC_STATE,
}
#[test]
fn bindgen_test_layout__NV_GSYNC_DISPLAY() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GSYNC_DISPLAY>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_GSYNC_DISPLAY))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GSYNC_DISPLAY>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GSYNC_DISPLAY))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_DISPLAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_DISPLAY),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_displayId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_DISPLAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayId) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_DISPLAY),
                "::",
                stringify!(displayId)
            )
        );
    }
    test_field_displayId();
    fn test_field_syncState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_DISPLAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).syncState) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_DISPLAY),
                "::",
                stringify!(syncState)
            )
        );
    }
    test_field_syncState();
}
impl Default for _NV_GSYNC_DISPLAY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_GSYNC_DISPLAY {
    #[inline]
    pub fn isMasterable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMasterable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isMasterable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isMasterable: u32 = unsafe { ::std::mem::transmute(isMasterable) };
            isMasterable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GSYNC_DISPLAY = _NV_GSYNC_DISPLAY;
extern "C" {
    #[doc = "!   DESCRIPTION: This API returns the topology for the specified Sync device."]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 313"]
    #[doc = "!"]
    #[doc = "! \\param [in]       hNvGSyncDevice-     The caller provides the handle for a Sync device for which the topology will be queried."]
    #[doc = "! \\param [in, out]  gsyncGpuCount-      It returns number of GPUs connected to Sync device"]
    #[doc = "! \\param [in, out]  gsyncGPUs-          It returns info about GPUs connected to Sync device"]
    #[doc = "! \\param [in, out]  gsyncDisplayCount-  It returns number of active displays that belongs to Sync device"]
    #[doc = "! \\param [in, out]  gsyncDisplays-      It returns info about all active displays that belongs to Sync device"]
    #[doc = "!"]
    #[doc = "! HOW TO USE: 1) make a call to get the number of GPUs connected OR displays synced through Sync device"]
    #[doc = "!                by passing the gsyncGPUs OR gsyncDisplays as NULL respectively. Both gsyncGpuCount and gsyncDisplayCount can be retrieved in same call by passing"]
    #[doc = "!                both gsyncGPUs and gsyncDisplays as NULL"]
    #[doc = "!                On call success:"]
    #[doc = "!             2) Allocate memory based on gsyncGpuCount(for gsyncGPUs) and/or gsyncDisplayCount(for gsyncDisplays) then make a call to populate gsyncGPUs and/or gsyncDisplays respectively."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!          If there are return error codes with specific meaning for this API, they are listed below."]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT               hNvGSyncDevice is NULL."]
    #[doc = "! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND        The queried Graphics system does not have any Sync Device."]
    #[doc = "! \\retval ::NVAPI_INSUFFICIENT_BUFFER            When the actual number of GPUs/displays in the topology exceed the number of elements allocated for SyncGPUs/SyncDisplays respectively."]
    #[doc = "!"]
    #[doc = "! \\ingroup gsyncapi"]
    #[doc = ""]
    pub fn NvAPI_GSync_GetTopology(
        hNvGSyncDevice: NvGSyncDeviceHandle,
        gsyncGpuCount: *mut NvU32,
        gsyncGPUs: *mut NV_GSYNC_GPU,
        gsyncDisplayCount: *mut NvU32,
        gsyncDisplays: *mut NV_GSYNC_DISPLAY,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: Sets a new sync state for the displays in system."]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 313"]
    #[doc = "!"]
    #[doc = "! \\param [in]  gsyncDisplayCount-\t\t\tThe number of displays in gsyncDisplays."]
    #[doc = "! \\param [in]  pGsyncDisplays-\t\t\tThe caller provides the structure containing all displays that need to be synchronized in the system."]
    #[doc = "!\t\t\t\t\t\t\t\t\t\t\tThe displays that are not part of pGsyncDisplays, will be un-synchronized."]
    #[doc = "! \\param [in]  flags-\t\t\t\t\t\tReserved for future use."]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!          If there are return error codes with specific meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT\t\t\tIf the display topology or count not valid."]
    #[doc = "! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND\t\tThe queried Graphics system does not have any Sync Device."]
    #[doc = "! \\retval ::NVAPI_INVALID_SYNC_TOPOLOGY       1.If any mosaic grid is partial."]
    #[doc = "!                                             2.If timing(HVisible/VVisible/refreshRate) applied of any display is different."]
    #[doc = "!                                             3.If There is a across GPU mosaic grid in system and that is not a part of pGsyncDisplays."]
    #[doc = "!"]
    #[doc = "! \\ingroup gsyncapi"]
    #[doc = ""]
    pub fn NvAPI_GSync_SetSyncStateSettings(
        gsyncDisplayCount: NvU32,
        pGsyncDisplays: *mut NV_GSYNC_DISPLAY,
        flags: NvU32,
    ) -> NvAPI_Status;
}
pub const _NVAPI_GSYNC_POLARITY_NVAPI_GSYNC_POLARITY_RISING_EDGE: _NVAPI_GSYNC_POLARITY = 0;
pub const _NVAPI_GSYNC_POLARITY_NVAPI_GSYNC_POLARITY_FALLING_EDGE: _NVAPI_GSYNC_POLARITY = 1;
pub const _NVAPI_GSYNC_POLARITY_NVAPI_GSYNC_POLARITY_BOTH_EDGES: _NVAPI_GSYNC_POLARITY = 2;
#[doc = "! Source signal edge to be used for output pulse. See NV_GSYNC_CONTROL_PARAMS."]
pub type _NVAPI_GSYNC_POLARITY = ::std::os::raw::c_int;
#[doc = "! Source signal edge to be used for output pulse. See NV_GSYNC_CONTROL_PARAMS."]
pub use self::_NVAPI_GSYNC_POLARITY as NVAPI_GSYNC_POLARITY;
pub const _NVAPI_GSYNC_VIDEO_MODE_NVAPI_GSYNC_VIDEO_MODE_NONE: _NVAPI_GSYNC_VIDEO_MODE = 0;
pub const _NVAPI_GSYNC_VIDEO_MODE_NVAPI_GSYNC_VIDEO_MODE_TTL: _NVAPI_GSYNC_VIDEO_MODE = 1;
pub const _NVAPI_GSYNC_VIDEO_MODE_NVAPI_GSYNC_VIDEO_MODE_NTSCPALSECAM: _NVAPI_GSYNC_VIDEO_MODE = 2;
pub const _NVAPI_GSYNC_VIDEO_MODE_NVAPI_GSYNC_VIDEO_MODE_HDTV: _NVAPI_GSYNC_VIDEO_MODE = 3;
pub const _NVAPI_GSYNC_VIDEO_MODE_NVAPI_GSYNC_VIDEO_MODE_COMPOSITE: _NVAPI_GSYNC_VIDEO_MODE = 4;
#[doc = "! Used in NV_GSYNC_CONTROL_PARAMS."]
pub type _NVAPI_GSYNC_VIDEO_MODE = ::std::os::raw::c_int;
#[doc = "! Used in NV_GSYNC_CONTROL_PARAMS."]
pub use self::_NVAPI_GSYNC_VIDEO_MODE as NVAPI_GSYNC_VIDEO_MODE;
pub const _NVAPI_GSYNC_SYNC_SOURCE_NVAPI_GSYNC_SYNC_SOURCE_VSYNC: _NVAPI_GSYNC_SYNC_SOURCE = 0;
pub const _NVAPI_GSYNC_SYNC_SOURCE_NVAPI_GSYNC_SYNC_SOURCE_HOUSESYNC: _NVAPI_GSYNC_SYNC_SOURCE = 1;
#[doc = "! Used in NV_GSYNC_CONTROL_PARAMS."]
pub type _NVAPI_GSYNC_SYNC_SOURCE = ::std::os::raw::c_int;
#[doc = "! Used in NV_GSYNC_CONTROL_PARAMS."]
pub use self::_NVAPI_GSYNC_SYNC_SOURCE as NVAPI_GSYNC_SYNC_SOURCE;
#[doc = "! Used in NV_GSYNC_CONTROL_PARAMS."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_GSYNC_DELAY {
    #[doc = "!< Version of the structure"]
    pub version: NvU32,
    #[doc = "!< delay to be induced in number of horizontal lines."]
    pub numLines: NvU32,
    #[doc = "!< delay to be induced in number of pixels."]
    pub numPixels: NvU32,
    #[doc = "!< maximum number of lines supported at current display mode to induce delay. Updated by NvAPI_GSync_GetControlParameters(). Read only."]
    pub maxLines: NvU32,
    #[doc = "!< minimum number of pixels required at current display mode to induce delay. Updated by NvAPI_GSync_GetControlParameters(). Read only."]
    pub minPixels: NvU32,
}
#[test]
fn bindgen_test_layout__NV_GSYNC_DELAY() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GSYNC_DELAY>(),
        20usize,
        concat!("Size of: ", stringify!(_NV_GSYNC_DELAY))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GSYNC_DELAY>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GSYNC_DELAY))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_DELAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_DELAY),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_numLines() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_DELAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numLines) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_DELAY),
                "::",
                stringify!(numLines)
            )
        );
    }
    test_field_numLines();
    fn test_field_numPixels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_DELAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numPixels) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_DELAY),
                "::",
                stringify!(numPixels)
            )
        );
    }
    test_field_numPixels();
    fn test_field_maxLines() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_DELAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxLines) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_DELAY),
                "::",
                stringify!(maxLines)
            )
        );
    }
    test_field_maxLines();
    fn test_field_minPixels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_DELAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minPixels) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_DELAY),
                "::",
                stringify!(minPixels)
            )
        );
    }
    test_field_minPixels();
}
#[doc = "! Used in NV_GSYNC_CONTROL_PARAMS."]
pub type NV_GSYNC_DELAY = _NV_GSYNC_DELAY;
#[doc = "! Used in NvAPI_GSync_GetControlParameters() and NvAPI_GSync_SetControlParameters()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GSYNC_CONTROL_PARAMS {
    #[doc = "!< Version of the structure"]
    pub version: NvU32,
    #[doc = "!< Leading edge / Falling edge / both"]
    pub polarity: NVAPI_GSYNC_POLARITY,
    #[doc = "!< None, TTL, NTSCPALSECAM, HDTV"]
    pub vmode: NVAPI_GSYNC_VIDEO_MODE,
    #[doc = "!< Number of pulses to wait between framelock signal generation"]
    pub interval: NvU32,
    #[doc = "!< VSync/House sync"]
    pub source: NVAPI_GSYNC_SYNC_SOURCE,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< The time delay between the frame sync signal and the GPUs signal."]
    pub syncSkew: NV_GSYNC_DELAY,
    #[doc = "!< Sync start delay for master."]
    pub startupDelay: NV_GSYNC_DELAY,
}
#[test]
fn bindgen_test_layout__NV_GSYNC_CONTROL_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GSYNC_CONTROL_PARAMS>(),
        64usize,
        concat!("Size of: ", stringify!(_NV_GSYNC_CONTROL_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GSYNC_CONTROL_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GSYNC_CONTROL_PARAMS))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_CONTROL_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_CONTROL_PARAMS),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_polarity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_CONTROL_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).polarity) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_CONTROL_PARAMS),
                "::",
                stringify!(polarity)
            )
        );
    }
    test_field_polarity();
    fn test_field_vmode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_CONTROL_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vmode) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_CONTROL_PARAMS),
                "::",
                stringify!(vmode)
            )
        );
    }
    test_field_vmode();
    fn test_field_interval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_CONTROL_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).interval) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_CONTROL_PARAMS),
                "::",
                stringify!(interval)
            )
        );
    }
    test_field_interval();
    fn test_field_source() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_CONTROL_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_CONTROL_PARAMS),
                "::",
                stringify!(source)
            )
        );
    }
    test_field_source();
    fn test_field_syncSkew() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_CONTROL_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).syncSkew) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_CONTROL_PARAMS),
                "::",
                stringify!(syncSkew)
            )
        );
    }
    test_field_syncSkew();
    fn test_field_startupDelay() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_CONTROL_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).startupDelay) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_CONTROL_PARAMS),
                "::",
                stringify!(startupDelay)
            )
        );
    }
    test_field_startupDelay();
}
impl Default for _NV_GSYNC_CONTROL_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_GSYNC_CONTROL_PARAMS {
    #[inline]
    pub fn interlaceMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interlaceMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syncSourceIsOutput(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_syncSourceIsOutput(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        interlaceMode: NvU32,
        syncSourceIsOutput: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interlaceMode: u32 = unsafe { ::std::mem::transmute(interlaceMode) };
            interlaceMode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let syncSourceIsOutput: u32 = unsafe { ::std::mem::transmute(syncSourceIsOutput) };
            syncSourceIsOutput as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! Used in NvAPI_GSync_GetControlParameters() and NvAPI_GSync_SetControlParameters()."]
pub type NV_GSYNC_CONTROL_PARAMS = _NV_GSYNC_CONTROL_PARAMS;
extern "C" {
    #[doc = "!   DESCRIPTION: This API queries for sync control parameters as defined in NV_GSYNC_CONTROL_PARAMS."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 313"]
    #[doc = "!"]
    #[doc = "! \\param [in]    hNvGSyncDevice-   The caller provides the handle of the Sync device for which to get parameters"]
    #[doc = "! \\param [inout] *pGsyncControls-  The caller provides the storage space. NvAPI_GSync_GetControlParameters() populates *pGsyncControls with values."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!          If there are return error codes with specific meaning for this API, they are listed below."]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT          hNvGSyncDevice is NULL."]
    #[doc = "! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any Sync Device."]
    #[doc = "!"]
    #[doc = "! \\ingroup gsyncapi"]
    #[doc = ""]
    pub fn NvAPI_GSync_GetControlParameters(
        hNvGSyncDevice: NvGSyncDeviceHandle,
        pGsyncControls: *mut NV_GSYNC_CONTROL_PARAMS,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API sets control parameters as defined in NV_SYNC_CONTROL_PARAMS."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 313"]
    #[doc = "!"]
    #[doc = "! \\param [in]  hNvGSyncDevice-   The caller provides the handle of the Sync device for which to get parameters"]
    #[doc = "! \\param [inout]  *pGsyncControls-  The caller provides NV_GSYNC_CONTROL_PARAMS. skew and startDelay will be updated to the applied values."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!          If there are return error codes with specific meaning for this API, they are listed below."]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT          hNvGSyncDevice is NULL."]
    #[doc = "! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any Sync Device."]
    #[doc = "! \\retval ::NVAPI_SYNC_MASTER_NOT_FOUND     Control Parameters can only be set if there is a Sync Master enabled on the Gsync card."]
    #[doc = "!"]
    #[doc = "! \\ingroup gsyncapi"]
    #[doc = ""]
    pub fn NvAPI_GSync_SetControlParameters(
        hNvGSyncDevice: NvGSyncDeviceHandle,
        pGsyncControls: *mut NV_GSYNC_CONTROL_PARAMS,
    ) -> NvAPI_Status;
}
pub const _NVAPI_GSYNC_DELAY_TYPE_NVAPI_GSYNC_DELAY_TYPE_UNKNOWN: _NVAPI_GSYNC_DELAY_TYPE = 0;
pub const _NVAPI_GSYNC_DELAY_TYPE_NVAPI_GSYNC_DELAY_TYPE_SYNC_SKEW: _NVAPI_GSYNC_DELAY_TYPE = 1;
pub const _NVAPI_GSYNC_DELAY_TYPE_NVAPI_GSYNC_DELAY_TYPE_STARTUP: _NVAPI_GSYNC_DELAY_TYPE = 2;
#[doc = "! Used in NvAPI_GSync_AdjustSyncDelay()"]
pub type _NVAPI_GSYNC_DELAY_TYPE = ::std::os::raw::c_int;
#[doc = "! Used in NvAPI_GSync_AdjustSyncDelay()"]
pub use self::_NVAPI_GSYNC_DELAY_TYPE as NVAPI_GSYNC_DELAY_TYPE;
extern "C" {
    #[doc = "!   DESCRIPTION: This API adjusts the skew and startDelay to the closest possible values. Use this API before calling NvAPI_GSync_SetControlParameters for skew or startDelay."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 319"]
    #[doc = "!"]
    #[doc = "! \\param [in]  hNvGSyncDevice-   \tThe caller provides the handle of the Sync device for which to get parameters"]
    #[doc = "! \\param [in]  delayType-   \t\tSpecifies whether the delay is syncSkew or startupDelay."]
    #[doc = "! \\param [inout]  *pGsyncDelay-  \tThe caller provides NV_GSYNC_DELAY. skew and startDelay will be adjusted and updated to the closest values."]
    #[doc = "! \\param [out]  *syncSteps-  \t\tThis parameter is optional. It returns the sync delay in unit steps. If 0, it means either the NV_GSYNC_DELAY::numPixels is less than NV_GSYNC_DELAY::minPixels or NV_GSYNC_DELAY::numOfLines exceeds the NV_GSYNC_DELAY::maxLines."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!          If there are return error codes with specific meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\ingroup gsyncapi"]
    #[doc = ""]
    pub fn NvAPI_GSync_AdjustSyncDelay(
        hNvGSyncDevice: NvGSyncDeviceHandle,
        delayType: NVAPI_GSYNC_DELAY_TYPE,
        pGsyncDelay: *mut NV_GSYNC_DELAY,
        syncSteps: *mut NvU32,
    ) -> NvAPI_Status;
}
#[doc = "! Used in NvAPI_GSync_GetSyncStatus()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_GSYNC_STATUS {
    #[doc = "!< Version of the structure"]
    pub version: NvU32,
    #[doc = "!< Is timing in sync?"]
    pub bIsSynced: NvU32,
    #[doc = "!< Does the phase of the timing signal from the GPU = the phase of the master sync signal?"]
    pub bIsStereoSynced: NvU32,
    #[doc = "!< Is the sync signal available?"]
    pub bIsSyncSignalAvailable: NvU32,
}
#[test]
fn bindgen_test_layout__NV_GSYNC_STATUS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GSYNC_STATUS>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_GSYNC_STATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GSYNC_STATUS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GSYNC_STATUS))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_STATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_STATUS),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_bIsSynced() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_STATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bIsSynced) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_STATUS),
                "::",
                stringify!(bIsSynced)
            )
        );
    }
    test_field_bIsSynced();
    fn test_field_bIsStereoSynced() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_STATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bIsStereoSynced) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_STATUS),
                "::",
                stringify!(bIsStereoSynced)
            )
        );
    }
    test_field_bIsStereoSynced();
    fn test_field_bIsSyncSignalAvailable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_STATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bIsSyncSignalAvailable) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_STATUS),
                "::",
                stringify!(bIsSyncSignalAvailable)
            )
        );
    }
    test_field_bIsSyncSignalAvailable();
}
#[doc = "! Used in NvAPI_GSync_GetSyncStatus()."]
pub type NV_GSYNC_STATUS = _NV_GSYNC_STATUS;
extern "C" {
    #[doc = "!   DESCRIPTION: This API queries the sync status of a GPU - timing, stereosync and sync signal availability."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 313"]
    #[doc = "!"]
    #[doc = "! \\param [in]  hNvGSyncDevice-     Handle of the Sync device"]
    #[doc = "! \\param [in]  hPhysicalGpu-       GPU to be queried for sync status."]
    #[doc = "! \\param [out] *status-            The caller provides the storage space. NvAPI_GSync_GetSyncStatus() populates *status with"]
    #[doc = "!                                  values - timing, stereosync and signal availability. On error, *status is set to NULL."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!          If there are return error codes with specific meaning for this API, they are listed below."]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT          hNvGSyncDevice is NULL / SyncTarget is NULL."]
    #[doc = "! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any G-Sync Device."]
    #[doc = "!"]
    #[doc = "! \\ingroup gsyncapi"]
    #[doc = ""]
    pub fn NvAPI_GSync_GetSyncStatus(
        hNvGSyncDevice: NvGSyncDeviceHandle,
        hPhysicalGpu: NvPhysicalGpuHandle,
        status: *mut NV_GSYNC_STATUS,
    ) -> NvAPI_Status;
}
pub const _NVAPI_GSYNC_RJ45_IO_NVAPI_GSYNC_RJ45_OUTPUT: _NVAPI_GSYNC_RJ45_IO = 0;
pub const _NVAPI_GSYNC_RJ45_IO_NVAPI_GSYNC_RJ45_INPUT: _NVAPI_GSYNC_RJ45_IO = 1;
#[doc = "!< This field is used to notify that the framelock is not actually present."]
pub const _NVAPI_GSYNC_RJ45_IO_NVAPI_GSYNC_RJ45_UNUSED: _NVAPI_GSYNC_RJ45_IO = 2;
#[doc = "! Used in NV_GSYNC_STATUS_PARAMS."]
pub type _NVAPI_GSYNC_RJ45_IO = ::std::os::raw::c_int;
#[doc = "! Used in NV_GSYNC_STATUS_PARAMS."]
pub use self::_NVAPI_GSYNC_RJ45_IO as NVAPI_GSYNC_RJ45_IO;
#[doc = "! \\ingroup gsyncapi"]
#[doc = "! Used in NvAPI_GSync_GetStatusParameters()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GSYNC_STATUS_PARAMS_V1 {
    pub version: NvU32,
    #[doc = "!< The refresh rate"]
    pub refreshRate: NvU32,
    #[doc = "!< Configured as input / output"]
    pub RJ45_IO: [NVAPI_GSYNC_RJ45_IO; 2usize],
    #[doc = "!< Connected to ethernet hub? [ERRONEOUSLY CONNECTED!]"]
    pub RJ45_Ethernet: [NvU32; 2usize],
    #[doc = "!< Incoming house sync frequency in Hz"]
    pub houseSyncIncoming: NvU32,
    #[doc = "!< Is house sync connected?"]
    pub bHouseSync: NvU32,
}
#[test]
fn bindgen_test_layout__NV_GSYNC_STATUS_PARAMS_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GSYNC_STATUS_PARAMS_V1>(),
        32usize,
        concat!("Size of: ", stringify!(_NV_GSYNC_STATUS_PARAMS_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GSYNC_STATUS_PARAMS_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GSYNC_STATUS_PARAMS_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_STATUS_PARAMS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_STATUS_PARAMS_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_refreshRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_STATUS_PARAMS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).refreshRate) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_STATUS_PARAMS_V1),
                "::",
                stringify!(refreshRate)
            )
        );
    }
    test_field_refreshRate();
    fn test_field_RJ45_IO() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_STATUS_PARAMS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).RJ45_IO) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_STATUS_PARAMS_V1),
                "::",
                stringify!(RJ45_IO)
            )
        );
    }
    test_field_RJ45_IO();
    fn test_field_RJ45_Ethernet() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_STATUS_PARAMS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).RJ45_Ethernet) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_STATUS_PARAMS_V1),
                "::",
                stringify!(RJ45_Ethernet)
            )
        );
    }
    test_field_RJ45_Ethernet();
    fn test_field_houseSyncIncoming() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_STATUS_PARAMS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).houseSyncIncoming) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_STATUS_PARAMS_V1),
                "::",
                stringify!(houseSyncIncoming)
            )
        );
    }
    test_field_houseSyncIncoming();
    fn test_field_bHouseSync() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_STATUS_PARAMS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bHouseSync) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_STATUS_PARAMS_V1),
                "::",
                stringify!(bHouseSync)
            )
        );
    }
    test_field_bHouseSync();
}
impl Default for _NV_GSYNC_STATUS_PARAMS_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\ingroup gsyncapi"]
#[doc = "! Used in NvAPI_GSync_GetStatusParameters()."]
pub type NV_GSYNC_STATUS_PARAMS_V1 = _NV_GSYNC_STATUS_PARAMS_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GSYNC_STATUS_PARAMS_V2 {
    pub version: NvU32,
    #[doc = "!< The refresh rate"]
    pub refreshRate: NvU32,
    #[doc = "!< Configured as input / output"]
    pub RJ45_IO: [NVAPI_GSYNC_RJ45_IO; 2usize],
    #[doc = "!< Connected to ethernet hub? [ERRONEOUSLY CONNECTED!]"]
    pub RJ45_Ethernet: [NvU32; 2usize],
    #[doc = "!< Incoming house sync frequency in Hz"]
    pub houseSyncIncoming: NvU32,
    #[doc = "!< Is house sync connected?"]
    pub bHouseSync: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NV_GSYNC_STATUS_PARAMS_V2() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GSYNC_STATUS_PARAMS_V2>(),
        36usize,
        concat!("Size of: ", stringify!(_NV_GSYNC_STATUS_PARAMS_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GSYNC_STATUS_PARAMS_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GSYNC_STATUS_PARAMS_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_STATUS_PARAMS_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_STATUS_PARAMS_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_refreshRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_STATUS_PARAMS_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).refreshRate) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_STATUS_PARAMS_V2),
                "::",
                stringify!(refreshRate)
            )
        );
    }
    test_field_refreshRate();
    fn test_field_RJ45_IO() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_STATUS_PARAMS_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).RJ45_IO) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_STATUS_PARAMS_V2),
                "::",
                stringify!(RJ45_IO)
            )
        );
    }
    test_field_RJ45_IO();
    fn test_field_RJ45_Ethernet() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_STATUS_PARAMS_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).RJ45_Ethernet) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_STATUS_PARAMS_V2),
                "::",
                stringify!(RJ45_Ethernet)
            )
        );
    }
    test_field_RJ45_Ethernet();
    fn test_field_houseSyncIncoming() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_STATUS_PARAMS_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).houseSyncIncoming) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_STATUS_PARAMS_V2),
                "::",
                stringify!(houseSyncIncoming)
            )
        );
    }
    test_field_houseSyncIncoming();
    fn test_field_bHouseSync() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GSYNC_STATUS_PARAMS_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bHouseSync) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GSYNC_STATUS_PARAMS_V2),
                "::",
                stringify!(bHouseSync)
            )
        );
    }
    test_field_bHouseSync();
}
impl Default for _NV_GSYNC_STATUS_PARAMS_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_GSYNC_STATUS_PARAMS_V2 {
    #[inline]
    pub fn bInternalSlave(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bInternalSlave(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bInternalSlave: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bInternalSlave: u32 = unsafe { ::std::mem::transmute(bInternalSlave) };
            bInternalSlave as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GSYNC_STATUS_PARAMS_V2 = _NV_GSYNC_STATUS_PARAMS_V2;
pub type NV_GSYNC_STATUS_PARAMS = NV_GSYNC_STATUS_PARAMS_V2;
extern "C" {
    #[doc = "!   DESCRIPTION: This API queries for sync status parameters as defined in NV_GSYNC_STATUS_PARAMS."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 313"]
    #[doc = "!"]
    #[doc = "! \\param [in]  hNvGSyncDevice   The caller provides the handle of the GSync device for which to get parameters"]
    #[doc = "! \\param [out] *pStatusParams   The caller provides the storage space. NvAPI_GSync_GetStatusParameters populates *pStatusParams with"]
    #[doc = "!                               values."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!          If there are return error codes with specific meaning for this API, they are listed below."]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT            hNvGSyncDevice is NULL / pStatusParams is NULL."]
    #[doc = "! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND     The queried Graphics system does not have any GSync Device."]
    #[doc = "!"]
    #[doc = "! \\ingroup gsyncapi"]
    #[doc = ""]
    pub fn NvAPI_GSync_GetStatusParameters(
        hNvGSyncDevice: NvGSyncDeviceHandle,
        pStatusParams: *mut NV_GSYNC_STATUS_PARAMS,
    ) -> NvAPI_Status;
}
pub const _NV_RESOLVE_MODE_NV_RESOLVE_MODE_SAMPLE_0: _NV_RESOLVE_MODE = 0;
#[doc = "! \\ingroup dx"]
#[doc = "! Valid modes for NvAPI_D3D11_ResolveSubresourceRegion() and NvAPI_D3D12_ResolveSubresourceRegion"]
pub type _NV_RESOLVE_MODE = ::std::os::raw::c_int;
#[doc = "! \\ingroup dx"]
#[doc = "! Valid modes for NvAPI_D3D11_ResolveSubresourceRegion() and NvAPI_D3D12_ResolveSubresourceRegion"]
pub use self::_NV_RESOLVE_MODE as NV_RESOLVE_MODE;
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used to query the support of Single Pass Stereo HW feature"]
#[doc = "! \\ingroup dx"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1 {
    pub version: NvU32,
    pub bSinglePassStereoSupported: NvU32,
}
#[test]
fn bindgen_test_layout__NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_bSinglePassStereoSupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bSinglePassStereoSupported) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1),
                "::",
                stringify!(bSinglePassStereoSupported)
            )
        );
    }
    test_field_bSinglePassStereoSupported();
}
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used to query the support of Single Pass Stereo HW feature"]
#[doc = "! \\ingroup dx"]
pub type NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1 =
    _NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2() {
    assert_eq!(
        ::std::mem::size_of::<_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
}
impl _NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2 {
    #[inline]
    pub fn bSinglePassStereoSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bSinglePassStereoSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bSinglePassStereoXYZWSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bSinglePassStereoXYZWSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bSinglePassStereoSupported: NvU32,
        bSinglePassStereoXYZWSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bSinglePassStereoSupported: u32 =
                unsafe { ::std::mem::transmute(bSinglePassStereoSupported) };
            bSinglePassStereoSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bSinglePassStereoXYZWSupported: u32 =
                unsafe { ::std::mem::transmute(bSinglePassStereoXYZWSupported) };
            bSinglePassStereoXYZWSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2 =
    _NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2;
pub type NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS = NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2;
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used to query the support of MultiView HW feature"]
#[doc = "! \\ingroup dx"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
}
impl _NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1 {
    #[inline]
    pub fn bMultiViewSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bMultiViewSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bSinglePassStereoSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bSinglePassStereoSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bSinglePassStereoXYZWSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bSinglePassStereoXYZWSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bMultiViewSupported: NvU32,
        bSinglePassStereoSupported: NvU32,
        bSinglePassStereoXYZWSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bMultiViewSupported: u32 = unsafe { ::std::mem::transmute(bMultiViewSupported) };
            bMultiViewSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bSinglePassStereoSupported: u32 =
                unsafe { ::std::mem::transmute(bSinglePassStereoSupported) };
            bSinglePassStereoSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bSinglePassStereoXYZWSupported: u32 =
                unsafe { ::std::mem::transmute(bSinglePassStereoXYZWSupported) };
            bSinglePassStereoXYZWSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used to query the support of MultiView HW feature"]
#[doc = "! \\ingroup dx"]
pub type NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1 = _NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1;
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used to query the support of MultiView HW feature"]
#[doc = "! \\ingroup dx"]
pub type NV_QUERY_MULTIVIEW_SUPPORT_PARAMS = NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1;
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used for setting the Mode for MultiView HW Feature."]
#[doc = "! \\ingroup dx"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_MULTIVIEW_PARAMS_V1 {
    pub version: NvU32,
    pub numViews: NvU32,
    pub renderTargetIndexOffset: [NvU32; 4usize],
    pub independentViewportMaskEnable: NvU8,
}
#[test]
fn bindgen_test_layout__NV_MULTIVIEW_PARAMS_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_MULTIVIEW_PARAMS_V1>(),
        28usize,
        concat!("Size of: ", stringify!(_NV_MULTIVIEW_PARAMS_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MULTIVIEW_PARAMS_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_MULTIVIEW_PARAMS_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MULTIVIEW_PARAMS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MULTIVIEW_PARAMS_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_numViews() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MULTIVIEW_PARAMS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numViews) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MULTIVIEW_PARAMS_V1),
                "::",
                stringify!(numViews)
            )
        );
    }
    test_field_numViews();
    fn test_field_renderTargetIndexOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MULTIVIEW_PARAMS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).renderTargetIndexOffset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MULTIVIEW_PARAMS_V1),
                "::",
                stringify!(renderTargetIndexOffset)
            )
        );
    }
    test_field_renderTargetIndexOffset();
    fn test_field_independentViewportMaskEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MULTIVIEW_PARAMS_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).independentViewportMaskEnable) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MULTIVIEW_PARAMS_V1),
                "::",
                stringify!(independentViewportMaskEnable)
            )
        );
    }
    test_field_independentViewportMaskEnable();
}
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used for setting the Mode for MultiView HW Feature."]
#[doc = "! \\ingroup dx"]
pub type NV_MULTIVIEW_PARAMS_V1 = _NV_MULTIVIEW_PARAMS_V1;
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used for setting the Mode for MultiView HW Feature."]
#[doc = "! \\ingroup dx"]
pub type NV_MULTIVIEW_PARAMS = NV_MULTIVIEW_PARAMS_V1;
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used to query the support of Lens Matched Shading HW feature"]
#[doc = "! \\ingroup dx"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_QUERY_MODIFIED_W_SUPPORT_PARAMS {
    pub version: NvU32,
    pub bModifiedWSupported: NvU32,
}
#[test]
fn bindgen_test_layout__NV_QUERY_MODIFIED_W_SUPPORT_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_QUERY_MODIFIED_W_SUPPORT_PARAMS>(),
        8usize,
        concat!("Size of: ", stringify!(_NV_QUERY_MODIFIED_W_SUPPORT_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_QUERY_MODIFIED_W_SUPPORT_PARAMS>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_QUERY_MODIFIED_W_SUPPORT_PARAMS)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_QUERY_MODIFIED_W_SUPPORT_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_QUERY_MODIFIED_W_SUPPORT_PARAMS),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_bModifiedWSupported() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_QUERY_MODIFIED_W_SUPPORT_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bModifiedWSupported) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_QUERY_MODIFIED_W_SUPPORT_PARAMS),
                "::",
                stringify!(bModifiedWSupported)
            )
        );
    }
    test_field_bModifiedWSupported();
}
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used to query the support of Lens Matched Shading HW feature"]
#[doc = "! \\ingroup dx"]
pub type NV_QUERY_MODIFIED_W_SUPPORT_PARAMS_V1 = _NV_QUERY_MODIFIED_W_SUPPORT_PARAMS;
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used to query the support of Lens Matched Shading HW feature"]
#[doc = "! \\ingroup dx"]
pub type NV_QUERY_MODIFIED_W_SUPPORT_PARAMS = NV_QUERY_MODIFIED_W_SUPPORT_PARAMS_V1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_MODIFIED_W_COEFFICIENTS {
    pub fA: f32,
    pub fB: f32,
    pub fAReserved: f32,
    pub fBReserved: f32,
    pub fReserved: [f32; 2usize],
}
#[test]
fn bindgen_test_layout__NV_MODIFIED_W_COEFFICIENTS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_MODIFIED_W_COEFFICIENTS>(),
        24usize,
        concat!("Size of: ", stringify!(_NV_MODIFIED_W_COEFFICIENTS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MODIFIED_W_COEFFICIENTS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_MODIFIED_W_COEFFICIENTS))
    );
    fn test_field_fA() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MODIFIED_W_COEFFICIENTS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fA) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MODIFIED_W_COEFFICIENTS),
                "::",
                stringify!(fA)
            )
        );
    }
    test_field_fA();
    fn test_field_fB() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MODIFIED_W_COEFFICIENTS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fB) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MODIFIED_W_COEFFICIENTS),
                "::",
                stringify!(fB)
            )
        );
    }
    test_field_fB();
    fn test_field_fAReserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MODIFIED_W_COEFFICIENTS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fAReserved) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MODIFIED_W_COEFFICIENTS),
                "::",
                stringify!(fAReserved)
            )
        );
    }
    test_field_fAReserved();
    fn test_field_fBReserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MODIFIED_W_COEFFICIENTS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fBReserved) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MODIFIED_W_COEFFICIENTS),
                "::",
                stringify!(fBReserved)
            )
        );
    }
    test_field_fBReserved();
    fn test_field_fReserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MODIFIED_W_COEFFICIENTS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fReserved) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MODIFIED_W_COEFFICIENTS),
                "::",
                stringify!(fReserved)
            )
        );
    }
    test_field_fReserved();
}
pub type NV_MODIFIED_W_COEFFICIENTS = _NV_MODIFIED_W_COEFFICIENTS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_MODIFIED_W_PARAMS {
    pub version: NvU32,
    pub numEntries: NvU32,
    pub modifiedWCoefficients: [NV_MODIFIED_W_COEFFICIENTS; 16usize],
    pub id: NvU32,
    pub reserved: [NvU32; 16usize],
}
#[test]
fn bindgen_test_layout__NV_MODIFIED_W_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_MODIFIED_W_PARAMS>(),
        460usize,
        concat!("Size of: ", stringify!(_NV_MODIFIED_W_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MODIFIED_W_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_MODIFIED_W_PARAMS))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MODIFIED_W_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MODIFIED_W_PARAMS),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_numEntries() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MODIFIED_W_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numEntries) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MODIFIED_W_PARAMS),
                "::",
                stringify!(numEntries)
            )
        );
    }
    test_field_numEntries();
    fn test_field_modifiedWCoefficients() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MODIFIED_W_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).modifiedWCoefficients) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MODIFIED_W_PARAMS),
                "::",
                stringify!(modifiedWCoefficients)
            )
        );
    }
    test_field_modifiedWCoefficients();
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MODIFIED_W_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MODIFIED_W_PARAMS),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_MODIFIED_W_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            396usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_MODIFIED_W_PARAMS),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type NV_MODIFIED_W_PARAMS_V1 = _NV_MODIFIED_W_PARAMS;
pub type NV_MODIFIED_W_PARAMS = NV_MODIFIED_W_PARAMS_V1;
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used to get sleep status"]
#[doc = "! \\ingroup dx"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GET_SLEEP_STATUS_PARAMS {
    #[doc = "!< (IN) Structure version"]
    pub version: NvU32,
    #[doc = "!< (OUT) Is low latency mode enabled?"]
    pub bLowLatencyMode: NvBool,
    #[doc = "!< (IN) Reserved. Must be set to 0s."]
    pub rsvd: [NvU8; 128usize],
}
#[test]
fn bindgen_test_layout__NV_GET_SLEEP_STATUS_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GET_SLEEP_STATUS_PARAMS>(),
        136usize,
        concat!("Size of: ", stringify!(_NV_GET_SLEEP_STATUS_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GET_SLEEP_STATUS_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GET_SLEEP_STATUS_PARAMS))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GET_SLEEP_STATUS_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GET_SLEEP_STATUS_PARAMS),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_bLowLatencyMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GET_SLEEP_STATUS_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bLowLatencyMode) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GET_SLEEP_STATUS_PARAMS),
                "::",
                stringify!(bLowLatencyMode)
            )
        );
    }
    test_field_bLowLatencyMode();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_GET_SLEEP_STATUS_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GET_SLEEP_STATUS_PARAMS),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_GET_SLEEP_STATUS_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used to get sleep status"]
#[doc = "! \\ingroup dx"]
pub type NV_GET_SLEEP_STATUS_PARAMS_V1 = _NV_GET_SLEEP_STATUS_PARAMS;
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used to get sleep status"]
#[doc = "! \\ingroup dx"]
pub type NV_GET_SLEEP_STATUS_PARAMS = NV_GET_SLEEP_STATUS_PARAMS_V1;
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used to set sleep mode"]
#[doc = "! \\ingroup dx"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NV_SET_SLEEP_MODE_PARAMS {
    #[doc = "!< (IN) Structure version"]
    pub version: NvU32,
    #[doc = "!< (IN) Low latency mode enable/disable."]
    pub bLowLatencyMode: NvBool,
    #[doc = "!< (IN) Request maximum GPU clock frequency regardless of workload."]
    pub bLowLatencyBoost: NvBool,
    #[doc = "!< (IN) Minimum frame interval in microseconds. 0 = no frame rate limit."]
    pub minimumIntervalUs: NvU32,
    #[doc = "!< (IN) Allow latency markers to be used for runtime optimizations."]
    pub bUseMarkersToOptimize: NvBool,
    #[doc = "!< (IN) Reserved. Must be set to 0s."]
    pub rsvd: [NvU8; 31usize],
}
#[test]
fn bindgen_test_layout__NV_SET_SLEEP_MODE_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_SET_SLEEP_MODE_PARAMS>(),
        44usize,
        concat!("Size of: ", stringify!(_NV_SET_SLEEP_MODE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_SET_SLEEP_MODE_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_SET_SLEEP_MODE_PARAMS))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_SET_SLEEP_MODE_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SET_SLEEP_MODE_PARAMS),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_bLowLatencyMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_SET_SLEEP_MODE_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bLowLatencyMode) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SET_SLEEP_MODE_PARAMS),
                "::",
                stringify!(bLowLatencyMode)
            )
        );
    }
    test_field_bLowLatencyMode();
    fn test_field_bLowLatencyBoost() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_SET_SLEEP_MODE_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bLowLatencyBoost) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SET_SLEEP_MODE_PARAMS),
                "::",
                stringify!(bLowLatencyBoost)
            )
        );
    }
    test_field_bLowLatencyBoost();
    fn test_field_minimumIntervalUs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_SET_SLEEP_MODE_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minimumIntervalUs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SET_SLEEP_MODE_PARAMS),
                "::",
                stringify!(minimumIntervalUs)
            )
        );
    }
    test_field_minimumIntervalUs();
    fn test_field_bUseMarkersToOptimize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_SET_SLEEP_MODE_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bUseMarkersToOptimize) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SET_SLEEP_MODE_PARAMS),
                "::",
                stringify!(bUseMarkersToOptimize)
            )
        );
    }
    test_field_bUseMarkersToOptimize();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_SET_SLEEP_MODE_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            13usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_SET_SLEEP_MODE_PARAMS),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used to set sleep mode"]
#[doc = "! \\ingroup dx"]
pub type NV_SET_SLEEP_MODE_PARAMS_V1 = _NV_SET_SLEEP_MODE_PARAMS;
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used to set sleep mode"]
#[doc = "! \\ingroup dx"]
pub type NV_SET_SLEEP_MODE_PARAMS = NV_SET_SLEEP_MODE_PARAMS_V1;
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used to get latency report."]
#[doc = "! \\ingroup dx"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LATENCY_RESULT_PARAMS {
    #[doc = "!< (IN) Structure version"]
    pub version: NvU32,
    pub frameReport: [_NV_LATENCY_RESULT_PARAMS_FrameReport; 64usize],
    pub rsvd: [NvU8; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LATENCY_RESULT_PARAMS_FrameReport {
    pub frameID: NvU64,
    pub inputSampleTime: NvU64,
    pub simStartTime: NvU64,
    pub simEndTime: NvU64,
    pub renderSubmitStartTime: NvU64,
    pub renderSubmitEndTime: NvU64,
    pub presentStartTime: NvU64,
    pub presentEndTime: NvU64,
    pub driverStartTime: NvU64,
    pub driverEndTime: NvU64,
    pub osRenderQueueStartTime: NvU64,
    pub osRenderQueueEndTime: NvU64,
    pub gpuRenderStartTime: NvU64,
    pub gpuRenderEndTime: NvU64,
    #[doc = "!< (OUT) Difference between gpuRenderStartTime and gpuRenderEndTime, excluding the idles in between, in microseconds."]
    pub gpuActiveRenderTimeUs: NvU32,
    #[doc = "!< (OUT) Difference between previous and current frame's gpuRenderEndTime, in microseconds."]
    pub gpuFrameTimeUs: NvU32,
    pub rsvd: [NvU8; 120usize],
}
#[test]
fn bindgen_test_layout__NV_LATENCY_RESULT_PARAMS_FrameReport() {
    assert_eq!(
        ::std::mem::size_of::<_NV_LATENCY_RESULT_PARAMS_FrameReport>(),
        240usize,
        concat!(
            "Size of: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LATENCY_RESULT_PARAMS_FrameReport>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport)
        )
    );
    fn test_field_frameID() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_LATENCY_RESULT_PARAMS_FrameReport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frameID) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
                "::",
                stringify!(frameID)
            )
        );
    }
    test_field_frameID();
    fn test_field_inputSampleTime() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_LATENCY_RESULT_PARAMS_FrameReport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inputSampleTime) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
                "::",
                stringify!(inputSampleTime)
            )
        );
    }
    test_field_inputSampleTime();
    fn test_field_simStartTime() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_LATENCY_RESULT_PARAMS_FrameReport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).simStartTime) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
                "::",
                stringify!(simStartTime)
            )
        );
    }
    test_field_simStartTime();
    fn test_field_simEndTime() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_LATENCY_RESULT_PARAMS_FrameReport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).simEndTime) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
                "::",
                stringify!(simEndTime)
            )
        );
    }
    test_field_simEndTime();
    fn test_field_renderSubmitStartTime() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_LATENCY_RESULT_PARAMS_FrameReport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).renderSubmitStartTime) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
                "::",
                stringify!(renderSubmitStartTime)
            )
        );
    }
    test_field_renderSubmitStartTime();
    fn test_field_renderSubmitEndTime() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_LATENCY_RESULT_PARAMS_FrameReport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).renderSubmitEndTime) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
                "::",
                stringify!(renderSubmitEndTime)
            )
        );
    }
    test_field_renderSubmitEndTime();
    fn test_field_presentStartTime() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_LATENCY_RESULT_PARAMS_FrameReport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).presentStartTime) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
                "::",
                stringify!(presentStartTime)
            )
        );
    }
    test_field_presentStartTime();
    fn test_field_presentEndTime() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_LATENCY_RESULT_PARAMS_FrameReport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).presentEndTime) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
                "::",
                stringify!(presentEndTime)
            )
        );
    }
    test_field_presentEndTime();
    fn test_field_driverStartTime() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_LATENCY_RESULT_PARAMS_FrameReport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).driverStartTime) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
                "::",
                stringify!(driverStartTime)
            )
        );
    }
    test_field_driverStartTime();
    fn test_field_driverEndTime() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_LATENCY_RESULT_PARAMS_FrameReport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).driverEndTime) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
                "::",
                stringify!(driverEndTime)
            )
        );
    }
    test_field_driverEndTime();
    fn test_field_osRenderQueueStartTime() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_LATENCY_RESULT_PARAMS_FrameReport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).osRenderQueueStartTime) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
                "::",
                stringify!(osRenderQueueStartTime)
            )
        );
    }
    test_field_osRenderQueueStartTime();
    fn test_field_osRenderQueueEndTime() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_LATENCY_RESULT_PARAMS_FrameReport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).osRenderQueueEndTime) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
                "::",
                stringify!(osRenderQueueEndTime)
            )
        );
    }
    test_field_osRenderQueueEndTime();
    fn test_field_gpuRenderStartTime() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_LATENCY_RESULT_PARAMS_FrameReport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gpuRenderStartTime) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
                "::",
                stringify!(gpuRenderStartTime)
            )
        );
    }
    test_field_gpuRenderStartTime();
    fn test_field_gpuRenderEndTime() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_LATENCY_RESULT_PARAMS_FrameReport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gpuRenderEndTime) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
                "::",
                stringify!(gpuRenderEndTime)
            )
        );
    }
    test_field_gpuRenderEndTime();
    fn test_field_gpuActiveRenderTimeUs() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_LATENCY_RESULT_PARAMS_FrameReport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gpuActiveRenderTimeUs) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
                "::",
                stringify!(gpuActiveRenderTimeUs)
            )
        );
    }
    test_field_gpuActiveRenderTimeUs();
    fn test_field_gpuFrameTimeUs() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_LATENCY_RESULT_PARAMS_FrameReport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gpuFrameTimeUs) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
                "::",
                stringify!(gpuFrameTimeUs)
            )
        );
    }
    test_field_gpuFrameTimeUs();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_LATENCY_RESULT_PARAMS_FrameReport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_LATENCY_RESULT_PARAMS_FrameReport {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__NV_LATENCY_RESULT_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_LATENCY_RESULT_PARAMS>(),
        15400usize,
        concat!("Size of: ", stringify!(_NV_LATENCY_RESULT_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LATENCY_RESULT_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_LATENCY_RESULT_PARAMS))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LATENCY_RESULT_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_RESULT_PARAMS),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_frameReport() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LATENCY_RESULT_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frameReport) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_RESULT_PARAMS),
                "::",
                stringify!(frameReport)
            )
        );
    }
    test_field_frameReport();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LATENCY_RESULT_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            15368usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_RESULT_PARAMS),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_LATENCY_RESULT_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used to get latency report."]
#[doc = "! \\ingroup dx"]
pub type NV_LATENCY_RESULT_PARAMS_V1 = _NV_LATENCY_RESULT_PARAMS;
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used to get latency report."]
#[doc = "! \\ingroup dx"]
pub type NV_LATENCY_RESULT_PARAMS = NV_LATENCY_RESULT_PARAMS_V1;
pub const NV_LATENCY_MARKER_TYPE_SIMULATION_START: NV_LATENCY_MARKER_TYPE = 0;
pub const NV_LATENCY_MARKER_TYPE_SIMULATION_END: NV_LATENCY_MARKER_TYPE = 1;
pub const NV_LATENCY_MARKER_TYPE_RENDERSUBMIT_START: NV_LATENCY_MARKER_TYPE = 2;
pub const NV_LATENCY_MARKER_TYPE_RENDERSUBMIT_END: NV_LATENCY_MARKER_TYPE = 3;
pub const NV_LATENCY_MARKER_TYPE_PRESENT_START: NV_LATENCY_MARKER_TYPE = 4;
pub const NV_LATENCY_MARKER_TYPE_PRESENT_END: NV_LATENCY_MARKER_TYPE = 5;
pub const NV_LATENCY_MARKER_TYPE_INPUT_SAMPLE: NV_LATENCY_MARKER_TYPE = 6;
pub const NV_LATENCY_MARKER_TYPE_TRIGGER_FLASH: NV_LATENCY_MARKER_TYPE = 7;
pub const NV_LATENCY_MARKER_TYPE_PC_LATENCY_PING: NV_LATENCY_MARKER_TYPE = 8;
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used define latency marker type"]
#[doc = "! \\ingroup dx"]
pub type NV_LATENCY_MARKER_TYPE = ::std::os::raw::c_int;
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used set latency markers"]
#[doc = "! \\ingroup dx"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LATENCY_MARKER_PARAMS {
    #[doc = "!< (IN) Structure version"]
    pub version: NvU32,
    pub frameID: NvU64,
    pub markerType: NV_LATENCY_MARKER_TYPE,
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_LATENCY_MARKER_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_LATENCY_MARKER_PARAMS>(),
        88usize,
        concat!("Size of: ", stringify!(_NV_LATENCY_MARKER_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LATENCY_MARKER_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_LATENCY_MARKER_PARAMS))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LATENCY_MARKER_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_MARKER_PARAMS),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_frameID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LATENCY_MARKER_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frameID) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_MARKER_PARAMS),
                "::",
                stringify!(frameID)
            )
        );
    }
    test_field_frameID();
    fn test_field_markerType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LATENCY_MARKER_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).markerType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_MARKER_PARAMS),
                "::",
                stringify!(markerType)
            )
        );
    }
    test_field_markerType();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_LATENCY_MARKER_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_LATENCY_MARKER_PARAMS),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_LATENCY_MARKER_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used set latency markers"]
#[doc = "! \\ingroup dx"]
pub type NV_LATENCY_MARKER_PARAMS_V1 = _NV_LATENCY_MARKER_PARAMS;
#[doc = "! SUPPORTED OS:  Windows 7 and higher"]
#[doc = "!"]
#[doc = "! Used set latency markers"]
#[doc = "! \\ingroup dx"]
pub type NV_LATENCY_MARKER_PARAMS = NV_LATENCY_MARKER_PARAMS_V1;
#[doc = "! \\ingroup vidio"]
#[doc = "! Unique identifier for VIO owner (process identifier or NVVIOOWNERID_NONE)"]
pub type NVVIOOWNERID = NvU32;
#[doc = "!<  No owner for the device"]
pub const _NVVIOOWNERTYPE_NVVIOOWNERTYPE_NONE: _NVVIOOWNERTYPE = 0;
#[doc = "!<  Application owns the device"]
pub const _NVVIOOWNERTYPE_NVVIOOWNERTYPE_APPLICATION: _NVVIOOWNERTYPE = 1;
#[doc = "!<  Desktop transparent mode owns the device (not applicable for video input)"]
pub const _NVVIOOWNERTYPE_NVVIOOWNERTYPE_DESKTOP: _NVVIOOWNERTYPE = 2;
#[doc = "! Owner type for device"]
pub type _NVVIOOWNERTYPE = ::std::os::raw::c_int;
#[doc = "! Owner type for device"]
pub use self::_NVVIOOWNERTYPE as NVVIOOWNERTYPE;
#[doc = "!< Invalid signal format"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_NONE: _NVVIOSIGNALFORMAT = 0;
#[doc = "!< 01  487i    59.94Hz  (SMPTE259) NTSC"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_487I_59_94_SMPTE259_NTSC: _NVVIOSIGNALFORMAT = 1;
#[doc = "!< 02  576i    50.00Hz  (SMPTE259) PAL"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_576I_50_00_SMPTE259_PAL: _NVVIOSIGNALFORMAT = 2;
#[doc = "!< 03  1035i   60.00Hz  (SMPTE260)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1035I_60_00_SMPTE260: _NVVIOSIGNALFORMAT = 3;
#[doc = "!< 04  1035i   59.94Hz  (SMPTE260)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1035I_59_94_SMPTE260: _NVVIOSIGNALFORMAT = 4;
#[doc = "!< 05  1080i   50.00Hz  (SMPTE295)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_50_00_SMPTE295: _NVVIOSIGNALFORMAT = 5;
#[doc = "!< 06  1080i   60.00Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_60_00_SMPTE274: _NVVIOSIGNALFORMAT = 6;
#[doc = "!< 07  1080i   59.94Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_59_94_SMPTE274: _NVVIOSIGNALFORMAT = 7;
#[doc = "!< 08  1080i   50.00Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_50_00_SMPTE274: _NVVIOSIGNALFORMAT = 8;
#[doc = "!< 09  1080p   30.00Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_30_00_SMPTE274: _NVVIOSIGNALFORMAT = 9;
#[doc = "!< 10  1080p   29.97Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_29_97_SMPTE274: _NVVIOSIGNALFORMAT = 10;
#[doc = "!< 11  1080p   25.00Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_25_00_SMPTE274: _NVVIOSIGNALFORMAT = 11;
#[doc = "!< 12  1080p   24.00Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_24_00_SMPTE274: _NVVIOSIGNALFORMAT = 12;
#[doc = "!< 13  1080p   23.976Hz (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_23_976_SMPTE274: _NVVIOSIGNALFORMAT = 13;
#[doc = "!< 14  720p    60.00Hz  (SMPTE296)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_720P_60_00_SMPTE296: _NVVIOSIGNALFORMAT = 14;
#[doc = "!< 15  720p    59.94Hz  (SMPTE296)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_720P_59_94_SMPTE296: _NVVIOSIGNALFORMAT = 15;
#[doc = "!< 16  720p    50.00Hz  (SMPTE296)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_720P_50_00_SMPTE296: _NVVIOSIGNALFORMAT = 16;
#[doc = "!< 17  1080I   48.00Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_48_00_SMPTE274: _NVVIOSIGNALFORMAT = 17;
#[doc = "!< 18  1080I   47.96Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_47_96_SMPTE274: _NVVIOSIGNALFORMAT = 18;
#[doc = "!< 19  720p    30.00Hz  (SMPTE296)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_720P_30_00_SMPTE296: _NVVIOSIGNALFORMAT = 19;
#[doc = "!< 20  720p    29.97Hz  (SMPTE296)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_720P_29_97_SMPTE296: _NVVIOSIGNALFORMAT = 20;
#[doc = "!< 21  720p    25.00Hz  (SMPTE296)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_720P_25_00_SMPTE296: _NVVIOSIGNALFORMAT = 21;
#[doc = "!< 22  720p    24.00Hz  (SMPTE296)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_720P_24_00_SMPTE296: _NVVIOSIGNALFORMAT = 22;
#[doc = "!< 23  720p    23.98Hz  (SMPTE296)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_720P_23_98_SMPTE296: _NVVIOSIGNALFORMAT = 23;
#[doc = "!< 24  2048p   30.00Hz  (SMPTE372)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048P_30_00_SMPTE372: _NVVIOSIGNALFORMAT = 24;
#[doc = "!< 25  2048p   29.97Hz  (SMPTE372)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048P_29_97_SMPTE372: _NVVIOSIGNALFORMAT = 25;
#[doc = "!< 26  2048i   60.00Hz  (SMPTE372)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048I_60_00_SMPTE372: _NVVIOSIGNALFORMAT = 26;
#[doc = "!< 27  2048i   59.94Hz  (SMPTE372)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048I_59_94_SMPTE372: _NVVIOSIGNALFORMAT = 27;
#[doc = "!< 28  2048p   25.00Hz  (SMPTE372)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048P_25_00_SMPTE372: _NVVIOSIGNALFORMAT = 28;
#[doc = "!< 29  2048i   50.00Hz  (SMPTE372)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048I_50_00_SMPTE372: _NVVIOSIGNALFORMAT = 29;
#[doc = "!< 30  2048p   24.00Hz  (SMPTE372)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048P_24_00_SMPTE372: _NVVIOSIGNALFORMAT = 30;
#[doc = "!< 31  2048p   23.98Hz  (SMPTE372)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048P_23_98_SMPTE372: _NVVIOSIGNALFORMAT = 31;
#[doc = "!< 32  2048i   48.00Hz  (SMPTE372)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048I_48_00_SMPTE372: _NVVIOSIGNALFORMAT = 32;
#[doc = "!< 33  2048i   47.96Hz  (SMPTE372)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048I_47_96_SMPTE372: _NVVIOSIGNALFORMAT = 33;
#[doc = "!< 34  1080PsF 25.00Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080PSF_25_00_SMPTE274: _NVVIOSIGNALFORMAT = 34;
#[doc = "!< 35  1080PsF 29.97Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080PSF_29_97_SMPTE274: _NVVIOSIGNALFORMAT = 35;
#[doc = "!< 36  1080PsF 30.00Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080PSF_30_00_SMPTE274: _NVVIOSIGNALFORMAT = 36;
#[doc = "!< 37  1080PsF 24.00Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080PSF_24_00_SMPTE274: _NVVIOSIGNALFORMAT = 37;
#[doc = "!< 38  1080PsF 23.98Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080PSF_23_98_SMPTE274: _NVVIOSIGNALFORMAT = 38;
#[doc = "!< 39  1080P   50.00Hz  (SMPTE274) 3G Level A"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_50_00_SMPTE274_3G_LEVEL_A: _NVVIOSIGNALFORMAT =
    39;
#[doc = "!< 40  1080P   59.94Hz  (SMPTE274) 3G Level A"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_59_94_SMPTE274_3G_LEVEL_A: _NVVIOSIGNALFORMAT =
    40;
#[doc = "!< 41  1080P   60.00Hz  (SMPTE274) 3G Level A"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_60_00_SMPTE274_3G_LEVEL_A: _NVVIOSIGNALFORMAT =
    41;
#[doc = "!< 42  1080p   60.00Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_60_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    42;
#[doc = "!< 43  1080i   60.00Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_60_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    43;
#[doc = "!< 44  2048i   60.00Hz  (SMPTE372) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048I_60_00_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    44;
#[doc = "!< 45  1080p   50.00Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_50_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    45;
#[doc = "!< 46  1080i   50.00Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_50_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    46;
#[doc = "!< 47  2048i   50.00Hz  (SMPTE372) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048I_50_00_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    47;
#[doc = "!< 48  1080p   30.00Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_30_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    48;
#[doc = "!< 49  2048p   30.00Hz  (SMPTE372) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048P_30_00_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    49;
#[doc = "!< 50  1080p   25.00Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_25_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    50;
#[doc = "!< 51  2048p   25.00Hz  (SMPTE372) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048P_25_00_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    51;
#[doc = "!< 52  1080p   24.00Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_24_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    52;
#[doc = "!< 53  2048p   24.00Hz  (SMPTE372) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048P_24_00_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    53;
#[doc = "!< 54  1080i   48.00Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_48_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    54;
#[doc = "!< 55  2048i   48.00Hz  (SMPTE372) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048I_48_00_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    55;
#[doc = "!< 56  1080p   59.94Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_59_94_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    56;
#[doc = "!< 57  1080i   59.94Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_59_94_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    57;
#[doc = "!< 58  2048i   59.94Hz  (SMPTE372) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048I_59_94_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    58;
#[doc = "!< 59  1080p   29.97Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_29_97_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    59;
#[doc = "!< 60  2048p   29.97Hz  (SMPTE372) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048P_29_97_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    60;
#[doc = "!< 61  1080p   29.98Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_23_98_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    61;
#[doc = "!< 62  2048p   29.98Hz  (SMPTE372) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048P_23_98_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    62;
#[doc = "!< 63  1080i   47.96Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_47_96_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    63;
#[doc = "!< 64  2048i   47.96Hz  (SMPTE372) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048I_47_96_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    64;
#[doc = "!< 65  To indicate end of signal format list"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_END: _NVVIOSIGNALFORMAT = 65;
#[doc = "! Video signal format and resolution"]
pub type _NVVIOSIGNALFORMAT = ::std::os::raw::c_int;
#[doc = "! Video signal format and resolution"]
pub use self::_NVVIOSIGNALFORMAT as NVVIOSIGNALFORMAT;
#[doc = "!< SMPTE259"]
pub const _NVVIOVIDEOSTANDARD_NVVIOVIDEOSTANDARD_SMPTE259: _NVVIOVIDEOSTANDARD = 0;
#[doc = "!< SMPTE260"]
pub const _NVVIOVIDEOSTANDARD_NVVIOVIDEOSTANDARD_SMPTE260: _NVVIOVIDEOSTANDARD = 1;
#[doc = "!< SMPTE274"]
pub const _NVVIOVIDEOSTANDARD_NVVIOVIDEOSTANDARD_SMPTE274: _NVVIOVIDEOSTANDARD = 2;
#[doc = "!< SMPTE295"]
pub const _NVVIOVIDEOSTANDARD_NVVIOVIDEOSTANDARD_SMPTE295: _NVVIOVIDEOSTANDARD = 3;
#[doc = "!< SMPTE296"]
pub const _NVVIOVIDEOSTANDARD_NVVIOVIDEOSTANDARD_SMPTE296: _NVVIOVIDEOSTANDARD = 4;
#[doc = "!< SMPTE372"]
pub const _NVVIOVIDEOSTANDARD_NVVIOVIDEOSTANDARD_SMPTE372: _NVVIOVIDEOSTANDARD = 5;
#[doc = "! SMPTE standards format"]
pub type _NVVIOVIDEOSTANDARD = ::std::os::raw::c_int;
#[doc = "! SMPTE standards format"]
pub use self::_NVVIOVIDEOSTANDARD as NVVIOVIDEOSTANDARD;
#[doc = "!< Standard-definition (SD)"]
pub const _NVVIOVIDEOTYPE_NVVIOVIDEOTYPE_SD: _NVVIOVIDEOTYPE = 0;
#[doc = "!< High-definition     (HD)"]
pub const _NVVIOVIDEOTYPE_NVVIOVIDEOTYPE_HD: _NVVIOVIDEOTYPE = 1;
#[doc = "! HD or SD video type"]
pub type _NVVIOVIDEOTYPE = ::std::os::raw::c_int;
#[doc = "! HD or SD video type"]
pub use self::_NVVIOVIDEOTYPE as NVVIOVIDEOTYPE;
#[doc = "!< Progressive               (p)"]
pub const _NVVIOINTERLACEMODE_NVVIOINTERLACEMODE_PROGRESSIVE: _NVVIOINTERLACEMODE = 0;
#[doc = "!< Interlace                 (i)"]
pub const _NVVIOINTERLACEMODE_NVVIOINTERLACEMODE_INTERLACE: _NVVIOINTERLACEMODE = 1;
#[doc = "!< Progressive Segment Frame (psf)"]
pub const _NVVIOINTERLACEMODE_NVVIOINTERLACEMODE_PSF: _NVVIOINTERLACEMODE = 2;
#[doc = "! Interlace mode"]
pub type _NVVIOINTERLACEMODE = ::std::os::raw::c_int;
#[doc = "! Interlace mode"]
pub use self::_NVVIOINTERLACEMODE as NVVIOINTERLACEMODE;
#[doc = "!< Invalid DataFormat"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_UNKNOWN: _NVVIODATAFORMAT = -1;
#[doc = "!< R8:G8:B8                => YCrCb  (4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R8G8B8_TO_YCRCB444: _NVVIODATAFORMAT = 0;
#[doc = "!< R8:G8:B8:A8             => YCrCbA (4:4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R8G8B8A8_TO_YCRCBA4444: _NVVIODATAFORMAT = 1;
#[doc = "!< R8:G8:B8:Z10            => YCrCbZ (4:4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R8G8B8Z10_TO_YCRCBZ4444: _NVVIODATAFORMAT = 2;
#[doc = "!< R8:G8:B8                => YCrCb  (4:2:2)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R8G8B8_TO_YCRCB422: _NVVIODATAFORMAT = 3;
#[doc = "!< R8:G8:B8:A8             => YCrCbA (4:2:2:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R8G8B8A8_TO_YCRCBA4224: _NVVIODATAFORMAT = 4;
#[doc = "!< R8:G8:B8:Z10            => YCrCbZ (4:2:2:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R8G8B8Z10_TO_YCRCBZ4224: _NVVIODATAFORMAT = 5;
#[doc = "!< R8:G8:B8                => RGB    (4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_X8X8X8_444_PASSTHRU: _NVVIODATAFORMAT = 6;
#[doc = "!< R8:G8:B8:A8             => RGBA   (4:4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_X8X8X8A8_4444_PASSTHRU: _NVVIODATAFORMAT = 7;
#[doc = "!< R8:G8:B8:Z10            => RGBZ   (4:4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_X8X8X8Z10_4444_PASSTHRU: _NVVIODATAFORMAT = 8;
#[doc = "!< Y10:CR10:CB10           => YCrCb  (4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_X10X10X10_444_PASSTHRU: _NVVIODATAFORMAT = 9;
#[doc = "!< Y10:CR8:CB8             => YCrCb  (4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_X10X8X8_444_PASSTHRU: _NVVIODATAFORMAT = 10;
#[doc = "!< Y10:CR8:CB8:A10         => YCrCbA (4:4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_X10X8X8A10_4444_PASSTHRU: _NVVIODATAFORMAT = 11;
#[doc = "!< Y10:CR8:CB8:Z10         => YCrCbZ (4:4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_X10X8X8Z10_4444_PASSTHRU: _NVVIODATAFORMAT = 12;
#[doc = "!< R8:G8:B8 + R8:G8:B8     => YCrCb  (4:2:2 + 4:2:2)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_DUAL_R8G8B8_TO_DUAL_YCRCB422: _NVVIODATAFORMAT = 13;
#[doc = "!< Y8:CR8:CB8 + Y8:CR8:CB8 => YCrCb  (4:2:2 + 4:2:2)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_DUAL_X8X8X8_TO_DUAL_422_PASSTHRU: _NVVIODATAFORMAT = 14;
#[doc = "!< R10:G10:B10             => YCrCb  (4:2:2)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R10G10B10_TO_YCRCB422: _NVVIODATAFORMAT = 15;
#[doc = "!< R10:G10:B10             => YCrCb  (4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R10G10B10_TO_YCRCB444: _NVVIODATAFORMAT = 16;
#[doc = "!< X12:X12:X12             => XXX    (4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_X12X12X12_444_PASSTHRU: _NVVIODATAFORMAT = 17;
#[doc = "!< X12:X12:X12             => XXX    (4:2:2)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_X12X12X12_422_PASSTHRU: _NVVIODATAFORMAT = 18;
#[doc = "!< Y10:CR10:CB10           => YCrCb  (4:2:2)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_Y10CR10CB10_TO_YCRCB422: _NVVIODATAFORMAT = 19;
#[doc = "!< Y8:CR8:CB8              => YCrCb  (4:2:2)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_Y8CR8CB8_TO_YCRCB422: _NVVIODATAFORMAT = 20;
#[doc = "!< Y10:CR8:CB8:A10         => YCrCbA (4:2:2:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_Y10CR8CB8A10_TO_YCRCBA4224: _NVVIODATAFORMAT = 21;
#[doc = "!< R10:G10:B10             => RGB    (4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R10G10B10_TO_RGB444: _NVVIODATAFORMAT = 22;
#[doc = "!< R12:G12:B12             => YCrCb  (4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R12G12B12_TO_YCRCB444: _NVVIODATAFORMAT = 23;
#[doc = "!< R12:G12:B12             => YCrCb  (4:2:2)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R12G12B12_TO_YCRCB422: _NVVIODATAFORMAT = 24;
#[doc = "! Video data format"]
pub type _NVVIODATAFORMAT = ::std::os::raw::c_int;
#[doc = "! Video data format"]
pub use self::_NVVIODATAFORMAT as NVVIODATAFORMAT;
#[doc = "!< Output to entire video resolution (full size)"]
pub const _NVVIOOUTPUTAREA_NVVIOOUTPUTAREA_FULLSIZE: _NVVIOOUTPUTAREA = 0;
#[doc = "!< Output to centered 90% of video resolution (safe action)"]
pub const _NVVIOOUTPUTAREA_NVVIOOUTPUTAREA_SAFEACTION: _NVVIOOUTPUTAREA = 1;
#[doc = "!< Output to centered 80% of video resolution (safe title)"]
pub const _NVVIOOUTPUTAREA_NVVIOOUTPUTAREA_SAFETITLE: _NVVIOOUTPUTAREA = 2;
#[doc = "! Video output area"]
pub type _NVVIOOUTPUTAREA = ::std::os::raw::c_int;
#[doc = "! Video output area"]
pub use self::_NVVIOOUTPUTAREA as NVVIOOUTPUTAREA;
#[doc = "!< SDI Sync  (Digital input)"]
pub const _NVVIOSYNCSOURCE_NVVIOSYNCSOURCE_SDISYNC: _NVVIOSYNCSOURCE = 0;
#[doc = "!< COMP Sync (Composite input)"]
pub const _NVVIOSYNCSOURCE_NVVIOSYNCSOURCE_COMPSYNC: _NVVIOSYNCSOURCE = 1;
#[doc = "! Synchronization source"]
pub type _NVVIOSYNCSOURCE = ::std::os::raw::c_int;
#[doc = "! Synchronization source"]
pub use self::_NVVIOSYNCSOURCE as NVVIOSYNCSOURCE;
#[doc = "!< Auto-detect"]
pub const _NVVIOCOMPSYNCTYPE_NVVIOCOMPSYNCTYPE_AUTO: _NVVIOCOMPSYNCTYPE = 0;
#[doc = "!< Bi-level signal"]
pub const _NVVIOCOMPSYNCTYPE_NVVIOCOMPSYNCTYPE_BILEVEL: _NVVIOCOMPSYNCTYPE = 1;
#[doc = "!< Tri-level signal"]
pub const _NVVIOCOMPSYNCTYPE_NVVIOCOMPSYNCTYPE_TRILEVEL: _NVVIOCOMPSYNCTYPE = 2;
#[doc = "! Composite synchronization type"]
pub type _NVVIOCOMPSYNCTYPE = ::std::os::raw::c_int;
#[doc = "! Composite synchronization type"]
pub use self::_NVVIOCOMPSYNCTYPE as NVVIOCOMPSYNCTYPE;
#[doc = "!< Not in use"]
pub const _NVVIOINPUTOUTPUTSTATUS_NVINPUTOUTPUTSTATUS_OFF: _NVVIOINPUTOUTPUTSTATUS = 0;
#[doc = "!< Error detected"]
pub const _NVVIOINPUTOUTPUTSTATUS_NVINPUTOUTPUTSTATUS_ERROR: _NVVIOINPUTOUTPUTSTATUS = 1;
#[doc = "!< SDI (standard-definition)"]
pub const _NVVIOINPUTOUTPUTSTATUS_NVINPUTOUTPUTSTATUS_SDI_SD: _NVVIOINPUTOUTPUTSTATUS = 2;
#[doc = "!< SDI (high-definition)"]
pub const _NVVIOINPUTOUTPUTSTATUS_NVINPUTOUTPUTSTATUS_SDI_HD: _NVVIOINPUTOUTPUTSTATUS = 3;
#[doc = "! Video input output status"]
pub type _NVVIOINPUTOUTPUTSTATUS = ::std::os::raw::c_int;
#[doc = "! Video input output status"]
pub use self::_NVVIOINPUTOUTPUTSTATUS as NVVIOINPUTOUTPUTSTATUS;
#[doc = "!< Sync not detected"]
pub const _NVVIOSYNCSTATUS_NVVIOSYNCSTATUS_OFF: _NVVIOSYNCSTATUS = 0;
#[doc = "!< Error detected"]
pub const _NVVIOSYNCSTATUS_NVVIOSYNCSTATUS_ERROR: _NVVIOSYNCSTATUS = 1;
#[doc = "!< Genlock in use, format mismatch with output"]
pub const _NVVIOSYNCSTATUS_NVVIOSYNCSTATUS_SYNCLOSS: _NVVIOSYNCSTATUS = 2;
#[doc = "!< Composite sync"]
pub const _NVVIOSYNCSTATUS_NVVIOSYNCSTATUS_COMPOSITE: _NVVIOSYNCSTATUS = 3;
#[doc = "!< SDI sync (standard-definition)"]
pub const _NVVIOSYNCSTATUS_NVVIOSYNCSTATUS_SDI_SD: _NVVIOSYNCSTATUS = 4;
#[doc = "!< SDI sync (high-definition)"]
pub const _NVVIOSYNCSTATUS_NVVIOSYNCSTATUS_SDI_HD: _NVVIOSYNCSTATUS = 5;
#[doc = "! Synchronization input status"]
pub type _NVVIOSYNCSTATUS = ::std::os::raw::c_int;
#[doc = "! Synchronization input status"]
pub use self::_NVVIOSYNCSTATUS as NVVIOSYNCSTATUS;
#[doc = "!< Sync not detected"]
pub const _NVVIOCAPTURESTATUS_NVVIOSTATUS_STOPPED: _NVVIOCAPTURESTATUS = 0;
#[doc = "!< Error detected"]
pub const _NVVIOCAPTURESTATUS_NVVIOSTATUS_RUNNING: _NVVIOCAPTURESTATUS = 1;
#[doc = "!< Genlock in use, format mismatch with output"]
pub const _NVVIOCAPTURESTATUS_NVVIOSTATUS_ERROR: _NVVIOCAPTURESTATUS = 2;
#[doc = "! Video Capture Status"]
pub type _NVVIOCAPTURESTATUS = ::std::os::raw::c_int;
#[doc = "! Video Capture Status"]
pub use self::_NVVIOCAPTURESTATUS as NVVIOCAPTURESTATUS;
#[doc = "!< Input Status"]
pub const _NVVIOSTATUSTYPE_NVVIOSTATUSTYPE_IN: _NVVIOSTATUSTYPE = 0;
#[doc = "!< Output Status"]
pub const _NVVIOSTATUSTYPE_NVVIOSTATUSTYPE_OUT: _NVVIOSTATUSTYPE = 1;
#[doc = "! Video Capture Status"]
pub type _NVVIOSTATUSTYPE = ::std::os::raw::c_int;
#[doc = "! Video Capture Status"]
pub use self::_NVVIOSTATUSTYPE as NVVIOSTATUSTYPE;
#[doc = "!< Input Status"]
pub const _NVVIOCONFIGTYPE_NVVIOCONFIGTYPE_IN: _NVVIOCONFIGTYPE = 0;
#[doc = "!< Output Status"]
pub const _NVVIOCONFIGTYPE_NVVIOCONFIGTYPE_OUT: _NVVIOCONFIGTYPE = 1;
#[doc = "! Device configuration"]
pub type _NVVIOCONFIGTYPE = ::std::os::raw::c_int;
#[doc = "! Device configuration"]
pub use self::_NVVIOCONFIGTYPE as NVVIOCONFIGTYPE;
pub const _NVVIOCOLORSPACE_NVVIOCOLORSPACE_UNKNOWN: _NVVIOCOLORSPACE = 0;
pub const _NVVIOCOLORSPACE_NVVIOCOLORSPACE_YCBCR: _NVVIOCOLORSPACE = 1;
pub const _NVVIOCOLORSPACE_NVVIOCOLORSPACE_YCBCRA: _NVVIOCOLORSPACE = 2;
pub const _NVVIOCOLORSPACE_NVVIOCOLORSPACE_YCBCRD: _NVVIOCOLORSPACE = 3;
pub const _NVVIOCOLORSPACE_NVVIOCOLORSPACE_GBR: _NVVIOCOLORSPACE = 4;
pub const _NVVIOCOLORSPACE_NVVIOCOLORSPACE_GBRA: _NVVIOCOLORSPACE = 5;
pub const _NVVIOCOLORSPACE_NVVIOCOLORSPACE_GBRD: _NVVIOCOLORSPACE = 6;
pub type _NVVIOCOLORSPACE = ::std::os::raw::c_int;
pub use self::_NVVIOCOLORSPACE as NVVIOCOLORSPACE;
pub const _NVVIOCOMPONENTSAMPLING_NVVIOCOMPONENTSAMPLING_UNKNOWN: _NVVIOCOMPONENTSAMPLING = 0;
pub const _NVVIOCOMPONENTSAMPLING_NVVIOCOMPONENTSAMPLING_4444: _NVVIOCOMPONENTSAMPLING = 1;
pub const _NVVIOCOMPONENTSAMPLING_NVVIOCOMPONENTSAMPLING_4224: _NVVIOCOMPONENTSAMPLING = 2;
pub const _NVVIOCOMPONENTSAMPLING_NVVIOCOMPONENTSAMPLING_444: _NVVIOCOMPONENTSAMPLING = 3;
pub const _NVVIOCOMPONENTSAMPLING_NVVIOCOMPONENTSAMPLING_422: _NVVIOCOMPONENTSAMPLING = 4;
#[doc = "! Component sampling"]
pub type _NVVIOCOMPONENTSAMPLING = ::std::os::raw::c_int;
#[doc = "! Component sampling"]
pub use self::_NVVIOCOMPONENTSAMPLING as NVVIOCOMPONENTSAMPLING;
pub const _NVVIOBITSPERCOMPONENT_NVVIOBITSPERCOMPONENT_UNKNOWN: _NVVIOBITSPERCOMPONENT = 0;
pub const _NVVIOBITSPERCOMPONENT_NVVIOBITSPERCOMPONENT_8: _NVVIOBITSPERCOMPONENT = 1;
pub const _NVVIOBITSPERCOMPONENT_NVVIOBITSPERCOMPONENT_10: _NVVIOBITSPERCOMPONENT = 2;
pub const _NVVIOBITSPERCOMPONENT_NVVIOBITSPERCOMPONENT_12: _NVVIOBITSPERCOMPONENT = 3;
pub type _NVVIOBITSPERCOMPONENT = ::std::os::raw::c_int;
pub use self::_NVVIOBITSPERCOMPONENT as NVVIOBITSPERCOMPONENT;
pub const _NVVIOLINKID_NVVIOLINKID_UNKNOWN: _NVVIOLINKID = 0;
pub const _NVVIOLINKID_NVVIOLINKID_A: _NVVIOLINKID = 1;
pub const _NVVIOLINKID_NVVIOLINKID_B: _NVVIOLINKID = 2;
pub const _NVVIOLINKID_NVVIOLINKID_C: _NVVIOLINKID = 3;
pub const _NVVIOLINKID_NVVIOLINKID_D: _NVVIOLINKID = 4;
pub type _NVVIOLINKID = ::std::os::raw::c_int;
pub use self::_NVVIOLINKID as NVVIOLINKID;
pub const _NVVIOANCPARITYCOMPUTATION_NVVIOANCPARITYCOMPUTATION_AUTO: _NVVIOANCPARITYCOMPUTATION = 0;
pub const _NVVIOANCPARITYCOMPUTATION_NVVIOANCPARITYCOMPUTATION_ON: _NVVIOANCPARITYCOMPUTATION = 1;
pub const _NVVIOANCPARITYCOMPUTATION_NVVIOANCPARITYCOMPUTATION_OFF: _NVVIOANCPARITYCOMPUTATION = 2;
pub type _NVVIOANCPARITYCOMPUTATION = ::std::os::raw::c_int;
pub use self::_NVVIOANCPARITYCOMPUTATION as NVVIOANCPARITYCOMPUTATION;
#[doc = "! Device capabilities"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOCAPS {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< Graphics adapter name"]
    pub adapterName: NvAPI_String,
    #[doc = "!< Graphics adapter classes (NVVIOCLASS_SDI mask)"]
    pub adapterClass: NvU32,
    #[doc = "!< Graphics adapter capabilities (NVVIOCAPS_* mask)"]
    pub adapterCaps: NvU32,
    #[doc = "!< On-board DIP switch settings bits"]
    pub dipSwitch: NvU32,
    #[doc = "!< On-board DIP switch settings reserved bits"]
    pub dipSwitchReserved: NvU32,
    #[doc = "!< Board ID"]
    pub boardID: NvU32,
    pub driver: _NVVIOCAPS__bindgen_ty_1,
    pub firmWare: _NVVIOCAPS__bindgen_ty_2,
    #[doc = "!< Unique identifier for owner of video output (NVVIOOWNERID_INVALID if free running)"]
    pub ownerId: NVVIOOWNERID,
    #[doc = "!< Owner type (OpenGL application or Desktop mode)"]
    pub ownerType: NVVIOOWNERTYPE,
}
#[doc = "! Driver version"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NVVIOCAPS__bindgen_ty_1 {
    #[doc = "!< Major version. For GVI, majorVersion contains MajorVersion(HIWORD) And MinorVersion(LOWORD)"]
    pub majorVersion: NvU32,
    #[doc = "!< Minor version. For GVI, minorVersion contains Revison(HIWORD) And Build(LOWORD)"]
    pub minorVersion: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOCAPS__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCAPS__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_NVVIOCAPS__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCAPS__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCAPS__bindgen_ty_1))
    );
    fn test_field_majorVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCAPS__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).majorVersion) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCAPS__bindgen_ty_1),
                "::",
                stringify!(majorVersion)
            )
        );
    }
    test_field_majorVersion();
    fn test_field_minorVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCAPS__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minorVersion) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCAPS__bindgen_ty_1),
                "::",
                stringify!(minorVersion)
            )
        );
    }
    test_field_minorVersion();
}
#[doc = "! Firmware version"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NVVIOCAPS__bindgen_ty_2 {
    #[doc = "!< Major version. In version 2, for both GVI and GVO, majorVersion contains MajorVersion(HIWORD) And MinorVersion(LOWORD)"]
    pub majorVersion: NvU32,
    #[doc = "!< Minor version. In version 2, for both GVI and GVO, minorVersion contains Revison(HIWORD) And Build(LOWORD)"]
    pub minorVersion: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOCAPS__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCAPS__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_NVVIOCAPS__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCAPS__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCAPS__bindgen_ty_2))
    );
    fn test_field_majorVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCAPS__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).majorVersion) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCAPS__bindgen_ty_2),
                "::",
                stringify!(majorVersion)
            )
        );
    }
    test_field_majorVersion();
    fn test_field_minorVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCAPS__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minorVersion) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCAPS__bindgen_ty_2),
                "::",
                stringify!(minorVersion)
            )
        );
    }
    test_field_minorVersion();
}
#[test]
fn bindgen_test_layout__NVVIOCAPS() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCAPS>(),
        4144usize,
        concat!("Size of: ", stringify!(_NVVIOCAPS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCAPS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCAPS))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCAPS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCAPS),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_adapterName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCAPS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).adapterName) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCAPS),
                "::",
                stringify!(adapterName)
            )
        );
    }
    test_field_adapterName();
    fn test_field_adapterClass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCAPS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).adapterClass) as usize - ptr as usize
            },
            4100usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCAPS),
                "::",
                stringify!(adapterClass)
            )
        );
    }
    test_field_adapterClass();
    fn test_field_adapterCaps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCAPS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).adapterCaps) as usize - ptr as usize
            },
            4104usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCAPS),
                "::",
                stringify!(adapterCaps)
            )
        );
    }
    test_field_adapterCaps();
    fn test_field_dipSwitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCAPS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dipSwitch) as usize - ptr as usize
            },
            4108usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCAPS),
                "::",
                stringify!(dipSwitch)
            )
        );
    }
    test_field_dipSwitch();
    fn test_field_dipSwitchReserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCAPS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dipSwitchReserved) as usize - ptr as usize
            },
            4112usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCAPS),
                "::",
                stringify!(dipSwitchReserved)
            )
        );
    }
    test_field_dipSwitchReserved();
    fn test_field_boardID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCAPS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).boardID) as usize - ptr as usize
            },
            4116usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCAPS),
                "::",
                stringify!(boardID)
            )
        );
    }
    test_field_boardID();
    fn test_field_driver() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCAPS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).driver) as usize - ptr as usize
            },
            4120usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCAPS),
                "::",
                stringify!(driver)
            )
        );
    }
    test_field_driver();
    fn test_field_firmWare() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCAPS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).firmWare) as usize - ptr as usize
            },
            4128usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCAPS),
                "::",
                stringify!(firmWare)
            )
        );
    }
    test_field_firmWare();
    fn test_field_ownerId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCAPS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ownerId) as usize - ptr as usize
            },
            4136usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCAPS),
                "::",
                stringify!(ownerId)
            )
        );
    }
    test_field_ownerId();
    fn test_field_ownerType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCAPS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ownerType) as usize - ptr as usize
            },
            4140usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCAPS),
                "::",
                stringify!(ownerType)
            )
        );
    }
    test_field_ownerType();
}
impl Default for _NVVIOCAPS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Device capabilities"]
pub type NVVIOCAPS = _NVVIOCAPS;
#[doc = "! Input channel status"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOCHANNELSTATUS {
    #[doc = "!< 4-byte SMPTE 352 video payload identifier"]
    pub smpte352: NvU32,
    #[doc = "!< Signal format"]
    pub signalFormat: NVVIOSIGNALFORMAT,
    #[doc = "!< Bits per component"]
    pub bitsPerComponent: NVVIOBITSPERCOMPONENT,
    #[doc = "!< Sampling format"]
    pub samplingFormat: NVVIOCOMPONENTSAMPLING,
    #[doc = "!< Color space"]
    pub colorSpace: NVVIOCOLORSPACE,
    #[doc = "!< Link ID"]
    pub linkID: NVVIOLINKID,
}
#[test]
fn bindgen_test_layout__NVVIOCHANNELSTATUS() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCHANNELSTATUS>(),
        24usize,
        concat!("Size of: ", stringify!(_NVVIOCHANNELSTATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCHANNELSTATUS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCHANNELSTATUS))
    );
    fn test_field_smpte352() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCHANNELSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).smpte352) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCHANNELSTATUS),
                "::",
                stringify!(smpte352)
            )
        );
    }
    test_field_smpte352();
    fn test_field_signalFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCHANNELSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signalFormat) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCHANNELSTATUS),
                "::",
                stringify!(signalFormat)
            )
        );
    }
    test_field_signalFormat();
    fn test_field_bitsPerComponent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCHANNELSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bitsPerComponent) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCHANNELSTATUS),
                "::",
                stringify!(bitsPerComponent)
            )
        );
    }
    test_field_bitsPerComponent();
    fn test_field_samplingFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCHANNELSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).samplingFormat) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCHANNELSTATUS),
                "::",
                stringify!(samplingFormat)
            )
        );
    }
    test_field_samplingFormat();
    fn test_field_colorSpace() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCHANNELSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorSpace) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCHANNELSTATUS),
                "::",
                stringify!(colorSpace)
            )
        );
    }
    test_field_colorSpace();
    fn test_field_linkID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCHANNELSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).linkID) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCHANNELSTATUS),
                "::",
                stringify!(linkID)
            )
        );
    }
    test_field_linkID();
}
impl Default for _NVVIOCHANNELSTATUS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Input channel status"]
pub type NVVIOCHANNELSTATUS = _NVVIOCHANNELSTATUS;
#[doc = "! Input device status"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOINPUTSTATUS {
    #[doc = "!< Video input status per channel within a jack"]
    pub vidIn: [[NVVIOCHANNELSTATUS; 2usize]; 4usize],
    #[doc = "!< status of video capture"]
    pub captureStatus: NVVIOCAPTURESTATUS,
}
#[test]
fn bindgen_test_layout__NVVIOINPUTSTATUS() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOINPUTSTATUS>(),
        196usize,
        concat!("Size of: ", stringify!(_NVVIOINPUTSTATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOINPUTSTATUS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOINPUTSTATUS))
    );
    fn test_field_vidIn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOINPUTSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vidIn) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOINPUTSTATUS),
                "::",
                stringify!(vidIn)
            )
        );
    }
    test_field_vidIn();
    fn test_field_captureStatus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOINPUTSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).captureStatus) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOINPUTSTATUS),
                "::",
                stringify!(captureStatus)
            )
        );
    }
    test_field_captureStatus();
}
impl Default for _NVVIOINPUTSTATUS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Input device status"]
pub type NVVIOINPUTSTATUS = _NVVIOINPUTSTATUS;
#[doc = "! Output device status"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOOUTPUTSTATUS {
    #[doc = "!< Video 1 output status"]
    pub vid1Out: NVVIOINPUTOUTPUTSTATUS,
    #[doc = "!< Video 2 output status"]
    pub vid2Out: NVVIOINPUTOUTPUTSTATUS,
    #[doc = "!< SDI sync input status"]
    pub sdiSyncIn: NVVIOSYNCSTATUS,
    #[doc = "!< Composite sync input status"]
    pub compSyncIn: NVVIOSYNCSTATUS,
    #[doc = "!< Sync enable (TRUE if using syncSource)"]
    pub syncEnable: NvU32,
    #[doc = "!< Sync source"]
    pub syncSource: NVVIOSYNCSOURCE,
    #[doc = "!< Sync format"]
    pub syncFormat: NVVIOSIGNALFORMAT,
    #[doc = "!< Framelock enable flag"]
    pub frameLockEnable: NvU32,
    #[doc = "!< Output locked status"]
    pub outputVideoLocked: NvU32,
    #[doc = "!< Data integrity check error count"]
    pub dataIntegrityCheckErrorCount: NvU32,
    #[doc = "!< Data integrity check status enabled"]
    pub dataIntegrityCheckEnabled: NvU32,
    #[doc = "!< Data integrity check status failed"]
    pub dataIntegrityCheckFailed: NvU32,
    #[doc = "!< genlocked to framelocked to ref signal"]
    pub uSyncSourceLocked: NvU32,
    #[doc = "!< TRUE: indicates there is sufficient power"]
    pub uPowerOn: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOOUTPUTSTATUS() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOOUTPUTSTATUS>(),
        56usize,
        concat!("Size of: ", stringify!(_NVVIOOUTPUTSTATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOOUTPUTSTATUS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOOUTPUTSTATUS))
    );
    fn test_field_vid1Out() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vid1Out) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTSTATUS),
                "::",
                stringify!(vid1Out)
            )
        );
    }
    test_field_vid1Out();
    fn test_field_vid2Out() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vid2Out) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTSTATUS),
                "::",
                stringify!(vid2Out)
            )
        );
    }
    test_field_vid2Out();
    fn test_field_sdiSyncIn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sdiSyncIn) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTSTATUS),
                "::",
                stringify!(sdiSyncIn)
            )
        );
    }
    test_field_sdiSyncIn();
    fn test_field_compSyncIn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compSyncIn) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTSTATUS),
                "::",
                stringify!(compSyncIn)
            )
        );
    }
    test_field_compSyncIn();
    fn test_field_syncEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).syncEnable) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTSTATUS),
                "::",
                stringify!(syncEnable)
            )
        );
    }
    test_field_syncEnable();
    fn test_field_syncSource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).syncSource) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTSTATUS),
                "::",
                stringify!(syncSource)
            )
        );
    }
    test_field_syncSource();
    fn test_field_syncFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).syncFormat) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTSTATUS),
                "::",
                stringify!(syncFormat)
            )
        );
    }
    test_field_syncFormat();
    fn test_field_frameLockEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frameLockEnable) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTSTATUS),
                "::",
                stringify!(frameLockEnable)
            )
        );
    }
    test_field_frameLockEnable();
    fn test_field_outputVideoLocked() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).outputVideoLocked) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTSTATUS),
                "::",
                stringify!(outputVideoLocked)
            )
        );
    }
    test_field_outputVideoLocked();
    fn test_field_dataIntegrityCheckErrorCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dataIntegrityCheckErrorCount) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTSTATUS),
                "::",
                stringify!(dataIntegrityCheckErrorCount)
            )
        );
    }
    test_field_dataIntegrityCheckErrorCount();
    fn test_field_dataIntegrityCheckEnabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dataIntegrityCheckEnabled) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTSTATUS),
                "::",
                stringify!(dataIntegrityCheckEnabled)
            )
        );
    }
    test_field_dataIntegrityCheckEnabled();
    fn test_field_dataIntegrityCheckFailed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dataIntegrityCheckFailed) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTSTATUS),
                "::",
                stringify!(dataIntegrityCheckFailed)
            )
        );
    }
    test_field_dataIntegrityCheckFailed();
    fn test_field_uSyncSourceLocked() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uSyncSourceLocked) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTSTATUS),
                "::",
                stringify!(uSyncSourceLocked)
            )
        );
    }
    test_field_uSyncSourceLocked();
    fn test_field_uPowerOn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uPowerOn) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTSTATUS),
                "::",
                stringify!(uPowerOn)
            )
        );
    }
    test_field_uPowerOn();
}
impl Default for _NVVIOOUTPUTSTATUS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Output device status"]
pub type NVVIOOUTPUTSTATUS = _NVVIOOUTPUTSTATUS;
#[doc = "! Video device status."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOSTATUS {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< Input or Output status"]
    pub nvvioStatusType: NVVIOSTATUSTYPE,
    pub vioStatus: _NVVIOSTATUS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVVIOSTATUS__bindgen_ty_1 {
    #[doc = "!<  Input device status"]
    pub inStatus: NVVIOINPUTSTATUS,
    #[doc = "!<  Output device status"]
    pub outStatus: NVVIOOUTPUTSTATUS,
}
#[test]
fn bindgen_test_layout__NVVIOSTATUS__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOSTATUS__bindgen_ty_1>(),
        196usize,
        concat!("Size of: ", stringify!(_NVVIOSTATUS__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOSTATUS__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOSTATUS__bindgen_ty_1))
    );
    fn test_field_inStatus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOSTATUS__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inStatus) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOSTATUS__bindgen_ty_1),
                "::",
                stringify!(inStatus)
            )
        );
    }
    test_field_inStatus();
    fn test_field_outStatus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOSTATUS__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).outStatus) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOSTATUS__bindgen_ty_1),
                "::",
                stringify!(outStatus)
            )
        );
    }
    test_field_outStatus();
}
impl Default for _NVVIOSTATUS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__NVVIOSTATUS() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOSTATUS>(),
        204usize,
        concat!("Size of: ", stringify!(_NVVIOSTATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOSTATUS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOSTATUS))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOSTATUS),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_nvvioStatusType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvvioStatusType) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOSTATUS),
                "::",
                stringify!(nvvioStatusType)
            )
        );
    }
    test_field_nvvioStatusType();
    fn test_field_vioStatus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOSTATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vioStatus) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOSTATUS),
                "::",
                stringify!(vioStatus)
            )
        );
    }
    test_field_vioStatus();
}
impl Default for _NVVIOSTATUS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Video device status."]
pub type NVVIOSTATUS = _NVVIOSTATUS;
#[doc = "! Output region"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NVVIOOUTPUTREGION {
    #[doc = "!< Horizontal origin in pixels"]
    pub x: NvU32,
    #[doc = "!< Vertical origin in pixels"]
    pub y: NvU32,
    #[doc = "!< Width of region in pixels"]
    pub width: NvU32,
    #[doc = "!< Height of region in pixels"]
    pub height: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOOUTPUTREGION() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOOUTPUTREGION>(),
        16usize,
        concat!("Size of: ", stringify!(_NVVIOOUTPUTREGION))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOOUTPUTREGION>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOOUTPUTREGION))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTREGION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTREGION),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTREGION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTREGION),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTREGION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTREGION),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTREGION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTREGION),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
}
#[doc = "! Output region"]
pub type NVVIOOUTPUTREGION = _NVVIOOUTPUTREGION;
#[doc = "! Gamma ramp (8-bit index)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOGAMMARAMP8 {
    #[doc = "!< Red channel gamma ramp (8-bit index, 16-bit values)"]
    pub uRed: [NvU16; 256usize],
    #[doc = "!< Green channel gamma ramp (8-bit index, 16-bit values)"]
    pub uGreen: [NvU16; 256usize],
    #[doc = "!< Blue channel gamma ramp (8-bit index, 16-bit values)"]
    pub uBlue: [NvU16; 256usize],
}
#[test]
fn bindgen_test_layout__NVVIOGAMMARAMP8() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOGAMMARAMP8>(),
        1536usize,
        concat!("Size of: ", stringify!(_NVVIOGAMMARAMP8))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOGAMMARAMP8>(),
        2usize,
        concat!("Alignment of ", stringify!(_NVVIOGAMMARAMP8))
    );
    fn test_field_uRed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOGAMMARAMP8>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uRed) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOGAMMARAMP8),
                "::",
                stringify!(uRed)
            )
        );
    }
    test_field_uRed();
    fn test_field_uGreen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOGAMMARAMP8>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uGreen) as usize - ptr as usize
            },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOGAMMARAMP8),
                "::",
                stringify!(uGreen)
            )
        );
    }
    test_field_uGreen();
    fn test_field_uBlue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOGAMMARAMP8>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uBlue) as usize - ptr as usize
            },
            1024usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOGAMMARAMP8),
                "::",
                stringify!(uBlue)
            )
        );
    }
    test_field_uBlue();
}
impl Default for _NVVIOGAMMARAMP8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Gamma ramp (8-bit index)"]
pub type NVVIOGAMMARAMP8 = _NVVIOGAMMARAMP8;
#[doc = "! Gamma ramp (10-bit index)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOGAMMARAMP10 {
    #[doc = "!< Red channel gamma ramp (10-bit index, 16-bit values)"]
    pub uRed: [NvU16; 1024usize],
    #[doc = "!< Green channel gamma ramp (10-bit index, 16-bit values)"]
    pub uGreen: [NvU16; 1024usize],
    #[doc = "!< Blue channel gamma ramp (10-bit index, 16-bit values)"]
    pub uBlue: [NvU16; 1024usize],
}
#[test]
fn bindgen_test_layout__NVVIOGAMMARAMP10() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOGAMMARAMP10>(),
        6144usize,
        concat!("Size of: ", stringify!(_NVVIOGAMMARAMP10))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOGAMMARAMP10>(),
        2usize,
        concat!("Alignment of ", stringify!(_NVVIOGAMMARAMP10))
    );
    fn test_field_uRed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOGAMMARAMP10>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uRed) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOGAMMARAMP10),
                "::",
                stringify!(uRed)
            )
        );
    }
    test_field_uRed();
    fn test_field_uGreen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOGAMMARAMP10>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uGreen) as usize - ptr as usize
            },
            2048usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOGAMMARAMP10),
                "::",
                stringify!(uGreen)
            )
        );
    }
    test_field_uGreen();
    fn test_field_uBlue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOGAMMARAMP10>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uBlue) as usize - ptr as usize
            },
            4096usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOGAMMARAMP10),
                "::",
                stringify!(uBlue)
            )
        );
    }
    test_field_uBlue();
}
impl Default for _NVVIOGAMMARAMP10 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Gamma ramp (10-bit index)"]
pub type NVVIOGAMMARAMP10 = _NVVIOGAMMARAMP10;
#[doc = "! Sync delay"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NVVIOSYNCDELAY {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< Horizontal delay in pixels"]
    pub horizontalDelay: NvU32,
    #[doc = "!< Vertical delay in lines"]
    pub verticalDelay: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOSYNCDELAY() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOSYNCDELAY>(),
        12usize,
        concat!("Size of: ", stringify!(_NVVIOSYNCDELAY))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOSYNCDELAY>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOSYNCDELAY))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOSYNCDELAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOSYNCDELAY),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_horizontalDelay() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOSYNCDELAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).horizontalDelay) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOSYNCDELAY),
                "::",
                stringify!(horizontalDelay)
            )
        );
    }
    test_field_horizontalDelay();
    fn test_field_verticalDelay() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOSYNCDELAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).verticalDelay) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOSYNCDELAY),
                "::",
                stringify!(verticalDelay)
            )
        );
    }
    test_field_verticalDelay();
}
#[doc = "! Sync delay"]
pub type NVVIOSYNCDELAY = _NVVIOSYNCDELAY;
#[doc = "! Video mode information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOVIDEOMODE {
    #[doc = "!< Horizontal resolution (in pixels)"]
    pub horizontalPixels: NvU32,
    #[doc = "!< Vertical resolution for frame (in lines)"]
    pub verticalLines: NvU32,
    #[doc = "!< Frame rate"]
    pub fFrameRate: f32,
    #[doc = "!< Interlace mode"]
    pub interlaceMode: NVVIOINTERLACEMODE,
    #[doc = "!< SMPTE standards format"]
    pub videoStandard: NVVIOVIDEOSTANDARD,
    #[doc = "!< HD or SD signal classification"]
    pub videoType: NVVIOVIDEOTYPE,
}
#[test]
fn bindgen_test_layout__NVVIOVIDEOMODE() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOVIDEOMODE>(),
        24usize,
        concat!("Size of: ", stringify!(_NVVIOVIDEOMODE))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOVIDEOMODE>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOVIDEOMODE))
    );
    fn test_field_horizontalPixels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOVIDEOMODE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).horizontalPixels) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOVIDEOMODE),
                "::",
                stringify!(horizontalPixels)
            )
        );
    }
    test_field_horizontalPixels();
    fn test_field_verticalLines() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOVIDEOMODE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).verticalLines) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOVIDEOMODE),
                "::",
                stringify!(verticalLines)
            )
        );
    }
    test_field_verticalLines();
    fn test_field_fFrameRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOVIDEOMODE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fFrameRate) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOVIDEOMODE),
                "::",
                stringify!(fFrameRate)
            )
        );
    }
    test_field_fFrameRate();
    fn test_field_interlaceMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOVIDEOMODE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).interlaceMode) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOVIDEOMODE),
                "::",
                stringify!(interlaceMode)
            )
        );
    }
    test_field_interlaceMode();
    fn test_field_videoStandard() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOVIDEOMODE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).videoStandard) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOVIDEOMODE),
                "::",
                stringify!(videoStandard)
            )
        );
    }
    test_field_videoStandard();
    fn test_field_videoType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOVIDEOMODE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).videoType) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOVIDEOMODE),
                "::",
                stringify!(videoType)
            )
        );
    }
    test_field_videoType();
}
impl Default for _NVVIOVIDEOMODE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Video mode information"]
pub type NVVIOVIDEOMODE = _NVVIOVIDEOMODE;
#[doc = "! Signal format details"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOSIGNALFORMATDETAIL {
    #[doc = "!< Signal format enumerated value"]
    pub signalFormat: NVVIOSIGNALFORMAT,
    #[doc = "!< Video mode for signal format"]
    pub videoMode: NVVIOVIDEOMODE,
}
#[test]
fn bindgen_test_layout__NVVIOSIGNALFORMATDETAIL() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOSIGNALFORMATDETAIL>(),
        28usize,
        concat!("Size of: ", stringify!(_NVVIOSIGNALFORMATDETAIL))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOSIGNALFORMATDETAIL>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOSIGNALFORMATDETAIL))
    );
    fn test_field_signalFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOSIGNALFORMATDETAIL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signalFormat) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOSIGNALFORMATDETAIL),
                "::",
                stringify!(signalFormat)
            )
        );
    }
    test_field_signalFormat();
    fn test_field_videoMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOSIGNALFORMATDETAIL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).videoMode) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOSIGNALFORMATDETAIL),
                "::",
                stringify!(videoMode)
            )
        );
    }
    test_field_videoMode();
}
impl Default for _NVVIOSIGNALFORMATDETAIL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Signal format details"]
pub type NVVIOSIGNALFORMATDETAIL = _NVVIOSIGNALFORMATDETAIL;
#[doc = "! Data format details"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIODATAFORMATDETAIL {
    #[doc = "!< Data format enumerated value"]
    pub dataFormat: NVVIODATAFORMAT,
    #[doc = "!< Data format capabilities (NVVIOCAPS_* mask)"]
    pub vioCaps: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIODATAFORMATDETAIL() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIODATAFORMATDETAIL>(),
        8usize,
        concat!("Size of: ", stringify!(_NVVIODATAFORMATDETAIL))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIODATAFORMATDETAIL>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIODATAFORMATDETAIL))
    );
    fn test_field_dataFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIODATAFORMATDETAIL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dataFormat) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIODATAFORMATDETAIL),
                "::",
                stringify!(dataFormat)
            )
        );
    }
    test_field_dataFormat();
    fn test_field_vioCaps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIODATAFORMATDETAIL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vioCaps) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIODATAFORMATDETAIL),
                "::",
                stringify!(vioCaps)
            )
        );
    }
    test_field_vioCaps();
}
impl Default for _NVVIODATAFORMATDETAIL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Data format details"]
pub type NVVIODATAFORMATDETAIL = _NVVIODATAFORMATDETAIL;
#[doc = "! Colorspace conversion"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NVVIOCOLORCONVERSION {
    #[doc = "!<  Structure version"]
    pub version: NvU32,
    #[doc = "!<  Output[n] ="]
    pub colorMatrix: [[f32; 3usize]; 3usize],
    #[doc = "!<  Input[0] * colorMatrix[n][0] +"]
    pub colorOffset: [f32; 3usize],
    #[doc = "!<  Input[1] * colorMatrix[n][1] +"]
    #[doc = "!<  Input[2] * colorMatrix[n][2] +"]
    #[doc = "!<  OutputRange * colorOffset[n]"]
    #[doc = "!<  where OutputRange is the standard magnitude of"]
    #[doc = "!<  Output[n][n] and colorMatrix and colorOffset"]
    #[doc = "!<  values are within the range -1.0 to +1.0"]
    pub colorScale: [f32; 3usize],
    #[doc = "!<  compositeSafe constrains luminance range when using composite output"]
    pub compositeSafe: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOCOLORCONVERSION() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCOLORCONVERSION>(),
        68usize,
        concat!("Size of: ", stringify!(_NVVIOCOLORCONVERSION))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCOLORCONVERSION>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCOLORCONVERSION))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCOLORCONVERSION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCOLORCONVERSION),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_colorMatrix() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCOLORCONVERSION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorMatrix) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCOLORCONVERSION),
                "::",
                stringify!(colorMatrix)
            )
        );
    }
    test_field_colorMatrix();
    fn test_field_colorOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCOLORCONVERSION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorOffset) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCOLORCONVERSION),
                "::",
                stringify!(colorOffset)
            )
        );
    }
    test_field_colorOffset();
    fn test_field_colorScale() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCOLORCONVERSION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorScale) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCOLORCONVERSION),
                "::",
                stringify!(colorScale)
            )
        );
    }
    test_field_colorScale();
    fn test_field_compositeSafe() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCOLORCONVERSION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compositeSafe) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCOLORCONVERSION),
                "::",
                stringify!(compositeSafe)
            )
        );
    }
    test_field_compositeSafe();
}
#[doc = "! Colorspace conversion"]
pub type NVVIOCOLORCONVERSION = _NVVIOCOLORCONVERSION;
#[doc = "! Gamma correction"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOGAMMACORRECTION {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< Gamma correction type (8-bit or 10-bit)"]
    pub vioGammaCorrectionType: NvU32,
    pub gammaRamp: _NVVIOGAMMACORRECTION__bindgen_ty_1,
    #[doc = "!< Red Gamma value within gamma ranges. 0.5 - 6.0"]
    pub fGammaValueR: f32,
    #[doc = "!< Green Gamma value within gamma ranges. 0.5 - 6.0"]
    pub fGammaValueG: f32,
    #[doc = "!< Blue Gamma value within gamma ranges. 0.5 - 6.0"]
    pub fGammaValueB: f32,
}
#[doc = "! Gamma correction:"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVVIOGAMMACORRECTION__bindgen_ty_1 {
    #[doc = "!< Gamma ramp (8-bit index, 16-bit values)"]
    pub gammaRamp8: NVVIOGAMMARAMP8,
    #[doc = "!< Gamma ramp (10-bit index, 16-bit values)"]
    pub gammaRamp10: NVVIOGAMMARAMP10,
}
#[test]
fn bindgen_test_layout__NVVIOGAMMACORRECTION__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOGAMMACORRECTION__bindgen_ty_1>(),
        6144usize,
        concat!("Size of: ", stringify!(_NVVIOGAMMACORRECTION__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOGAMMACORRECTION__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_NVVIOGAMMACORRECTION__bindgen_ty_1)
        )
    );
    fn test_field_gammaRamp8() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NVVIOGAMMACORRECTION__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gammaRamp8) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOGAMMACORRECTION__bindgen_ty_1),
                "::",
                stringify!(gammaRamp8)
            )
        );
    }
    test_field_gammaRamp8();
    fn test_field_gammaRamp10() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NVVIOGAMMACORRECTION__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gammaRamp10) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOGAMMACORRECTION__bindgen_ty_1),
                "::",
                stringify!(gammaRamp10)
            )
        );
    }
    test_field_gammaRamp10();
}
impl Default for _NVVIOGAMMACORRECTION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__NVVIOGAMMACORRECTION() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOGAMMACORRECTION>(),
        6164usize,
        concat!("Size of: ", stringify!(_NVVIOGAMMACORRECTION))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOGAMMACORRECTION>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOGAMMACORRECTION))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOGAMMACORRECTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOGAMMACORRECTION),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_vioGammaCorrectionType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOGAMMACORRECTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vioGammaCorrectionType) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOGAMMACORRECTION),
                "::",
                stringify!(vioGammaCorrectionType)
            )
        );
    }
    test_field_vioGammaCorrectionType();
    fn test_field_gammaRamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOGAMMACORRECTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gammaRamp) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOGAMMACORRECTION),
                "::",
                stringify!(gammaRamp)
            )
        );
    }
    test_field_gammaRamp();
    fn test_field_fGammaValueR() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOGAMMACORRECTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fGammaValueR) as usize - ptr as usize
            },
            6152usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOGAMMACORRECTION),
                "::",
                stringify!(fGammaValueR)
            )
        );
    }
    test_field_fGammaValueR();
    fn test_field_fGammaValueG() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOGAMMACORRECTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fGammaValueG) as usize - ptr as usize
            },
            6156usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOGAMMACORRECTION),
                "::",
                stringify!(fGammaValueG)
            )
        );
    }
    test_field_fGammaValueG();
    fn test_field_fGammaValueB() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOGAMMACORRECTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fGammaValueB) as usize - ptr as usize
            },
            6160usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOGAMMACORRECTION),
                "::",
                stringify!(fGammaValueB)
            )
        );
    }
    test_field_fGammaValueB();
}
impl Default for _NVVIOGAMMACORRECTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Gamma correction"]
pub type NVVIOGAMMACORRECTION = _NVVIOGAMMACORRECTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NVVIOCOMPOSITERANGE {
    pub uRange: NvU32,
    pub uEnabled: NvU32,
    pub uMin: NvU32,
    pub uMax: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOCOMPOSITERANGE() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCOMPOSITERANGE>(),
        16usize,
        concat!("Size of: ", stringify!(_NVVIOCOMPOSITERANGE))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCOMPOSITERANGE>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCOMPOSITERANGE))
    );
    fn test_field_uRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCOMPOSITERANGE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uRange) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCOMPOSITERANGE),
                "::",
                stringify!(uRange)
            )
        );
    }
    test_field_uRange();
    fn test_field_uEnabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCOMPOSITERANGE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uEnabled) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCOMPOSITERANGE),
                "::",
                stringify!(uEnabled)
            )
        );
    }
    test_field_uEnabled();
    fn test_field_uMin() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCOMPOSITERANGE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uMin) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCOMPOSITERANGE),
                "::",
                stringify!(uMin)
            )
        );
    }
    test_field_uMin();
    fn test_field_uMax() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCOMPOSITERANGE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uMax) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCOMPOSITERANGE),
                "::",
                stringify!(uMax)
            )
        );
    }
    test_field_uMax();
}
pub type NVVIOCOMPOSITERANGE = _NVVIOCOMPOSITERANGE;
#[doc = "! Output device configuration"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOOUTPUTCONFIG_V1 {
    #[doc = "!< Signal format for video output"]
    pub signalFormat: NVVIOSIGNALFORMAT,
    #[doc = "!< Data format for video output"]
    pub dataFormat: NVVIODATAFORMAT,
    #[doc = "!< Region for video output (Desktop mode)"]
    pub outputRegion: NVVIOOUTPUTREGION,
    #[doc = "!< Usable resolution for video output (safe area)"]
    pub outputArea: NVVIOOUTPUTAREA,
    #[doc = "!< Color conversion."]
    pub colorConversion: NVVIOCOLORCONVERSION,
    pub gammaCorrection: NVVIOGAMMACORRECTION,
    #[doc = "!< Sync enable (TRUE to use syncSource)"]
    pub syncEnable: NvU32,
    #[doc = "!< Sync source"]
    pub syncSource: NVVIOSYNCSOURCE,
    #[doc = "!< Sync delay"]
    pub syncDelay: NVVIOSYNCDELAY,
    #[doc = "!< Composite sync type"]
    pub compositeSyncType: NVVIOCOMPSYNCTYPE,
    #[doc = "!< Flag indicating whether framelock was on/off"]
    pub frameLockEnable: NvU32,
    #[doc = "!< Indicates whether contained format is PSF Signal format"]
    pub psfSignalFormat: NvU32,
    #[doc = "!< Enables/Disables 4:2:2 filter"]
    pub enable422Filter: NvU32,
    #[doc = "!< Composite termination"]
    pub compositeTerminate: NvU32,
    #[doc = "!< Enable data integrity check: true - enable, false - disable"]
    pub enableDataIntegrityCheck: NvU32,
    #[doc = "!< Use provided CSC color matrix to overwrite"]
    pub cscOverride: NvU32,
    #[doc = "!< Number of buffers used for the internal flipqueue"]
    pub flipQueueLength: NvU32,
    #[doc = "!< Enable SDI ANC time code generation"]
    pub enableANCTimeCodeGeneration: NvU32,
    #[doc = "!< Enable composite"]
    pub enableComposite: NvU32,
    #[doc = "!< Enable Alpha key composite"]
    pub enableAlphaKeyComposite: NvU32,
    #[doc = "!< Composite ranges"]
    pub compRange: NVVIOCOMPOSITERANGE,
    #[doc = "!< Inicates last stored SDI output state TRUE-ON / FALSE-OFF"]
    pub reservedData: [NvU8; 256usize],
    #[doc = "!< Flag indicating Full Color Range"]
    pub enableFullColorRange: NvU32,
    #[doc = "!< Indicates data is in RGB format"]
    pub enableRGBData: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOOUTPUTCONFIG_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOOUTPUTCONFIG_V1>(),
        6604usize,
        concat!("Size of: ", stringify!(_NVVIOOUTPUTCONFIG_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOOUTPUTCONFIG_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOOUTPUTCONFIG_V1))
    );
    fn test_field_signalFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signalFormat) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(signalFormat)
            )
        );
    }
    test_field_signalFormat();
    fn test_field_dataFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dataFormat) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(dataFormat)
            )
        );
    }
    test_field_dataFormat();
    fn test_field_outputRegion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).outputRegion) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(outputRegion)
            )
        );
    }
    test_field_outputRegion();
    fn test_field_outputArea() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).outputArea) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(outputArea)
            )
        );
    }
    test_field_outputArea();
    fn test_field_colorConversion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorConversion) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(colorConversion)
            )
        );
    }
    test_field_colorConversion();
    fn test_field_gammaCorrection() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gammaCorrection) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(gammaCorrection)
            )
        );
    }
    test_field_gammaCorrection();
    fn test_field_syncEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).syncEnable) as usize - ptr as usize
            },
            6260usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(syncEnable)
            )
        );
    }
    test_field_syncEnable();
    fn test_field_syncSource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).syncSource) as usize - ptr as usize
            },
            6264usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(syncSource)
            )
        );
    }
    test_field_syncSource();
    fn test_field_syncDelay() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).syncDelay) as usize - ptr as usize
            },
            6268usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(syncDelay)
            )
        );
    }
    test_field_syncDelay();
    fn test_field_compositeSyncType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compositeSyncType) as usize - ptr as usize
            },
            6280usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(compositeSyncType)
            )
        );
    }
    test_field_compositeSyncType();
    fn test_field_frameLockEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frameLockEnable) as usize - ptr as usize
            },
            6284usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(frameLockEnable)
            )
        );
    }
    test_field_frameLockEnable();
    fn test_field_psfSignalFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).psfSignalFormat) as usize - ptr as usize
            },
            6288usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(psfSignalFormat)
            )
        );
    }
    test_field_psfSignalFormat();
    fn test_field_enable422Filter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enable422Filter) as usize - ptr as usize
            },
            6292usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(enable422Filter)
            )
        );
    }
    test_field_enable422Filter();
    fn test_field_compositeTerminate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compositeTerminate) as usize - ptr as usize
            },
            6296usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(compositeTerminate)
            )
        );
    }
    test_field_compositeTerminate();
    fn test_field_enableDataIntegrityCheck() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enableDataIntegrityCheck) as usize - ptr as usize
            },
            6300usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(enableDataIntegrityCheck)
            )
        );
    }
    test_field_enableDataIntegrityCheck();
    fn test_field_cscOverride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cscOverride) as usize - ptr as usize
            },
            6304usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(cscOverride)
            )
        );
    }
    test_field_cscOverride();
    fn test_field_flipQueueLength() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flipQueueLength) as usize - ptr as usize
            },
            6308usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(flipQueueLength)
            )
        );
    }
    test_field_flipQueueLength();
    fn test_field_enableANCTimeCodeGeneration() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enableANCTimeCodeGeneration) as usize - ptr as usize
            },
            6312usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(enableANCTimeCodeGeneration)
            )
        );
    }
    test_field_enableANCTimeCodeGeneration();
    fn test_field_enableComposite() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enableComposite) as usize - ptr as usize
            },
            6316usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(enableComposite)
            )
        );
    }
    test_field_enableComposite();
    fn test_field_enableAlphaKeyComposite() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enableAlphaKeyComposite) as usize - ptr as usize
            },
            6320usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(enableAlphaKeyComposite)
            )
        );
    }
    test_field_enableAlphaKeyComposite();
    fn test_field_compRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compRange) as usize - ptr as usize
            },
            6324usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(compRange)
            )
        );
    }
    test_field_compRange();
    fn test_field_reservedData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reservedData) as usize - ptr as usize
            },
            6340usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(reservedData)
            )
        );
    }
    test_field_reservedData();
    fn test_field_enableFullColorRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enableFullColorRange) as usize - ptr as usize
            },
            6596usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(enableFullColorRange)
            )
        );
    }
    test_field_enableFullColorRange();
    fn test_field_enableRGBData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enableRGBData) as usize - ptr as usize
            },
            6600usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V1),
                "::",
                stringify!(enableRGBData)
            )
        );
    }
    test_field_enableRGBData();
}
impl Default for _NVVIOOUTPUTCONFIG_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Output device configuration"]
pub type NVVIOOUTPUTCONFIG_V1 = _NVVIOOUTPUTCONFIG_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOOUTPUTCONFIG_V2 {
    #[doc = "!< Signal format for video output"]
    pub signalFormat: NVVIOSIGNALFORMAT,
    #[doc = "!< Data format for video output"]
    pub dataFormat: NVVIODATAFORMAT,
    #[doc = "!< Region for video output (Desktop mode)"]
    pub outputRegion: NVVIOOUTPUTREGION,
    #[doc = "!< Usable resolution for video output (safe area)"]
    pub outputArea: NVVIOOUTPUTAREA,
    #[doc = "!< Color conversion."]
    pub colorConversion: NVVIOCOLORCONVERSION,
    pub gammaCorrection: NVVIOGAMMACORRECTION,
    #[doc = "!< Sync enable (TRUE to use syncSource)"]
    pub syncEnable: NvU32,
    #[doc = "!< Sync source"]
    pub syncSource: NVVIOSYNCSOURCE,
    #[doc = "!< Sync delay"]
    pub syncDelay: NVVIOSYNCDELAY,
    #[doc = "!< Composite sync type"]
    pub compositeSyncType: NVVIOCOMPSYNCTYPE,
    #[doc = "!< Flag indicating whether framelock was on/off"]
    pub frameLockEnable: NvU32,
    #[doc = "!< Indicates whether contained format is PSF Signal format"]
    pub psfSignalFormat: NvU32,
    #[doc = "!< Enables/Disables 4:2:2 filter"]
    pub enable422Filter: NvU32,
    #[doc = "!< Composite termination"]
    pub compositeTerminate: NvU32,
    #[doc = "!< Enable data integrity check: true - enable, false - disable"]
    pub enableDataIntegrityCheck: NvU32,
    #[doc = "!< Use provided CSC color matrix to overwrite"]
    pub cscOverride: NvU32,
    #[doc = "!< Number of buffers used for the internal flip queue"]
    pub flipQueueLength: NvU32,
    #[doc = "!< Enable SDI ANC time code generation"]
    pub enableANCTimeCodeGeneration: NvU32,
    #[doc = "!< Enable composite"]
    pub enableComposite: NvU32,
    #[doc = "!< Enable Alpha key composite"]
    pub enableAlphaKeyComposite: NvU32,
    #[doc = "!< Composite ranges"]
    pub compRange: NVVIOCOMPOSITERANGE,
    #[doc = "!< Indicates last stored SDI output state TRUE-ON / FALSE-OFF"]
    pub reservedData: [NvU8; 256usize],
    #[doc = "!< Flag indicating Full Color Range"]
    pub enableFullColorRange: NvU32,
    #[doc = "!< Indicates data is in RGB format"]
    pub enableRGBData: NvU32,
    #[doc = "!< Enable HW ANC parity bit computation (auto/on/off)"]
    pub ancParityComputation: NVVIOANCPARITYCOMPUTATION,
}
#[test]
fn bindgen_test_layout__NVVIOOUTPUTCONFIG_V2() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOOUTPUTCONFIG_V2>(),
        6608usize,
        concat!("Size of: ", stringify!(_NVVIOOUTPUTCONFIG_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOOUTPUTCONFIG_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOOUTPUTCONFIG_V2))
    );
    fn test_field_signalFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signalFormat) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(signalFormat)
            )
        );
    }
    test_field_signalFormat();
    fn test_field_dataFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dataFormat) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(dataFormat)
            )
        );
    }
    test_field_dataFormat();
    fn test_field_outputRegion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).outputRegion) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(outputRegion)
            )
        );
    }
    test_field_outputRegion();
    fn test_field_outputArea() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).outputArea) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(outputArea)
            )
        );
    }
    test_field_outputArea();
    fn test_field_colorConversion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorConversion) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(colorConversion)
            )
        );
    }
    test_field_colorConversion();
    fn test_field_gammaCorrection() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gammaCorrection) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(gammaCorrection)
            )
        );
    }
    test_field_gammaCorrection();
    fn test_field_syncEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).syncEnable) as usize - ptr as usize
            },
            6260usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(syncEnable)
            )
        );
    }
    test_field_syncEnable();
    fn test_field_syncSource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).syncSource) as usize - ptr as usize
            },
            6264usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(syncSource)
            )
        );
    }
    test_field_syncSource();
    fn test_field_syncDelay() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).syncDelay) as usize - ptr as usize
            },
            6268usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(syncDelay)
            )
        );
    }
    test_field_syncDelay();
    fn test_field_compositeSyncType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compositeSyncType) as usize - ptr as usize
            },
            6280usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(compositeSyncType)
            )
        );
    }
    test_field_compositeSyncType();
    fn test_field_frameLockEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frameLockEnable) as usize - ptr as usize
            },
            6284usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(frameLockEnable)
            )
        );
    }
    test_field_frameLockEnable();
    fn test_field_psfSignalFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).psfSignalFormat) as usize - ptr as usize
            },
            6288usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(psfSignalFormat)
            )
        );
    }
    test_field_psfSignalFormat();
    fn test_field_enable422Filter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enable422Filter) as usize - ptr as usize
            },
            6292usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(enable422Filter)
            )
        );
    }
    test_field_enable422Filter();
    fn test_field_compositeTerminate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compositeTerminate) as usize - ptr as usize
            },
            6296usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(compositeTerminate)
            )
        );
    }
    test_field_compositeTerminate();
    fn test_field_enableDataIntegrityCheck() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enableDataIntegrityCheck) as usize - ptr as usize
            },
            6300usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(enableDataIntegrityCheck)
            )
        );
    }
    test_field_enableDataIntegrityCheck();
    fn test_field_cscOverride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cscOverride) as usize - ptr as usize
            },
            6304usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(cscOverride)
            )
        );
    }
    test_field_cscOverride();
    fn test_field_flipQueueLength() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flipQueueLength) as usize - ptr as usize
            },
            6308usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(flipQueueLength)
            )
        );
    }
    test_field_flipQueueLength();
    fn test_field_enableANCTimeCodeGeneration() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enableANCTimeCodeGeneration) as usize - ptr as usize
            },
            6312usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(enableANCTimeCodeGeneration)
            )
        );
    }
    test_field_enableANCTimeCodeGeneration();
    fn test_field_enableComposite() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enableComposite) as usize - ptr as usize
            },
            6316usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(enableComposite)
            )
        );
    }
    test_field_enableComposite();
    fn test_field_enableAlphaKeyComposite() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enableAlphaKeyComposite) as usize - ptr as usize
            },
            6320usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(enableAlphaKeyComposite)
            )
        );
    }
    test_field_enableAlphaKeyComposite();
    fn test_field_compRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compRange) as usize - ptr as usize
            },
            6324usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(compRange)
            )
        );
    }
    test_field_compRange();
    fn test_field_reservedData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reservedData) as usize - ptr as usize
            },
            6340usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(reservedData)
            )
        );
    }
    test_field_reservedData();
    fn test_field_enableFullColorRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enableFullColorRange) as usize - ptr as usize
            },
            6596usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(enableFullColorRange)
            )
        );
    }
    test_field_enableFullColorRange();
    fn test_field_enableRGBData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enableRGBData) as usize - ptr as usize
            },
            6600usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(enableRGBData)
            )
        );
    }
    test_field_enableRGBData();
    fn test_field_ancParityComputation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ancParityComputation) as usize - ptr as usize
            },
            6604usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V2),
                "::",
                stringify!(ancParityComputation)
            )
        );
    }
    test_field_ancParityComputation();
}
impl Default for _NVVIOOUTPUTCONFIG_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NVVIOOUTPUTCONFIG_V2 = _NVVIOOUTPUTCONFIG_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOOUTPUTCONFIG_V3 {
    #[doc = "!< Signal format for video output"]
    pub signalFormat: NVVIOSIGNALFORMAT,
    #[doc = "!< Data format for video output"]
    pub dataFormat: NVVIODATAFORMAT,
    #[doc = "!< Region for video output (Desktop mode)"]
    pub outputRegion: NVVIOOUTPUTREGION,
    #[doc = "!< Usable resolution for video output (safe area)"]
    pub outputArea: NVVIOOUTPUTAREA,
    #[doc = "!< Color conversion."]
    pub colorConversion: NVVIOCOLORCONVERSION,
    pub gammaCorrection: NVVIOGAMMACORRECTION,
    #[doc = "!< Sync enable (TRUE to use syncSource)"]
    pub syncEnable: NvU32,
    #[doc = "!< Sync source"]
    pub syncSource: NVVIOSYNCSOURCE,
    #[doc = "!< Sync delay"]
    pub syncDelay: NVVIOSYNCDELAY,
    #[doc = "!< Composite sync type"]
    pub compositeSyncType: NVVIOCOMPSYNCTYPE,
    #[doc = "!< Flag indicating whether framelock was on/off"]
    pub frameLockEnable: NvU32,
    #[doc = "!< Indicates whether contained format is PSF Signal format"]
    pub psfSignalFormat: NvU32,
    #[doc = "!< Enables/Disables 4:2:2 filter"]
    pub enable422Filter: NvU32,
    #[doc = "!< Composite termination"]
    pub compositeTerminate: NvU32,
    #[doc = "!< Enable data integrity check: true - enable, false - disable"]
    pub enableDataIntegrityCheck: NvU32,
    #[doc = "!< Use provided CSC color matrix to overwrite"]
    pub cscOverride: NvU32,
    #[doc = "!< Number of buffers used for the internal flip queue"]
    pub flipQueueLength: NvU32,
    #[doc = "!< Enable SDI ANC time code generation"]
    pub enableANCTimeCodeGeneration: NvU32,
    #[doc = "!< Enable composite"]
    pub enableComposite: NvU32,
    #[doc = "!< Enable Alpha key composite"]
    pub enableAlphaKeyComposite: NvU32,
    #[doc = "!< Composite ranges"]
    pub compRange: NVVIOCOMPOSITERANGE,
    #[doc = "!< Indicates last stored SDI output state TRUE-ON / FALSE-OFF"]
    pub reservedData: [NvU8; 256usize],
    #[doc = "!< Flag indicating Full Color Range"]
    pub enableFullColorRange: NvU32,
    #[doc = "!< Indicates data is in RGB format"]
    pub enableRGBData: NvU32,
    #[doc = "!< Enable HW ANC parity bit computation (auto/on/off)"]
    pub ancParityComputation: NVVIOANCPARITYCOMPUTATION,
    #[doc = "!< Enable HANC audio blanking on repeat frames"]
    pub enableAudioBlanking: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOOUTPUTCONFIG_V3() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOOUTPUTCONFIG_V3>(),
        6612usize,
        concat!("Size of: ", stringify!(_NVVIOOUTPUTCONFIG_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOOUTPUTCONFIG_V3>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOOUTPUTCONFIG_V3))
    );
    fn test_field_signalFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signalFormat) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(signalFormat)
            )
        );
    }
    test_field_signalFormat();
    fn test_field_dataFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dataFormat) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(dataFormat)
            )
        );
    }
    test_field_dataFormat();
    fn test_field_outputRegion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).outputRegion) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(outputRegion)
            )
        );
    }
    test_field_outputRegion();
    fn test_field_outputArea() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).outputArea) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(outputArea)
            )
        );
    }
    test_field_outputArea();
    fn test_field_colorConversion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorConversion) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(colorConversion)
            )
        );
    }
    test_field_colorConversion();
    fn test_field_gammaCorrection() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gammaCorrection) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(gammaCorrection)
            )
        );
    }
    test_field_gammaCorrection();
    fn test_field_syncEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).syncEnable) as usize - ptr as usize
            },
            6260usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(syncEnable)
            )
        );
    }
    test_field_syncEnable();
    fn test_field_syncSource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).syncSource) as usize - ptr as usize
            },
            6264usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(syncSource)
            )
        );
    }
    test_field_syncSource();
    fn test_field_syncDelay() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).syncDelay) as usize - ptr as usize
            },
            6268usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(syncDelay)
            )
        );
    }
    test_field_syncDelay();
    fn test_field_compositeSyncType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compositeSyncType) as usize - ptr as usize
            },
            6280usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(compositeSyncType)
            )
        );
    }
    test_field_compositeSyncType();
    fn test_field_frameLockEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frameLockEnable) as usize - ptr as usize
            },
            6284usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(frameLockEnable)
            )
        );
    }
    test_field_frameLockEnable();
    fn test_field_psfSignalFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).psfSignalFormat) as usize - ptr as usize
            },
            6288usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(psfSignalFormat)
            )
        );
    }
    test_field_psfSignalFormat();
    fn test_field_enable422Filter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enable422Filter) as usize - ptr as usize
            },
            6292usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(enable422Filter)
            )
        );
    }
    test_field_enable422Filter();
    fn test_field_compositeTerminate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compositeTerminate) as usize - ptr as usize
            },
            6296usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(compositeTerminate)
            )
        );
    }
    test_field_compositeTerminate();
    fn test_field_enableDataIntegrityCheck() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enableDataIntegrityCheck) as usize - ptr as usize
            },
            6300usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(enableDataIntegrityCheck)
            )
        );
    }
    test_field_enableDataIntegrityCheck();
    fn test_field_cscOverride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cscOverride) as usize - ptr as usize
            },
            6304usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(cscOverride)
            )
        );
    }
    test_field_cscOverride();
    fn test_field_flipQueueLength() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flipQueueLength) as usize - ptr as usize
            },
            6308usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(flipQueueLength)
            )
        );
    }
    test_field_flipQueueLength();
    fn test_field_enableANCTimeCodeGeneration() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enableANCTimeCodeGeneration) as usize - ptr as usize
            },
            6312usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(enableANCTimeCodeGeneration)
            )
        );
    }
    test_field_enableANCTimeCodeGeneration();
    fn test_field_enableComposite() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enableComposite) as usize - ptr as usize
            },
            6316usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(enableComposite)
            )
        );
    }
    test_field_enableComposite();
    fn test_field_enableAlphaKeyComposite() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enableAlphaKeyComposite) as usize - ptr as usize
            },
            6320usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(enableAlphaKeyComposite)
            )
        );
    }
    test_field_enableAlphaKeyComposite();
    fn test_field_compRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compRange) as usize - ptr as usize
            },
            6324usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(compRange)
            )
        );
    }
    test_field_compRange();
    fn test_field_reservedData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reservedData) as usize - ptr as usize
            },
            6340usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(reservedData)
            )
        );
    }
    test_field_reservedData();
    fn test_field_enableFullColorRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enableFullColorRange) as usize - ptr as usize
            },
            6596usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(enableFullColorRange)
            )
        );
    }
    test_field_enableFullColorRange();
    fn test_field_enableRGBData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enableRGBData) as usize - ptr as usize
            },
            6600usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(enableRGBData)
            )
        );
    }
    test_field_enableRGBData();
    fn test_field_ancParityComputation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ancParityComputation) as usize - ptr as usize
            },
            6604usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(ancParityComputation)
            )
        );
    }
    test_field_ancParityComputation();
    fn test_field_enableAudioBlanking() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOOUTPUTCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enableAudioBlanking) as usize - ptr as usize
            },
            6608usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOOUTPUTCONFIG_V3),
                "::",
                stringify!(enableAudioBlanking)
            )
        );
    }
    test_field_enableAudioBlanking();
}
impl Default for _NVVIOOUTPUTCONFIG_V3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NVVIOOUTPUTCONFIG_V3 = _NVVIOOUTPUTCONFIG_V3;
#[doc = "! Stream configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOSTREAM {
    #[doc = "!< Bits per component"]
    pub bitsPerComponent: NvU32,
    #[doc = "!< Sampling"]
    pub sampling: NVVIOCOMPONENTSAMPLING,
    #[doc = "!< Enable/disable 4:2:2->4:4:4 expansion"]
    pub expansionEnable: NvU32,
    #[doc = "!< Number of active links"]
    pub numLinks: NvU32,
    pub links: [_NVVIOSTREAM__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NVVIOSTREAM__bindgen_ty_1 {
    #[doc = "!< This stream's link[i] will use the specified (0-based) channel within the"]
    pub jack: NvU32,
    #[doc = "!< specified (0-based) jack"]
    pub channel: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOSTREAM__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOSTREAM__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_NVVIOSTREAM__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOSTREAM__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOSTREAM__bindgen_ty_1))
    );
    fn test_field_jack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOSTREAM__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).jack) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOSTREAM__bindgen_ty_1),
                "::",
                stringify!(jack)
            )
        );
    }
    test_field_jack();
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOSTREAM__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOSTREAM__bindgen_ty_1),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
}
#[test]
fn bindgen_test_layout__NVVIOSTREAM() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOSTREAM>(),
        32usize,
        concat!("Size of: ", stringify!(_NVVIOSTREAM))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOSTREAM>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOSTREAM))
    );
    fn test_field_bitsPerComponent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOSTREAM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bitsPerComponent) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOSTREAM),
                "::",
                stringify!(bitsPerComponent)
            )
        );
    }
    test_field_bitsPerComponent();
    fn test_field_sampling() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOSTREAM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampling) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOSTREAM),
                "::",
                stringify!(sampling)
            )
        );
    }
    test_field_sampling();
    fn test_field_expansionEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOSTREAM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).expansionEnable) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOSTREAM),
                "::",
                stringify!(expansionEnable)
            )
        );
    }
    test_field_expansionEnable();
    fn test_field_numLinks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOSTREAM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numLinks) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOSTREAM),
                "::",
                stringify!(numLinks)
            )
        );
    }
    test_field_numLinks();
    fn test_field_links() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOSTREAM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).links) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOSTREAM),
                "::",
                stringify!(links)
            )
        );
    }
    test_field_links();
}
impl Default for _NVVIOSTREAM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Stream configuration"]
pub type NVVIOSTREAM = _NVVIOSTREAM;
#[doc = "! Input device configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOINPUTCONFIG {
    #[doc = "!< numRawCaptureImages is the number of frames to keep in the capture queue."]
    #[doc = "!< must be between NVAPI_GVI_MIN_RAW_CAPTURE_IMAGES and NVAPI_GVI_MAX_RAW_CAPTURE_IMAGES,"]
    pub numRawCaptureImages: NvU32,
    #[doc = "!< Signal format."]
    #[doc = "!< Please note that both numRawCaptureImages and signalFormat should be set together."]
    pub signalFormat: NVVIOSIGNALFORMAT,
    #[doc = "!< Number of active streams."]
    pub numStreams: NvU32,
    #[doc = "!< Stream configurations"]
    pub streams: [NVVIOSTREAM; 4usize],
    #[doc = "!< This attribute controls the GVI test mode."]
    #[doc = "!< Possible values 0/1. When testmode enabled, the"]
    #[doc = "!< GVI device will generate fake data as quickly as possible."]
    pub bTestMode: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOINPUTCONFIG() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOINPUTCONFIG>(),
        144usize,
        concat!("Size of: ", stringify!(_NVVIOINPUTCONFIG))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOINPUTCONFIG>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOINPUTCONFIG))
    );
    fn test_field_numRawCaptureImages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOINPUTCONFIG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numRawCaptureImages) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOINPUTCONFIG),
                "::",
                stringify!(numRawCaptureImages)
            )
        );
    }
    test_field_numRawCaptureImages();
    fn test_field_signalFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOINPUTCONFIG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signalFormat) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOINPUTCONFIG),
                "::",
                stringify!(signalFormat)
            )
        );
    }
    test_field_signalFormat();
    fn test_field_numStreams() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOINPUTCONFIG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numStreams) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOINPUTCONFIG),
                "::",
                stringify!(numStreams)
            )
        );
    }
    test_field_numStreams();
    fn test_field_streams() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOINPUTCONFIG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).streams) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOINPUTCONFIG),
                "::",
                stringify!(streams)
            )
        );
    }
    test_field_streams();
    fn test_field_bTestMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOINPUTCONFIG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bTestMode) as usize - ptr as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOINPUTCONFIG),
                "::",
                stringify!(bTestMode)
            )
        );
    }
    test_field_bTestMode();
}
impl Default for _NVVIOINPUTCONFIG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Input device configuration"]
pub type NVVIOINPUTCONFIG = _NVVIOINPUTCONFIG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOCONFIG_V1 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< Caller sets to NVVIOCONFIG_* mask for fields to use"]
    pub fields: NvU32,
    #[doc = "!< Input or Output configuration"]
    pub nvvioConfigType: NVVIOCONFIGTYPE,
    pub vioConfig: _NVVIOCONFIG_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVVIOCONFIG_V1__bindgen_ty_1 {
    #[doc = "!<  Input device configuration"]
    pub inConfig: NVVIOINPUTCONFIG,
    #[doc = "!<  Output device configuration"]
    pub outConfig: NVVIOOUTPUTCONFIG_V1,
}
#[test]
fn bindgen_test_layout__NVVIOCONFIG_V1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCONFIG_V1__bindgen_ty_1>(),
        6604usize,
        concat!("Size of: ", stringify!(_NVVIOCONFIG_V1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCONFIG_V1__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCONFIG_V1__bindgen_ty_1))
    );
    fn test_field_inConfig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCONFIG_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inConfig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCONFIG_V1__bindgen_ty_1),
                "::",
                stringify!(inConfig)
            )
        );
    }
    test_field_inConfig();
    fn test_field_outConfig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCONFIG_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).outConfig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCONFIG_V1__bindgen_ty_1),
                "::",
                stringify!(outConfig)
            )
        );
    }
    test_field_outConfig();
}
impl Default for _NVVIOCONFIG_V1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__NVVIOCONFIG_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCONFIG_V1>(),
        6616usize,
        concat!("Size of: ", stringify!(_NVVIOCONFIG_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCONFIG_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCONFIG_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCONFIG_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_fields() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fields) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCONFIG_V1),
                "::",
                stringify!(fields)
            )
        );
    }
    test_field_fields();
    fn test_field_nvvioConfigType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvvioConfigType) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCONFIG_V1),
                "::",
                stringify!(nvvioConfigType)
            )
        );
    }
    test_field_nvvioConfigType();
    fn test_field_vioConfig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCONFIG_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vioConfig) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCONFIG_V1),
                "::",
                stringify!(vioConfig)
            )
        );
    }
    test_field_vioConfig();
}
impl Default for _NVVIOCONFIG_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NVVIOCONFIG_V1 = _NVVIOCONFIG_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOCONFIG_V2 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< Caller sets to NVVIOCONFIG_* mask for fields to use"]
    pub fields: NvU32,
    #[doc = "!< Input or Output configuration"]
    pub nvvioConfigType: NVVIOCONFIGTYPE,
    pub vioConfig: _NVVIOCONFIG_V2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVVIOCONFIG_V2__bindgen_ty_1 {
    #[doc = "!< Input device configuration"]
    pub inConfig: NVVIOINPUTCONFIG,
    #[doc = "!< Output device configuration"]
    pub outConfig: NVVIOOUTPUTCONFIG_V2,
}
#[test]
fn bindgen_test_layout__NVVIOCONFIG_V2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCONFIG_V2__bindgen_ty_1>(),
        6608usize,
        concat!("Size of: ", stringify!(_NVVIOCONFIG_V2__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCONFIG_V2__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCONFIG_V2__bindgen_ty_1))
    );
    fn test_field_inConfig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCONFIG_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inConfig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCONFIG_V2__bindgen_ty_1),
                "::",
                stringify!(inConfig)
            )
        );
    }
    test_field_inConfig();
    fn test_field_outConfig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCONFIG_V2__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).outConfig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCONFIG_V2__bindgen_ty_1),
                "::",
                stringify!(outConfig)
            )
        );
    }
    test_field_outConfig();
}
impl Default for _NVVIOCONFIG_V2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__NVVIOCONFIG_V2() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCONFIG_V2>(),
        6620usize,
        concat!("Size of: ", stringify!(_NVVIOCONFIG_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCONFIG_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCONFIG_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCONFIG_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_fields() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fields) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCONFIG_V2),
                "::",
                stringify!(fields)
            )
        );
    }
    test_field_fields();
    fn test_field_nvvioConfigType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvvioConfigType) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCONFIG_V2),
                "::",
                stringify!(nvvioConfigType)
            )
        );
    }
    test_field_nvvioConfigType();
    fn test_field_vioConfig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCONFIG_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vioConfig) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCONFIG_V2),
                "::",
                stringify!(vioConfig)
            )
        );
    }
    test_field_vioConfig();
}
impl Default for _NVVIOCONFIG_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NVVIOCONFIG_V2 = _NVVIOCONFIG_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOCONFIG_V3 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< Caller sets to NVVIOCONFIG_* mask for fields to use"]
    pub fields: NvU32,
    #[doc = "!< Input or Output configuration"]
    pub nvvioConfigType: NVVIOCONFIGTYPE,
    pub vioConfig: _NVVIOCONFIG_V3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVVIOCONFIG_V3__bindgen_ty_1 {
    #[doc = "!< Input device configuration"]
    pub inConfig: NVVIOINPUTCONFIG,
    #[doc = "!< Output device configuration"]
    pub outConfig: NVVIOOUTPUTCONFIG_V3,
}
#[test]
fn bindgen_test_layout__NVVIOCONFIG_V3__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCONFIG_V3__bindgen_ty_1>(),
        6612usize,
        concat!("Size of: ", stringify!(_NVVIOCONFIG_V3__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCONFIG_V3__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCONFIG_V3__bindgen_ty_1))
    );
    fn test_field_inConfig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCONFIG_V3__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inConfig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCONFIG_V3__bindgen_ty_1),
                "::",
                stringify!(inConfig)
            )
        );
    }
    test_field_inConfig();
    fn test_field_outConfig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCONFIG_V3__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).outConfig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCONFIG_V3__bindgen_ty_1),
                "::",
                stringify!(outConfig)
            )
        );
    }
    test_field_outConfig();
}
impl Default for _NVVIOCONFIG_V3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__NVVIOCONFIG_V3() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCONFIG_V3>(),
        6624usize,
        concat!("Size of: ", stringify!(_NVVIOCONFIG_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCONFIG_V3>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCONFIG_V3))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCONFIG_V3),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_fields() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fields) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCONFIG_V3),
                "::",
                stringify!(fields)
            )
        );
    }
    test_field_fields();
    fn test_field_nvvioConfigType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvvioConfigType) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCONFIG_V3),
                "::",
                stringify!(nvvioConfigType)
            )
        );
    }
    test_field_nvvioConfigType();
    fn test_field_vioConfig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOCONFIG_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vioConfig) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOCONFIG_V3),
                "::",
                stringify!(vioConfig)
            )
        );
    }
    test_field_vioConfig();
}
impl Default for _NVVIOCONFIG_V3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NVVIOCONFIG_V3 = _NVVIOCONFIG_V3;
pub type NVVIOOUTPUTCONFIG = NVVIOOUTPUTCONFIG_V3;
pub type NVVIOCONFIG = NVVIOCONFIG_V3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NVVIOTOPOLOGYTARGET {
    #[doc = "!< Handle to Physical GPU (This could be NULL for GVI device if its not binded)"]
    pub hPhysicalGpu: NvPhysicalGpuHandle,
    #[doc = "!< handle to SDI Input/Output device"]
    pub hVioHandle: NvVioHandle,
    #[doc = "!< device Id of SDI Input/Output device"]
    pub vioId: NvU32,
    #[doc = "!< deviceMask of the SDI display connected to GVO device."]
    #[doc = "!< outputId will be 0 for GVI device."]
    pub outputId: NvU32,
}
#[test]
fn bindgen_test_layout_NVVIOTOPOLOGYTARGET() {
    assert_eq!(
        ::std::mem::size_of::<NVVIOTOPOLOGYTARGET>(),
        24usize,
        concat!("Size of: ", stringify!(NVVIOTOPOLOGYTARGET))
    );
    assert_eq!(
        ::std::mem::align_of::<NVVIOTOPOLOGYTARGET>(),
        8usize,
        concat!("Alignment of ", stringify!(NVVIOTOPOLOGYTARGET))
    );
    fn test_field_hPhysicalGpu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NVVIOTOPOLOGYTARGET>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hPhysicalGpu) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NVVIOTOPOLOGYTARGET),
                "::",
                stringify!(hPhysicalGpu)
            )
        );
    }
    test_field_hPhysicalGpu();
    fn test_field_hVioHandle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NVVIOTOPOLOGYTARGET>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hVioHandle) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NVVIOTOPOLOGYTARGET),
                "::",
                stringify!(hVioHandle)
            )
        );
    }
    test_field_hVioHandle();
    fn test_field_vioId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NVVIOTOPOLOGYTARGET>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vioId) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NVVIOTOPOLOGYTARGET),
                "::",
                stringify!(vioId)
            )
        );
    }
    test_field_vioId();
    fn test_field_outputId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NVVIOTOPOLOGYTARGET>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).outputId) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(NVVIOTOPOLOGYTARGET),
                "::",
                stringify!(outputId)
            )
        );
    }
    test_field_outputId();
}
impl Default for NVVIOTOPOLOGYTARGET {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_VIO_TOPOLOGY {
    pub version: NvU32,
    #[doc = "!< How many video I/O targets are valid"]
    pub vioTotalDeviceCount: NvU32,
    #[doc = "!< Array of video I/O targets"]
    pub vioTarget: [NVVIOTOPOLOGYTARGET; 8usize],
}
#[test]
fn bindgen_test_layout__NV_VIO_TOPOLOGY() {
    assert_eq!(
        ::std::mem::size_of::<_NV_VIO_TOPOLOGY>(),
        200usize,
        concat!("Size of: ", stringify!(_NV_VIO_TOPOLOGY))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_VIO_TOPOLOGY>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_VIO_TOPOLOGY))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_VIO_TOPOLOGY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_VIO_TOPOLOGY),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_vioTotalDeviceCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_VIO_TOPOLOGY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vioTotalDeviceCount) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_VIO_TOPOLOGY),
                "::",
                stringify!(vioTotalDeviceCount)
            )
        );
    }
    test_field_vioTotalDeviceCount();
    fn test_field_vioTarget() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_VIO_TOPOLOGY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vioTarget) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_VIO_TOPOLOGY),
                "::",
                stringify!(vioTarget)
            )
        );
    }
    test_field_vioTarget();
}
impl Default for _NV_VIO_TOPOLOGY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_VIO_TOPOLOGY = _NV_VIO_TOPOLOGY;
pub type NVVIOTOPOLOGY = _NV_VIO_TOPOLOGY;
extern "C" {
    #[doc = "! \\addtogroup vidio"]
    #[doc = "! @{"]
    #[doc = ""]
    #[doc = "!"]
    #[doc = "!   Function:    NvAPI_VIO_GetCapabilities"]
    #[doc = "!"]
    #[doc = "!   Description: This API determine the graphics adapter video I/O capabilities."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 440."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 190"]
    #[doc = "!"]
    #[doc = "! \\param [in]  NvVioHandle   The caller provides the SDI device handle as input."]
    #[doc = "! \\param [out] pAdapterCaps  Pointer to receive capabilities"]
    #[doc = "!"]
    #[doc = "! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported"]
    #[doc = "!"]
    #[doc = ""]
    pub fn NvAPI_VIO_GetCapabilities(
        hVioHandle: NvVioHandle,
        pAdapterCaps: *mut NVVIOCAPS,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    #[doc = "!   Function:    NvAPI_VIO_Open"]
    #[doc = "!"]
    #[doc = "!   Description: This API opens the graphics adapter for video I/O operations"]
    #[doc = "!                using the OpenGL application interface.  Read operations"]
    #[doc = "!                are permitted in this mode by multiple clients, but Write"]
    #[doc = "!                operations are application exclusive."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 440."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 190"]
    #[doc = "!"]
    #[doc = "! \\param [in]  NvVioHandle      The caller provides the SDI output device handle as input."]
    #[doc = "! \\param [in]  vioClass         Class interface (NVVIOCLASS_* value)"]
    #[doc = "! \\param [in]  ownerType        Specify NVVIOOWNERTYPE_APPLICATION or NVVIOOWNERTYPE_DESKTOP."]
    #[doc = "!"]
    #[doc = "! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported"]
    #[doc = "!"]
    #[doc = ""]
    pub fn NvAPI_VIO_Open(
        hVioHandle: NvVioHandle,
        vioClass: NvU32,
        ownerType: NVVIOOWNERTYPE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    #[doc = "!   Function:    NvAPI_VIO_Close"]
    #[doc = "!"]
    #[doc = "!   Description: This API closes the graphics adapter for graphics-to-video operations"]
    #[doc = "!                using the OpenGL application interface.  Closing an"]
    #[doc = "!                OpenGL handle releases the device."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 440."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 190"]
    #[doc = "!"]
    #[doc = "! \\param [in]  NvVioHandle   The caller provides the SDI output device handle as input."]
    #[doc = "! \\param [in]  bRelease      boolean value to either keep or release ownership"]
    #[doc = "!"]
    #[doc = "! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported"]
    #[doc = "!"]
    #[doc = ""]
    pub fn NvAPI_VIO_Close(hVioHandle: NvVioHandle, bRelease: NvU32) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    #[doc = "!   Function:    NvAPI_VIO_Status"]
    #[doc = "!"]
    #[doc = "!   Description: This API gets the Video I/O LED status."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 440."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 190"]
    #[doc = "!"]
    #[doc = "! \\param [in]  NvVioHandle   The caller provides the SDI device handle as input."]
    #[doc = "! \\param [out] pStatus       Return pointer to NVVIOSTATUS"]
    #[doc = "!"]
    #[doc = "! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported"]
    #[doc = "!"]
    #[doc = ""]
    pub fn NvAPI_VIO_Status(hVioHandle: NvVioHandle, pStatus: *mut NVVIOSTATUS) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    #[doc = "!   Function:    NvAPI_VIO_SyncFormatDetect"]
    #[doc = "!"]
    #[doc = "!   Description: This API detects the Video I/O incoming sync video format."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 440."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 190"]
    #[doc = "!"]
    #[doc = "! \\param [in]  NvVioHandle  The caller provides the SDI device handle as input."]
    #[doc = "! \\param [out] pWait        Pointer to receive how many milliseconds will lapse"]
    #[doc = "!                           before VIOStatus returns the detected syncFormat."]
    #[doc = "!"]
    #[doc = "! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported"]
    #[doc = "!"]
    #[doc = ""]
    pub fn NvAPI_VIO_SyncFormatDetect(hVioHandle: NvVioHandle, pWait: *mut NvU32) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    #[doc = "!   Function:    NvAPI_VIO_GetConfig"]
    #[doc = "!"]
    #[doc = "!   Description: This API gets the graphics-to-video configuration."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 440."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 190"]
    #[doc = "!"]
    #[doc = "! \\param [in]  NvVioHandle   The caller provides the SDI device handle as input."]
    #[doc = "! \\param [out] pConfig       Pointer to the graphics-to-video configuration"]
    #[doc = "!"]
    #[doc = "! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported"]
    #[doc = "!"]
    #[doc = ""]
    pub fn NvAPI_VIO_GetConfig(hVioHandle: NvVioHandle, pConfig: *mut NVVIOCONFIG) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    #[doc = "!   Function:    NvAPI_VIO_SetConfig"]
    #[doc = "!"]
    #[doc = "!   Description: This API sets the graphics-to-video configuration."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 440."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 190"]
    #[doc = "!"]
    #[doc = "! \\param [in]  NvVioHandle      The caller provides the SDI device handle as input."]
    #[doc = "! \\param [in]  pConfig          Pointer to Graphics-to-Video configuration"]
    #[doc = "!"]
    #[doc = "! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported"]
    #[doc = "!"]
    #[doc = ""]
    pub fn NvAPI_VIO_SetConfig(
        hVioHandle: NvVioHandle,
        pConfig: *const NVVIOCONFIG,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    #[doc = "!   Function:    NvAPI_VIO_SetCSC"]
    #[doc = "!"]
    #[doc = "!   Description: This API sets the colorspace conversion parameters."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_SetConfig."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 190"]
    #[doc = "!"]
    #[doc = "! \\param [in]  NvVioHandle      The caller provides the SDI device handle as input."]
    #[doc = "! \\param [in]  pCSC             Pointer to CSC parameters"]
    #[doc = "!"]
    #[doc = "! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported"]
    #[doc = "!"]
    #[doc = "----"]
    pub fn NvAPI_VIO_SetCSC(
        hVioHandle: NvVioHandle,
        pCSC: *mut NVVIOCOLORCONVERSION,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    #[doc = "!   Function:    NvAPI_VIO_GetCSC"]
    #[doc = "!"]
    #[doc = "!   Description: This API gets the colorspace conversion parameters."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_GetConfig."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 190"]
    #[doc = "!"]
    #[doc = "! \\param [in]  NvVioHandle      The caller provides the SDI device handle as input."]
    #[doc = "! \\param [out] pCSC             Pointer to CSC parameters"]
    #[doc = "!"]
    #[doc = "! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported"]
    #[doc = "!"]
    #[doc = ""]
    pub fn NvAPI_VIO_GetCSC(
        hVioHandle: NvVioHandle,
        pCSC: *mut NVVIOCOLORCONVERSION,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    #[doc = "!   Function:    NvAPI_VIO_SetGamma"]
    #[doc = "!"]
    #[doc = "!   Description: This API sets the gamma conversion parameters."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_SetConfig."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 190"]
    #[doc = "!"]
    #[doc = "! \\param [in]  NvVioHandle       The caller provides the SDI device handle as input."]
    #[doc = "! \\param [in]  pGamma            Pointer to gamma parameters"]
    #[doc = "!"]
    #[doc = "! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported"]
    #[doc = "!"]
    #[doc = ""]
    pub fn NvAPI_VIO_SetGamma(
        hVioHandle: NvVioHandle,
        pGamma: *mut NVVIOGAMMACORRECTION,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    #[doc = "!   Function:    NvAPI_VIO_GetGamma"]
    #[doc = "!"]
    #[doc = "!   Description: This API gets the gamma conversion parameters."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_GetConfig."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 190"]
    #[doc = "!"]
    #[doc = "! \\param [in]  NvVioHandle      The caller provides the SDI device handle as input."]
    #[doc = "! \\param [out] pGamma           Pointer to gamma parameters"]
    #[doc = "!"]
    #[doc = "! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported"]
    #[doc = "!"]
    #[doc = ""]
    pub fn NvAPI_VIO_GetGamma(
        hVioHandle: NvVioHandle,
        pGamma: *mut NVVIOGAMMACORRECTION,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    #[doc = "!   Function:    NvAPI_VIO_SetSyncDelay"]
    #[doc = "!"]
    #[doc = "!   Description: This API sets the sync delay parameters."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_SetConfig."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 190"]
    #[doc = "!"]
    #[doc = "! \\param [in]  NvVioHandle   The caller provides the SDI device handle as input."]
    #[doc = "! \\param [in]  pSyncDelay    Pointer to sync delay parameters"]
    #[doc = "!"]
    #[doc = "! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported"]
    #[doc = "!"]
    #[doc = ""]
    pub fn NvAPI_VIO_SetSyncDelay(
        hVioHandle: NvVioHandle,
        pSyncDelay: *const NVVIOSYNCDELAY,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    #[doc = "!   Function:    NvAPI_VIO_GetSyncDelay"]
    #[doc = "!"]
    #[doc = "!   Description: This API gets the sync delay parameters."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_GetConfig."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 190"]
    #[doc = "!"]
    #[doc = "! \\param [in]  NvVioHandle      The caller provides the SDI device handle as input."]
    #[doc = "! \\param [out] pSyncDelay       Pointer to sync delay parameters"]
    #[doc = "!"]
    #[doc = "! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported"]
    #[doc = "!"]
    #[doc = ""]
    pub fn NvAPI_VIO_GetSyncDelay(
        hVioHandle: NvVioHandle,
        pSyncDelay: *mut NVVIOSYNCDELAY,
    ) -> NvAPI_Status;
}
pub const _NVVIOPCILINKRATE_NVVIOPCILINKRATE_UNKNOWN: _NVVIOPCILINKRATE = 0;
pub const _NVVIOPCILINKRATE_NVVIOPCILINKRATE_GEN1: _NVVIOPCILINKRATE = 1;
pub const _NVVIOPCILINKRATE_NVVIOPCILINKRATE_GEN2: _NVVIOPCILINKRATE = 2;
pub const _NVVIOPCILINKRATE_NVVIOPCILINKRATE_GEN3: _NVVIOPCILINKRATE = 3;
pub type _NVVIOPCILINKRATE = ::std::os::raw::c_int;
pub use self::_NVVIOPCILINKRATE as NVVIOPCILINKRATE;
pub const _NVVIOPCILINKWIDTH_NVVIOPCILINKWIDTH_UNKNOWN: _NVVIOPCILINKWIDTH = 0;
pub const _NVVIOPCILINKWIDTH_NVVIOPCILINKWIDTH_x1: _NVVIOPCILINKWIDTH = 1;
pub const _NVVIOPCILINKWIDTH_NVVIOPCILINKWIDTH_x2: _NVVIOPCILINKWIDTH = 2;
pub const _NVVIOPCILINKWIDTH_NVVIOPCILINKWIDTH_x4: _NVVIOPCILINKWIDTH = 4;
pub const _NVVIOPCILINKWIDTH_NVVIOPCILINKWIDTH_x8: _NVVIOPCILINKWIDTH = 8;
pub const _NVVIOPCILINKWIDTH_NVVIOPCILINKWIDTH_x16: _NVVIOPCILINKWIDTH = 16;
pub type _NVVIOPCILINKWIDTH = ::std::os::raw::c_int;
pub use self::_NVVIOPCILINKWIDTH as NVVIOPCILINKWIDTH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOPCIINFO {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< specifies the internal PCI device identifier for the GVI."]
    pub pciDeviceId: NvU32,
    #[doc = "!< specifies the internal PCI subsystem identifier for the GVI."]
    pub pciSubSystemId: NvU32,
    #[doc = "!< specifies the internal PCI device-specific revision identifier for the GVI."]
    pub pciRevisionId: NvU32,
    #[doc = "!< specifies the PCI domain of the GVI device."]
    pub pciDomain: NvU32,
    #[doc = "!< specifies the PCI bus number of the GVI device."]
    pub pciBus: NvU32,
    #[doc = "!< specifies the PCI slot number of the GVI device."]
    pub pciSlot: NvU32,
    #[doc = "!< specifies the the negotiated PCIE link width."]
    pub pciLinkWidth: NVVIOPCILINKWIDTH,
    #[doc = "!< specifies the the negotiated PCIE link rate."]
    pub pciLinkRate: NVVIOPCILINKRATE,
}
#[test]
fn bindgen_test_layout__NVVIOPCIINFO() {
    assert_eq!(
        ::std::mem::size_of::<_NVVIOPCIINFO>(),
        36usize,
        concat!("Size of: ", stringify!(_NVVIOPCIINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOPCIINFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOPCIINFO))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOPCIINFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOPCIINFO),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_pciDeviceId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOPCIINFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pciDeviceId) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOPCIINFO),
                "::",
                stringify!(pciDeviceId)
            )
        );
    }
    test_field_pciDeviceId();
    fn test_field_pciSubSystemId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOPCIINFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pciSubSystemId) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOPCIINFO),
                "::",
                stringify!(pciSubSystemId)
            )
        );
    }
    test_field_pciSubSystemId();
    fn test_field_pciRevisionId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOPCIINFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pciRevisionId) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOPCIINFO),
                "::",
                stringify!(pciRevisionId)
            )
        );
    }
    test_field_pciRevisionId();
    fn test_field_pciDomain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOPCIINFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pciDomain) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOPCIINFO),
                "::",
                stringify!(pciDomain)
            )
        );
    }
    test_field_pciDomain();
    fn test_field_pciBus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOPCIINFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pciBus) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOPCIINFO),
                "::",
                stringify!(pciBus)
            )
        );
    }
    test_field_pciBus();
    fn test_field_pciSlot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOPCIINFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pciSlot) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOPCIINFO),
                "::",
                stringify!(pciSlot)
            )
        );
    }
    test_field_pciSlot();
    fn test_field_pciLinkWidth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOPCIINFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pciLinkWidth) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOPCIINFO),
                "::",
                stringify!(pciLinkWidth)
            )
        );
    }
    test_field_pciLinkWidth();
    fn test_field_pciLinkRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVVIOPCIINFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pciLinkRate) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVVIOPCIINFO),
                "::",
                stringify!(pciLinkRate)
            )
        );
    }
    test_field_pciLinkRate();
}
impl Default for _NVVIOPCIINFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NVVIOPCIINFO_V1 = _NVVIOPCIINFO;
pub type NVVIOPCIINFO = NVVIOPCIINFO_V1;
extern "C" {
    #[doc = ""]
    pub fn NvAPI_VIO_GetPCIInfo(
        hVioHandle: NvVioHandle,
        pVioPCIInfo: *mut NVVIOPCIINFO,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    #[doc = "!   Function:    NvAPI_VIO_IsRunning"]
    #[doc = "!"]
    #[doc = "!   Description: This API determines if Video I/O is running."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 440."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 190"]
    #[doc = "!"]
    #[doc = "! \\param [in]  NvVioHandle[IN]          The caller provides the SDI device handle as input."]
    #[doc = "!"]
    #[doc = "! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported"]
    #[doc = "!"]
    #[doc = ""]
    pub fn NvAPI_VIO_IsRunning(hVioHandle: NvVioHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    #[doc = "!   Function:    NvAPI_VIO_Start"]
    #[doc = "!"]
    #[doc = "!   Description: This API starts Video I/O."]
    #[doc = "!              This API should be called for NVVIOOWNERTYPE_DESKTOP only and will not work for OGL applications."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 440."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 190"]
    #[doc = "!"]
    #[doc = "! \\param [in]  NvVioHandle[IN]     The caller provides the SDI device handle as input."]
    #[doc = "!"]
    #[doc = "! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported"]
    #[doc = "!"]
    #[doc = ""]
    pub fn NvAPI_VIO_Start(hVioHandle: NvVioHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    #[doc = "!   Function:    NvAPI_VIO_Stop"]
    #[doc = "!"]
    #[doc = "!   Description: This API stops Video I/O."]
    #[doc = "!              This API should be called for NVVIOOWNERTYPE_DESKTOP only and will not work for OGL applications."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 440."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 190"]
    #[doc = "!"]
    #[doc = "! \\param [in]  NvVioHandle[IN]     The caller provides the SDI device handle as input."]
    #[doc = "!"]
    #[doc = "! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported"]
    #[doc = "!"]
    #[doc = ""]
    pub fn NvAPI_VIO_Stop(hVioHandle: NvVioHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    #[doc = "!   Function:    NvAPI_VIO_IsFrameLockModeCompatible"]
    #[doc = "!"]
    #[doc = "!   Description: This API checks whether modes are compatible in frame lock mode."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 440."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 190"]
    #[doc = "!"]
    #[doc = "! \\param [in]   NvVioHandle          The caller provides the SDI device handle as input."]
    #[doc = "! \\param [in]   srcEnumIndex         Source Enumeration index"]
    #[doc = "! \\param [in]   destEnumIndex        Destination Enumeration index"]
    #[doc = "! \\param [out]  pbCompatible         Pointer to receive compatibility"]
    #[doc = "!"]
    #[doc = "! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported"]
    #[doc = "!"]
    #[doc = ""]
    pub fn NvAPI_VIO_IsFrameLockModeCompatible(
        hVioHandle: NvVioHandle,
        srcEnumIndex: NvU32,
        destEnumIndex: NvU32,
        pbCompatible: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    #[doc = "!   Function:    NvAPI_VIO_EnumDevices"]
    #[doc = "!"]
    #[doc = "!   Description: This API enumerate all VIO devices connected to the system."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 440."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 190"]
    #[doc = "!"]
    #[doc = "! \\param [out]  NvVioHandle                  User passes the pointer of NvVioHandle[] array to get handles to"]
    #[doc = "!                                            all the connected video I/O devices."]
    #[doc = "! \\param [out]  vioDeviceCount               User gets total number of VIO devices connected to the system."]
    #[doc = "!"]
    #[doc = "! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported"]
    #[doc = "!"]
    #[doc = ""]
    pub fn NvAPI_VIO_EnumDevices(
        hVioHandle: *mut NvVioHandle,
        vioDeviceCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    #[doc = "!   Function:    NvAPI_VIO_QueryTopology"]
    #[doc = "!"]
    #[doc = "!   Description: This API queries the valid SDI topologies."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 440."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 190"]
    #[doc = "!"]
    #[doc = "! \\param [out] pNvVIOTopology     User passes the pointer to NVVIOTOPOLOGY to fetch all valid SDI topologies."]
    #[doc = "!"]
    #[doc = "! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported"]
    #[doc = "!"]
    #[doc = ""]
    pub fn NvAPI_VIO_QueryTopology(pNvVIOTopology: *mut NV_VIO_TOPOLOGY) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    #[doc = "!   Function:    NvAPI_VIO_EnumSignalFormats"]
    #[doc = "!"]
    #[doc = "!   Description: This API enumerates signal formats supported by Video I/O."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 440."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 190"]
    #[doc = "!"]
    #[doc = "! \\param [in]   NvVioHandle          The caller provides the SDI device handle as input."]
    #[doc = "! \\param [in]   enumIndex            Enumeration index"]
    #[doc = "! \\param [out]  pSignalFormatDetail  Pointer to receive detail or NULL"]
    #[doc = "!"]
    #[doc = "! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported"]
    #[doc = "!"]
    #[doc = ""]
    pub fn NvAPI_VIO_EnumSignalFormats(
        hVioHandle: NvVioHandle,
        enumIndex: NvU32,
        pSignalFormatDetail: *mut NVVIOSIGNALFORMATDETAIL,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    #[doc = "!   Function:    NvAPI_VIO_EnumDataFormats"]
    #[doc = "!"]
    #[doc = "!   Description: This API enumerates data formats supported by Video I/O."]
    #[doc = "!"]
    #[doc = "! \\deprecated  Do not use this function - it is deprecated in release 440."]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 190"]
    #[doc = "!"]
    #[doc = "! \\param [in]  NvVioHandle         The caller provides the SDI device handle as input."]
    #[doc = "! \\param [in]  enumIndex           Enumeration index"]
    #[doc = "! \\param [out] pDataFormatDetail   Pointer to receive detail or NULL"]
    #[doc = "!"]
    #[doc = "! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported"]
    #[doc = "!"]
    #[doc = ""]
    pub fn NvAPI_VIO_EnumDataFormats(
        hVioHandle: NvVioHandle,
        enumIndex: NvU32,
        pDataFormatDetail: *mut NVVIODATAFORMATDETAIL,
    ) -> NvAPI_Status;
}
#[doc = "!< Default registry configuration profile."]
pub const _NV_StereoRegistryProfileType_NVAPI_STEREO_DEFAULT_REGISTRY_PROFILE:
    _NV_StereoRegistryProfileType = 0;
#[doc = "!< Separate registry configuration profile for a DirectX 9 executable."]
pub const _NV_StereoRegistryProfileType_NVAPI_STEREO_DX9_REGISTRY_PROFILE:
    _NV_StereoRegistryProfileType = 1;
#[doc = "!< Separate registry configuration profile for a DirectX 10 executable."]
pub const _NV_StereoRegistryProfileType_NVAPI_STEREO_DX10_REGISTRY_PROFILE:
    _NV_StereoRegistryProfileType = 2;
#[doc = "! \\ingroup stereoapi"]
#[doc = "! Used in NvAPI_Stereo_CreateConfigurationProfileRegistryKey()"]
pub type _NV_StereoRegistryProfileType = ::std::os::raw::c_int;
#[doc = "! \\ingroup stereoapi"]
#[doc = "! Used in NvAPI_Stereo_CreateConfigurationProfileRegistryKey()"]
pub use self::_NV_StereoRegistryProfileType as NV_STEREO_REGISTRY_PROFILE_TYPE;
extern "C" {
    #[doc = "! \\ingroup stereoapi"]
    pub fn NvAPI_Stereo_CreateConfigurationProfileRegistryKey(
        registryProfileType: NV_STEREO_REGISTRY_PROFILE_TYPE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   Removes configuration registry key for current application."]
    #[doc = "!"]
    #[doc = "!                If an application already has a configuration profile prior to this function call,"]
    #[doc = "!                the function attempts to remove the application's configuration profile registry key from the registry."]
    #[doc = "!                If there is no configuration profile registry key prior to the function call,"]
    #[doc = "!                the function does nothing and does not report an error."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "! \\param [in]   registryProfileType   Type of profile that the application wants to delete. This should be one of the symbolic"]
    #[doc = "!                                     constants defined in ::NV_STEREO_REGISTRY_PROFILE_TYPE. Any other value will cause the function"]
    #[doc = "!                                     to do nothing and return ::NV_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                                           Key does not exist in the registry any more."]
    #[doc = "! \\retval ::NVAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED   This profile type is not supported."]
    #[doc = "! \\retval ::NVAPI_STEREO_REGISTRY_ACCESS_FAILED                Access to registry failed."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED                           NVAPI is not initialized."]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED                       Stereo part of NVAPI is not initialized."]
    #[doc = "! \\retval ::NVAPI_ERROR"]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_DeleteConfigurationProfileRegistryKey(
        registryProfileType: NV_STEREO_REGISTRY_PROFILE_TYPE,
    ) -> NvAPI_Status;
}
#[doc = "!< Symbolic constant for convergence registry ID."]
pub const _NV_StereoRegistryID_NVAPI_CONVERGENCE_ID: _NV_StereoRegistryID = 0;
#[doc = "!< Symbolic constant for frustum adjust mode registry ID."]
pub const _NV_StereoRegistryID_NVAPI_FRUSTUM_ADJUST_MODE_ID: _NV_StereoRegistryID = 1;
#[doc = "! \\ingroup stereoapi"]
#[doc = "! Used in NvAPI_Stereo_SetConfigurationProfileValue()"]
pub type _NV_StereoRegistryID = ::std::os::raw::c_int;
#[doc = "! \\ingroup stereoapi"]
#[doc = "! Used in NvAPI_Stereo_SetConfigurationProfileValue()"]
pub use self::_NV_StereoRegistryID as NV_STEREO_REGISTRY_ID;
extern "C" {
    #[doc = "! \\ingroup stereoapi"]
    pub fn NvAPI_Stereo_SetConfigurationProfileValue(
        registryProfileType: NV_STEREO_REGISTRY_PROFILE_TYPE,
        valueRegistryID: NV_STEREO_REGISTRY_ID,
        pValue: *mut ::std::os::raw::c_void,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API removes the given value from the application's configuration profile registry key."]
    #[doc = "!                If there is no such value, the function does nothing and does not report an error."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "! \\param [in]     registryProfileType   The type of profile the application wants to access. It should be one of the"]
    #[doc = "!                                       symbolic constants defined in ::NV_STEREO_REGISTRY_PROFILE_TYPE. Any other value will"]
    #[doc = "!                                       cause function to do nothing and return ::NV_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED."]
    #[doc = "! \\param [in]     valueRegistryID       ID of the value that is being deleted. It should be one of the symbolic constants defined in"]
    #[doc = "!                                       ::NV_STEREO_REGISTRY_PROFILE_TYPE. Any other value will cause function to do nothing and return"]
    #[doc = "!                                       ::NVAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                                           Value does not exist in registry any more."]
    #[doc = "! \\retval ::NVAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED   This profile type is not supported."]
    #[doc = "! \\retval ::NVAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED          This value is not supported."]
    #[doc = "! \\retval ::NVAPI_STEREO_REGISTRY_ACCESS_FAILED                Access to registry failed."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED"]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED                       Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_ERROR"]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_DeleteConfigurationProfileValue(
        registryProfileType: NV_STEREO_REGISTRY_PROFILE_TYPE,
        valueRegistryID: NV_STEREO_REGISTRY_ID,
    ) -> NvAPI_Status;
}
#[doc = "! \\addtogroup stereoapi"]
#[doc = "! @{"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NVAPI_STEREO_CAPS {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved2: [NvU32; 3usize],
}
#[test]
fn bindgen_test_layout__NVAPI_STEREO_CAPS() {
    assert_eq!(
        ::std::mem::size_of::<_NVAPI_STEREO_CAPS>(),
        20usize,
        concat!("Size of: ", stringify!(_NVAPI_STEREO_CAPS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVAPI_STEREO_CAPS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVAPI_STEREO_CAPS))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVAPI_STEREO_CAPS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVAPI_STEREO_CAPS),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVAPI_STEREO_CAPS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVAPI_STEREO_CAPS),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
}
impl _NVAPI_STEREO_CAPS {
    #[inline]
    pub fn supportsWindowedModeOff(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supportsWindowedModeOff(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supportsWindowedModeAutomatic(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supportsWindowedModeAutomatic(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supportsWindowedModePersistent(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supportsWindowedModePersistent(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        supportsWindowedModeOff: NvU32,
        supportsWindowedModeAutomatic: NvU32,
        supportsWindowedModePersistent: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let supportsWindowedModeOff: u32 =
                unsafe { ::std::mem::transmute(supportsWindowedModeOff) };
            supportsWindowedModeOff as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let supportsWindowedModeAutomatic: u32 =
                unsafe { ::std::mem::transmute(supportsWindowedModeAutomatic) };
            supportsWindowedModeAutomatic as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let supportsWindowedModePersistent: u32 =
                unsafe { ::std::mem::transmute(supportsWindowedModePersistent) };
            supportsWindowedModePersistent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! \\addtogroup stereoapi"]
#[doc = "! @{"]
pub type NVAPI_STEREO_CAPS_V1 = _NVAPI_STEREO_CAPS;
#[doc = "! \\addtogroup stereoapi"]
#[doc = "! @{"]
pub type NVAPI_STEREO_CAPS = NVAPI_STEREO_CAPS_V1;
extern "C" {
    #[doc = "! DESCRIPTION:  This API checks what kind of stereo support is currently supported on a particular display."]
    #[doc = "!               If the the display is prohibited from showing stereo (e.g. secondary in a multi-mon setup), we will"]
    #[doc = "!               return 0 for all stereo modes (full screen exclusive, automatic windowed, persistent windowed)."]
    #[doc = "!               Otherwise, we will check which stereo mode is supported. On 120Hz display, this will be what"]
    #[doc = "!               the user chooses in control panel. On HDMI 1.4 display, persistent windowed mode is always assumed to be"]
    #[doc = "!               supported. Note that this function does not check if the CURRENT RESOLUTION/REFRESH RATE can support"]
    #[doc = "!               stereo. For HDMI 1.4, it is the app's responsibility to change the resolution/refresh rate to one that is"]
    #[doc = "!               3D compatible. For 120Hz, the driver will ALWAYS force 120Hz anyway."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 304"]
    #[doc = "!"]
    #[doc = "! \\param [in]     hMonitor handle to monitor that app is going to run on"]
    #[doc = "! \\param [out]    pCaps    Address where the result of the inquiry will be placed."]
    #[doc = "!                          *pCaps is defined in NVAPI_STEREO_CAPS."]
    #[doc = "! \\return       This API can return any of the following error codes enumerated in #NvAPI_Status"]
    #[doc = "! \\retval ::NVAPI_OK"]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_GetStereoSupport(
        hMonitor: NvMonitorHandle,
        pCaps: *mut NVAPI_STEREO_CAPS,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API decreases separation for the given device interface (just like the Ctrl+F3 hotkey)."]
    #[doc = "!"]
    #[doc = "! WHEN TO USE:   After the stereo handle for device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "! \\param [in]   stereoHandle  Stereo handle that corresponds to the device interface."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK - Decrease of separation percentage was successfull."]
    #[doc = "! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_ERROR - Something is wrong (generic error)."]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_DecreaseSeparation(stereoHandle: StereoHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API increases separation for the given device interface (just like the Ctrl+F4 hotkey)."]
    #[doc = "!"]
    #[doc = "! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "! \\param [in]    stereoHandle  Stereo handle that corresponds to the device interface."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                               Increase of separation percentage was successfull."]
    #[doc = "! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED               NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_ERROR                            Something is wrong (generic error)."]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_IncreaseSeparation(stereoHandle: StereoHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API decreases convergence for the given device interface (just like the Ctrl+F5 hotkey)."]
    #[doc = "!"]
    #[doc = "! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "! \\param [in]     stereoHandle  Stereo handle that corresponds to the device interface."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK - Decrease of convergence was successfull."]
    #[doc = "! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_ERROR - Something is wrong (generic error)."]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_DecreaseConvergence(stereoHandle: StereoHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API increases convergence for given the device interface (just like the Ctrl+F5 hotkey)."]
    #[doc = "!"]
    #[doc = "! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "! \\param [in]    stereoHandle  Stereo handle that corresponds to the device interface."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                               Increase of convergence was successfull."]
    #[doc = "! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED"]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_ERROR"]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_IncreaseConvergence(stereoHandle: StereoHandle) -> NvAPI_Status;
}
#[doc = "!< Do not adjust frustum."]
pub const _NV_FrustumAdjustMode_NVAPI_NO_FRUSTUM_ADJUST: _NV_FrustumAdjustMode = 0;
#[doc = "!< Stretch images in X."]
pub const _NV_FrustumAdjustMode_NVAPI_FRUSTUM_STRETCH: _NV_FrustumAdjustMode = 1;
#[doc = "!< Clear corresponding edges for each eye."]
pub const _NV_FrustumAdjustMode_NVAPI_FRUSTUM_CLEAR_EDGES: _NV_FrustumAdjustMode = 2;
#[doc = "! \\ingroup stereoapi"]
#[doc = "! Used in NvAPI_Stereo_GetFrustumAdjustMode()."]
pub type _NV_FrustumAdjustMode = ::std::os::raw::c_int;
#[doc = "! \\ingroup stereoapi"]
#[doc = "! Used in NvAPI_Stereo_GetFrustumAdjustMode()."]
pub use self::_NV_FrustumAdjustMode as NV_FRUSTUM_ADJUST_MODE;
extern "C" {
    #[doc = "! \\ingroup stereoapi"]
    pub fn NvAPI_Stereo_GetFrustumAdjustMode(
        stereoHandle: StereoHandle,
        pFrustumAdjustMode: *mut NV_FRUSTUM_ADJUST_MODE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API sets the current frustum adjust mode value."]
    #[doc = "!"]
    #[doc = "! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "! \\param [in]     stereoHandle                Stereo handle that corresponds to the device interface."]
    #[doc = "! \\param [in]     newFrustumAdjustModeValue   New value for frustum adjust mode. It should be one of the symbolic constants defined in"]
    #[doc = "!                                             ::NV_FRUSTUM_ADJUST_MODE. Any other value will cause function to do nothing and return"]
    #[doc = "!                                             ::NVAPI_STEREO_FRUSTUM_ADJUST_MODE_NOT_SUPPORTED."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                                         Retrieval of frustum adjust mode was successfull."]
    #[doc = "! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE            Device interface is not valid. Create again, then attach again."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED"]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED                     Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_STEREO_FRUSTUM_ADJUST_MODE_NOT_SUPPORTED   Given frustum adjust mode is not supported."]
    #[doc = "! \\retval ::NVAPI_ERROR"]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_SetFrustumAdjustMode(
        stereoHandle: StereoHandle,
        newFrustumAdjustModeValue: NV_FRUSTUM_ADJUST_MODE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API captures the current stereo image in JPEG stereo format with the given quality."]
    #[doc = "!                Only the last capture call per flip will be effective."]
    #[doc = "!"]
    #[doc = "! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "! \\param [in]     stereoHandle  Stereo handle that corresponds to the device interface."]
    #[doc = "! \\param [in]     quality        Quality of the JPEG image to be captured. Integer value betweeen 0 and 100."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                              Image captured."]
    #[doc = "! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE Device interface is not valid. Create again, then attach again."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED"]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED"]
    #[doc = "! \\retval ::NVAPI_STEREO_PARAMETER_OUT_OF_RANGE   Given quality is out of [0..100] range."]
    #[doc = "! \\retval ::NVAPI_ERROR"]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_CaptureJpegImage(
        stereoHandle: StereoHandle,
        quality: NvU32,
    ) -> NvAPI_Status;
}
pub const _NVAPI_STEREO_INIT_ACTIVATION_FLAGS_NVAPI_STEREO_INIT_ACTIVATION_IMMEDIATE:
    _NVAPI_STEREO_INIT_ACTIVATION_FLAGS = 0;
pub const _NVAPI_STEREO_INIT_ACTIVATION_FLAGS_NVAPI_STEREO_INIT_ACTIVATION_DELAYED:
    _NVAPI_STEREO_INIT_ACTIVATION_FLAGS = 1;
#[doc = "! InitActivation Flags"]
pub type _NVAPI_STEREO_INIT_ACTIVATION_FLAGS = ::std::os::raw::c_int;
#[doc = "! InitActivation Flags"]
pub use self::_NVAPI_STEREO_INIT_ACTIVATION_FLAGS as NVAPI_STEREO_INIT_ACTIVATION_FLAGS;
extern "C" {
    pub fn NvAPI_Stereo_InitActivation(
        hStereoHandle: StereoHandle,
        flags: NVAPI_STEREO_INIT_ACTIVATION_FLAGS,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API allows an application to trigger creation of a stereo desktop,"]
    #[doc = "!\t\t\t\t   in case the creation was stopped on application launch."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "! \\since Release: 302"]
    #[doc = "!"]
    #[doc = "! \\param [in]   stereoHandle   Stereo handle that corresponds to the device interface."]
    #[doc = "!"]
    #[doc = "! \\return This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!         If there are return error codes with specific meaning for this API,"]
    #[doc = "!         they are listed below."]
    #[doc = "! \\retval ::NVAPI_STEREO_INIT_ACTIVATION_NOT_DONE - Stereo InitActivation not called."]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized."]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_Trigger_Activation(hStereoHandle: StereoHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API captures the current stereo image in PNG stereo format."]
    #[doc = "!                Only the last capture call per flip will be effective."]
    #[doc = "!"]
    #[doc = "! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "! \\param [in]     stereoHandle  Stereo handle corresponding to the device interface."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                               Image captured."]
    #[doc = "! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED"]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_ERROR"]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_CapturePngImage(stereoHandle: StereoHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API turns on/off reverse stereo blit."]
    #[doc = "!"]
    #[doc = "! HOW TO USE:    Use after the stereo handle for the device interface is created via successfull call to the appropriate"]
    #[doc = "!                NvAPI_Stereo_CreateHandleFrom() function."]
    #[doc = "!                After reversed stereo blit control is turned on, blits from the stereo surface will"]
    #[doc = "!                produce the right-eye image in the left side of the destination surface and the left-eye"]
    #[doc = "!                image in the right side of the destination surface."]
    #[doc = "!"]
    #[doc = "!                In DirectX 9, the destination surface must be created as the render target, and StretchRect must be used."]
    #[doc = "!                Conditions:"]
    #[doc = "!                - DstWidth == 2*SrcWidth"]
    #[doc = "!                - DstHeight == SrcHeight"]
    #[doc = "!                - Src surface is the stereo surface."]
    #[doc = "!                - SrcRect must be {0,0,SrcWidth,SrcHeight}"]
    #[doc = "!                - DstRect must be {0,0,DstWidth,DstHeight}"]
    #[doc = "!"]
    #[doc = "!                In DirectX 10, ResourceCopyRegion must be used."]
    #[doc = "!                Conditions:"]
    #[doc = "!                - DstWidth == 2*SrcWidth"]
    #[doc = "!                - DstHeight == SrcHeight"]
    #[doc = "!                - dstX == 0,"]
    #[doc = "!                - dstY == 0,"]
    #[doc = "!                - dstZ == 0,"]
    #[doc = "!                - SrcBox: left=top=front==0; right==SrcWidth; bottom==SrcHeight; back==1;"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 185"]
    #[doc = "!"]
    #[doc = "! \\param [in]    stereoHandle  Stereo handle corresponding to the device interface."]
    #[doc = "! \\param [in]    TurnOn         != 0 : Turns on \\n"]
    #[doc = "!                               == 0 : Turns off"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                                Retrieval of frustum adjust mode was successfull."]
    #[doc = "! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED"]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED            Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_ERROR"]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_ReverseStereoBlitControl(
        hStereoHandle: StereoHandle,
        TurnOn: NvU8,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API is a Setup notification message that the stereo driver uses to notify the application"]
    #[doc = "!                when the user changes the stereo driver state."]
    #[doc = "!"]
    #[doc = "!                When the user changes the stereo state (Activated or Deactivated, separation or conversion)"]
    #[doc = "!                the stereo driver posts a defined message with the following parameters:"]
    #[doc = "!"]
    #[doc = "!                lParam  is the current conversion. (Actual conversion is *(float*)&lParam )"]
    #[doc = "!"]
    #[doc = "!                wParam == MAKEWPARAM(l, h) where"]
    #[doc = "!                - l == 0 if stereo is deactivated"]
    #[doc = "!                - l == 1 if stereo is deactivated"]
    #[doc = "!                - h is the current separation. (Actual separation is float(h*100.f/0xFFFF)"]
    #[doc = "!"]
    #[doc = "!                Call this API with NULL hWnd to prohibit notification."]
    #[doc = "!"]
    #[doc = "! WHEN TO USE:   Use after the stereo handle for device interface is created via successful call to appropriate"]
    #[doc = "!                NvAPI_Stereo_CreateHandleFrom() function."]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 180"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]     stereoHandle  Stereo handle corresponding to the device interface."]
    #[doc = "! \\param [in]     hWnd          Window HWND that will be notified when the user changes the stereo driver state."]
    #[doc = "!                               Actual HWND must be cast to an NvU64."]
    #[doc = "! \\param [in]     messageID     MessageID of the message that will be posted to hWnd"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                                Notification set."]
    #[doc = "! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again."]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED"]
    #[doc = "! \\retval ::NVAPI_STEREO_NOT_INITIALIZED            Stereo part of NVAPI not initialized."]
    #[doc = "! \\retval ::NVAPI_ERROR"]
    #[doc = "!"]
    #[doc = "! \\ingroup stereoapi"]
    #[doc = ""]
    pub fn NvAPI_Stereo_SetNotificationMessage(
        hStereoHandle: StereoHandle,
        hWnd: NvU64,
        messageID: NvU64,
    ) -> NvAPI_Status;
}
pub const _NV_StereoSwapChainMode_NVAPI_STEREO_SWAPCHAIN_DEFAULT: _NV_StereoSwapChainMode = 0;
pub const _NV_StereoSwapChainMode_NVAPI_STEREO_SWAPCHAIN_STEREO: _NV_StereoSwapChainMode = 1;
pub const _NV_StereoSwapChainMode_NVAPI_STEREO_SWAPCHAIN_MONO: _NV_StereoSwapChainMode = 2;
#[doc = "! \\ingroup stereoapi"]
pub type _NV_StereoSwapChainMode = ::std::os::raw::c_int;
#[doc = "! \\ingroup stereoapi"]
pub use self::_NV_StereoSwapChainMode as NV_STEREO_SWAPCHAIN_MODE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NvDRSSessionHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvDRSSessionHandle__() {
    assert_eq!(
        ::std::mem::size_of::<NvDRSSessionHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvDRSSessionHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDRSSessionHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvDRSSessionHandle__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDRSSessionHandle__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDRSSessionHandle__),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type NvDRSSessionHandle = *mut NvDRSSessionHandle__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NvDRSProfileHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvDRSProfileHandle__() {
    assert_eq!(
        ::std::mem::size_of::<NvDRSProfileHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvDRSProfileHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDRSProfileHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvDRSProfileHandle__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDRSProfileHandle__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDRSProfileHandle__),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type NvDRSProfileHandle = *mut NvDRSProfileHandle__;
pub const _NVDRS_SETTING_TYPE_NVDRS_DWORD_TYPE: _NVDRS_SETTING_TYPE = 0;
pub const _NVDRS_SETTING_TYPE_NVDRS_BINARY_TYPE: _NVDRS_SETTING_TYPE = 1;
pub const _NVDRS_SETTING_TYPE_NVDRS_STRING_TYPE: _NVDRS_SETTING_TYPE = 2;
pub const _NVDRS_SETTING_TYPE_NVDRS_WSTRING_TYPE: _NVDRS_SETTING_TYPE = 3;
pub type _NVDRS_SETTING_TYPE = ::std::os::raw::c_int;
pub use self::_NVDRS_SETTING_TYPE as NVDRS_SETTING_TYPE;
pub const _NVDRS_SETTING_LOCATION_NVDRS_CURRENT_PROFILE_LOCATION: _NVDRS_SETTING_LOCATION = 0;
pub const _NVDRS_SETTING_LOCATION_NVDRS_GLOBAL_PROFILE_LOCATION: _NVDRS_SETTING_LOCATION = 1;
pub const _NVDRS_SETTING_LOCATION_NVDRS_BASE_PROFILE_LOCATION: _NVDRS_SETTING_LOCATION = 2;
pub const _NVDRS_SETTING_LOCATION_NVDRS_DEFAULT_PROFILE_LOCATION: _NVDRS_SETTING_LOCATION = 3;
pub type _NVDRS_SETTING_LOCATION = ::std::os::raw::c_int;
pub use self::_NVDRS_SETTING_LOCATION as NVDRS_SETTING_LOCATION;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NVDRS_GPU_SUPPORT {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NVDRS_GPU_SUPPORT() {
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_GPU_SUPPORT>(),
        4usize,
        concat!("Size of: ", stringify!(_NVDRS_GPU_SUPPORT))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_GPU_SUPPORT>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_GPU_SUPPORT))
    );
}
impl _NVDRS_GPU_SUPPORT {
    #[inline]
    pub fn geforce(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_geforce(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn quadro(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_quadro(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nvs(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nvs(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved5(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved5(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved7(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved7(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved10(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved10(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved11(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved11(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved13(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved13(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved14(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved14(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved15(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved15(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved18(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved18(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved19(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved19(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved21(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved21(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved22(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved22(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved23(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved23(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved25(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved25(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved27(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved27(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved29(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved29(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved30(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved30(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved31(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved31(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved32(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved32(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        geforce: NvU32,
        quadro: NvU32,
        nvs: NvU32,
        reserved4: NvU32,
        reserved5: NvU32,
        reserved6: NvU32,
        reserved7: NvU32,
        reserved8: NvU32,
        reserved9: NvU32,
        reserved10: NvU32,
        reserved11: NvU32,
        reserved12: NvU32,
        reserved13: NvU32,
        reserved14: NvU32,
        reserved15: NvU32,
        reserved16: NvU32,
        reserved17: NvU32,
        reserved18: NvU32,
        reserved19: NvU32,
        reserved20: NvU32,
        reserved21: NvU32,
        reserved22: NvU32,
        reserved23: NvU32,
        reserved24: NvU32,
        reserved25: NvU32,
        reserved26: NvU32,
        reserved27: NvU32,
        reserved28: NvU32,
        reserved29: NvU32,
        reserved30: NvU32,
        reserved31: NvU32,
        reserved32: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let geforce: u32 = unsafe { ::std::mem::transmute(geforce) };
            geforce as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let quadro: u32 = unsafe { ::std::mem::transmute(quadro) };
            quadro as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let nvs: u32 = unsafe { ::std::mem::transmute(nvs) };
            nvs as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let reserved4: u32 = unsafe { ::std::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let reserved5: u32 = unsafe { ::std::mem::transmute(reserved5) };
            reserved5 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let reserved6: u32 = unsafe { ::std::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let reserved7: u32 = unsafe { ::std::mem::transmute(reserved7) };
            reserved7 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let reserved9: u32 = unsafe { ::std::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let reserved10: u32 = unsafe { ::std::mem::transmute(reserved10) };
            reserved10 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let reserved11: u32 = unsafe { ::std::mem::transmute(reserved11) };
            reserved11 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let reserved12: u32 = unsafe { ::std::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let reserved13: u32 = unsafe { ::std::mem::transmute(reserved13) };
            reserved13 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let reserved14: u32 = unsafe { ::std::mem::transmute(reserved14) };
            reserved14 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let reserved15: u32 = unsafe { ::std::mem::transmute(reserved15) };
            reserved15 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let reserved16: u32 = unsafe { ::std::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let reserved17: u32 = unsafe { ::std::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let reserved18: u32 = unsafe { ::std::mem::transmute(reserved18) };
            reserved18 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let reserved19: u32 = unsafe { ::std::mem::transmute(reserved19) };
            reserved19 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let reserved20: u32 = unsafe { ::std::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let reserved21: u32 = unsafe { ::std::mem::transmute(reserved21) };
            reserved21 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let reserved22: u32 = unsafe { ::std::mem::transmute(reserved22) };
            reserved22 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let reserved23: u32 = unsafe { ::std::mem::transmute(reserved23) };
            reserved23 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let reserved24: u32 = unsafe { ::std::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let reserved25: u32 = unsafe { ::std::mem::transmute(reserved25) };
            reserved25 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let reserved26: u32 = unsafe { ::std::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let reserved27: u32 = unsafe { ::std::mem::transmute(reserved27) };
            reserved27 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let reserved28: u32 = unsafe { ::std::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let reserved29: u32 = unsafe { ::std::mem::transmute(reserved29) };
            reserved29 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let reserved30: u32 = unsafe { ::std::mem::transmute(reserved30) };
            reserved30 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let reserved31: u32 = unsafe { ::std::mem::transmute(reserved31) };
            reserved31 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let reserved32: u32 = unsafe { ::std::mem::transmute(reserved32) };
            reserved32 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NVDRS_GPU_SUPPORT = _NVDRS_GPU_SUPPORT;
#[doc = "! Enum to decide on the datatype of setting value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVDRS_BINARY_SETTING {
    #[doc = "!< valueLength should always be in number of bytes."]
    pub valueLength: NvU32,
    pub valueData: [NvU8; 4096usize],
}
#[test]
fn bindgen_test_layout__NVDRS_BINARY_SETTING() {
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_BINARY_SETTING>(),
        4100usize,
        concat!("Size of: ", stringify!(_NVDRS_BINARY_SETTING))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_BINARY_SETTING>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_BINARY_SETTING))
    );
    fn test_field_valueLength() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_BINARY_SETTING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).valueLength) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_BINARY_SETTING),
                "::",
                stringify!(valueLength)
            )
        );
    }
    test_field_valueLength();
    fn test_field_valueData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_BINARY_SETTING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).valueData) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_BINARY_SETTING),
                "::",
                stringify!(valueData)
            )
        );
    }
    test_field_valueData();
}
impl Default for _NVDRS_BINARY_SETTING {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! Enum to decide on the datatype of setting value."]
pub type NVDRS_BINARY_SETTING = _NVDRS_BINARY_SETTING;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVDRS_SETTING_VALUES {
    #[doc = "!< Structure Version"]
    pub version: NvU32,
    #[doc = "!< Total number of values available in a setting."]
    pub numSettingValues: NvU32,
    #[doc = "!< Type of setting value."]
    pub settingType: NVDRS_SETTING_TYPE,
    pub __bindgen_anon_1: _NVDRS_SETTING_VALUES__bindgen_ty_1,
    pub settingValues: [_NVDRS_SETTING_VALUES__bindgen_ty_2; 100usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVDRS_SETTING_VALUES__bindgen_ty_1 {
    #[doc = "!< Accessing default DWORD value of this setting."]
    pub u32DefaultValue: NvU32,
    #[doc = "!< Accessing default Binary value of this setting."]
    #[doc = "!< Must be allocated by caller with valueLength specifying buffer size, or only valueLength will be filled in."]
    pub binaryDefaultValue: NVDRS_BINARY_SETTING,
    #[doc = "!< Accessing default unicode string value of this setting."]
    pub wszDefaultValue: NvAPI_UnicodeString,
}
#[test]
fn bindgen_test_layout__NVDRS_SETTING_VALUES__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_SETTING_VALUES__bindgen_ty_1>(),
        4100usize,
        concat!("Size of: ", stringify!(_NVDRS_SETTING_VALUES__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_SETTING_VALUES__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NVDRS_SETTING_VALUES__bindgen_ty_1)
        )
    );
    fn test_field_u32DefaultValue() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NVDRS_SETTING_VALUES__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u32DefaultValue) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_VALUES__bindgen_ty_1),
                "::",
                stringify!(u32DefaultValue)
            )
        );
    }
    test_field_u32DefaultValue();
    fn test_field_binaryDefaultValue() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NVDRS_SETTING_VALUES__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).binaryDefaultValue) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_VALUES__bindgen_ty_1),
                "::",
                stringify!(binaryDefaultValue)
            )
        );
    }
    test_field_binaryDefaultValue();
    fn test_field_wszDefaultValue() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NVDRS_SETTING_VALUES__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wszDefaultValue) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_VALUES__bindgen_ty_1),
                "::",
                stringify!(wszDefaultValue)
            )
        );
    }
    test_field_wszDefaultValue();
}
impl Default for _NVDRS_SETTING_VALUES__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVDRS_SETTING_VALUES__bindgen_ty_2 {
    #[doc = "!< All possible DWORD values for a setting"]
    pub u32Value: NvU32,
    #[doc = "!< All possible Binary values for a setting"]
    pub binaryValue: NVDRS_BINARY_SETTING,
    #[doc = "!< Accessing current unicode string value of this setting."]
    pub wszValue: NvAPI_UnicodeString,
}
#[test]
fn bindgen_test_layout__NVDRS_SETTING_VALUES__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_SETTING_VALUES__bindgen_ty_2>(),
        4100usize,
        concat!("Size of: ", stringify!(_NVDRS_SETTING_VALUES__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_SETTING_VALUES__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NVDRS_SETTING_VALUES__bindgen_ty_2)
        )
    );
    fn test_field_u32Value() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NVDRS_SETTING_VALUES__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u32Value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_VALUES__bindgen_ty_2),
                "::",
                stringify!(u32Value)
            )
        );
    }
    test_field_u32Value();
    fn test_field_binaryValue() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NVDRS_SETTING_VALUES__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).binaryValue) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_VALUES__bindgen_ty_2),
                "::",
                stringify!(binaryValue)
            )
        );
    }
    test_field_binaryValue();
    fn test_field_wszValue() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NVDRS_SETTING_VALUES__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wszValue) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_VALUES__bindgen_ty_2),
                "::",
                stringify!(wszValue)
            )
        );
    }
    test_field_wszValue();
}
impl Default for _NVDRS_SETTING_VALUES__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__NVDRS_SETTING_VALUES() {
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_SETTING_VALUES>(),
        414112usize,
        concat!("Size of: ", stringify!(_NVDRS_SETTING_VALUES))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_SETTING_VALUES>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_SETTING_VALUES))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_SETTING_VALUES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_VALUES),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_numSettingValues() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_SETTING_VALUES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numSettingValues) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_VALUES),
                "::",
                stringify!(numSettingValues)
            )
        );
    }
    test_field_numSettingValues();
    fn test_field_settingType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_SETTING_VALUES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).settingType) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_VALUES),
                "::",
                stringify!(settingType)
            )
        );
    }
    test_field_settingType();
    fn test_field_settingValues() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_SETTING_VALUES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).settingValues) as usize - ptr as usize
            },
            4112usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_VALUES),
                "::",
                stringify!(settingValues)
            )
        );
    }
    test_field_settingValues();
}
impl Default for _NVDRS_SETTING_VALUES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NVDRS_SETTING_VALUES = _NVDRS_SETTING_VALUES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVDRS_SETTING_V1 {
    #[doc = "!< Structure Version"]
    pub version: NvU32,
    #[doc = "!< String name of setting"]
    pub settingName: NvAPI_UnicodeString,
    #[doc = "!< 32 bit setting Id"]
    pub settingId: NvU32,
    #[doc = "!< Type of setting value."]
    pub settingType: NVDRS_SETTING_TYPE,
    #[doc = "!< Describes where the value in CurrentValue comes from."]
    pub settingLocation: NVDRS_SETTING_LOCATION,
    #[doc = "!< It is different than 0 if the currentValue is a predefined Value,"]
    #[doc = "!< 0 if the currentValue is a user value."]
    pub isCurrentPredefined: NvU32,
    #[doc = "!< It is different than 0 if the PredefinedValue union contains a valid value."]
    pub isPredefinedValid: NvU32,
    pub __bindgen_anon_1: _NVDRS_SETTING_V1__bindgen_ty_1,
    pub __bindgen_anon_2: _NVDRS_SETTING_V1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVDRS_SETTING_V1__bindgen_ty_1 {
    #[doc = "!< Accessing default DWORD value of this setting."]
    pub u32PredefinedValue: NvU32,
    #[doc = "!< Accessing default Binary value of this setting."]
    #[doc = "!< Must be allocated by caller with valueLength specifying buffer size,"]
    #[doc = "!< or only valueLength will be filled in."]
    pub binaryPredefinedValue: NVDRS_BINARY_SETTING,
    #[doc = "!< Accessing default unicode string value of this setting."]
    pub wszPredefinedValue: NvAPI_UnicodeString,
}
#[test]
fn bindgen_test_layout__NVDRS_SETTING_V1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_SETTING_V1__bindgen_ty_1>(),
        4100usize,
        concat!("Size of: ", stringify!(_NVDRS_SETTING_V1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_SETTING_V1__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_SETTING_V1__bindgen_ty_1))
    );
    fn test_field_u32PredefinedValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_SETTING_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u32PredefinedValue) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_V1__bindgen_ty_1),
                "::",
                stringify!(u32PredefinedValue)
            )
        );
    }
    test_field_u32PredefinedValue();
    fn test_field_binaryPredefinedValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_SETTING_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).binaryPredefinedValue) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_V1__bindgen_ty_1),
                "::",
                stringify!(binaryPredefinedValue)
            )
        );
    }
    test_field_binaryPredefinedValue();
    fn test_field_wszPredefinedValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_SETTING_V1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wszPredefinedValue) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_V1__bindgen_ty_1),
                "::",
                stringify!(wszPredefinedValue)
            )
        );
    }
    test_field_wszPredefinedValue();
}
impl Default for _NVDRS_SETTING_V1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVDRS_SETTING_V1__bindgen_ty_2 {
    #[doc = "!< Accessing current DWORD value of this setting."]
    pub u32CurrentValue: NvU32,
    #[doc = "!< Accessing current Binary value of this setting."]
    #[doc = "!< Must be allocated by caller with valueLength specifying buffer size,"]
    #[doc = "!< or only valueLength will be filled in."]
    pub binaryCurrentValue: NVDRS_BINARY_SETTING,
    #[doc = "!< Accessing current unicode string value of this setting."]
    pub wszCurrentValue: NvAPI_UnicodeString,
}
#[test]
fn bindgen_test_layout__NVDRS_SETTING_V1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_SETTING_V1__bindgen_ty_2>(),
        4100usize,
        concat!("Size of: ", stringify!(_NVDRS_SETTING_V1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_SETTING_V1__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_SETTING_V1__bindgen_ty_2))
    );
    fn test_field_u32CurrentValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_SETTING_V1__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u32CurrentValue) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_V1__bindgen_ty_2),
                "::",
                stringify!(u32CurrentValue)
            )
        );
    }
    test_field_u32CurrentValue();
    fn test_field_binaryCurrentValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_SETTING_V1__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).binaryCurrentValue) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_V1__bindgen_ty_2),
                "::",
                stringify!(binaryCurrentValue)
            )
        );
    }
    test_field_binaryCurrentValue();
    fn test_field_wszCurrentValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_SETTING_V1__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wszCurrentValue) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_V1__bindgen_ty_2),
                "::",
                stringify!(wszCurrentValue)
            )
        );
    }
    test_field_wszCurrentValue();
}
impl Default for _NVDRS_SETTING_V1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__NVDRS_SETTING_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_SETTING_V1>(),
        12320usize,
        concat!("Size of: ", stringify!(_NVDRS_SETTING_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_SETTING_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_SETTING_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_SETTING_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_settingName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_SETTING_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).settingName) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_V1),
                "::",
                stringify!(settingName)
            )
        );
    }
    test_field_settingName();
    fn test_field_settingId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_SETTING_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).settingId) as usize - ptr as usize
            },
            4100usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_V1),
                "::",
                stringify!(settingId)
            )
        );
    }
    test_field_settingId();
    fn test_field_settingType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_SETTING_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).settingType) as usize - ptr as usize
            },
            4104usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_V1),
                "::",
                stringify!(settingType)
            )
        );
    }
    test_field_settingType();
    fn test_field_settingLocation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_SETTING_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).settingLocation) as usize - ptr as usize
            },
            4108usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_V1),
                "::",
                stringify!(settingLocation)
            )
        );
    }
    test_field_settingLocation();
    fn test_field_isCurrentPredefined() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_SETTING_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).isCurrentPredefined) as usize - ptr as usize
            },
            4112usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_V1),
                "::",
                stringify!(isCurrentPredefined)
            )
        );
    }
    test_field_isCurrentPredefined();
    fn test_field_isPredefinedValid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_SETTING_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).isPredefinedValid) as usize - ptr as usize
            },
            4116usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_SETTING_V1),
                "::",
                stringify!(isPredefinedValid)
            )
        );
    }
    test_field_isPredefinedValid();
}
impl Default for _NVDRS_SETTING_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NVDRS_SETTING_V1 = _NVDRS_SETTING_V1;
pub type NVDRS_SETTING = NVDRS_SETTING_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVDRS_APPLICATION_V1 {
    #[doc = "!< Structure Version"]
    pub version: NvU32,
    #[doc = "!< Is the application userdefined/predefined"]
    pub isPredefined: NvU32,
    #[doc = "!< String name of the Application"]
    pub appName: NvAPI_UnicodeString,
    #[doc = "!< UserFriendly name of the Application"]
    pub userFriendlyName: NvAPI_UnicodeString,
    #[doc = "!< Indicates the name (if any) of the launcher that starts the application"]
    pub launcher: NvAPI_UnicodeString,
}
#[test]
fn bindgen_test_layout__NVDRS_APPLICATION_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_APPLICATION_V1>(),
        12296usize,
        concat!("Size of: ", stringify!(_NVDRS_APPLICATION_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_APPLICATION_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_APPLICATION_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_isPredefined() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).isPredefined) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V1),
                "::",
                stringify!(isPredefined)
            )
        );
    }
    test_field_isPredefined();
    fn test_field_appName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).appName) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V1),
                "::",
                stringify!(appName)
            )
        );
    }
    test_field_appName();
    fn test_field_userFriendlyName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).userFriendlyName) as usize - ptr as usize
            },
            4104usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V1),
                "::",
                stringify!(userFriendlyName)
            )
        );
    }
    test_field_userFriendlyName();
    fn test_field_launcher() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).launcher) as usize - ptr as usize
            },
            8200usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V1),
                "::",
                stringify!(launcher)
            )
        );
    }
    test_field_launcher();
}
impl Default for _NVDRS_APPLICATION_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NVDRS_APPLICATION_V1 = _NVDRS_APPLICATION_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVDRS_APPLICATION_V2 {
    #[doc = "!< Structure Version"]
    pub version: NvU32,
    #[doc = "!< Is the application userdefined/predefined"]
    pub isPredefined: NvU32,
    #[doc = "!< String name of the Application"]
    pub appName: NvAPI_UnicodeString,
    #[doc = "!< UserFriendly name of the Application"]
    pub userFriendlyName: NvAPI_UnicodeString,
    #[doc = "!< Indicates the name (if any) of the launcher that starts the Application"]
    pub launcher: NvAPI_UnicodeString,
    #[doc = "!< Select this application only if this file is found."]
    #[doc = "!< When specifying multiple files, separate them using the ':' character."]
    pub fileInFolder: NvAPI_UnicodeString,
}
#[test]
fn bindgen_test_layout__NVDRS_APPLICATION_V2() {
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_APPLICATION_V2>(),
        16392usize,
        concat!("Size of: ", stringify!(_NVDRS_APPLICATION_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_APPLICATION_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_APPLICATION_V2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_isPredefined() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).isPredefined) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V2),
                "::",
                stringify!(isPredefined)
            )
        );
    }
    test_field_isPredefined();
    fn test_field_appName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).appName) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V2),
                "::",
                stringify!(appName)
            )
        );
    }
    test_field_appName();
    fn test_field_userFriendlyName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).userFriendlyName) as usize - ptr as usize
            },
            4104usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V2),
                "::",
                stringify!(userFriendlyName)
            )
        );
    }
    test_field_userFriendlyName();
    fn test_field_launcher() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).launcher) as usize - ptr as usize
            },
            8200usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V2),
                "::",
                stringify!(launcher)
            )
        );
    }
    test_field_launcher();
    fn test_field_fileInFolder() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fileInFolder) as usize - ptr as usize
            },
            12296usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V2),
                "::",
                stringify!(fileInFolder)
            )
        );
    }
    test_field_fileInFolder();
}
impl Default for _NVDRS_APPLICATION_V2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NVDRS_APPLICATION_V2 = _NVDRS_APPLICATION_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVDRS_APPLICATION_V3 {
    #[doc = "!< Structure Version"]
    pub version: NvU32,
    #[doc = "!< Is the application userdefined/predefined"]
    pub isPredefined: NvU32,
    #[doc = "!< String name of the Application"]
    pub appName: NvAPI_UnicodeString,
    #[doc = "!< UserFriendly name of the Application"]
    pub userFriendlyName: NvAPI_UnicodeString,
    #[doc = "!< Indicates the name (if any) of the launcher that starts the Application"]
    pub launcher: NvAPI_UnicodeString,
    #[doc = "!< Select this application only if this file is found."]
    #[doc = "!< When specifying multiple files, separate them using the ':' character."]
    pub fileInFolder: NvAPI_UnicodeString,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NVDRS_APPLICATION_V3() {
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_APPLICATION_V3>(),
        16396usize,
        concat!("Size of: ", stringify!(_NVDRS_APPLICATION_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_APPLICATION_V3>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_APPLICATION_V3))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V3),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_isPredefined() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).isPredefined) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V3),
                "::",
                stringify!(isPredefined)
            )
        );
    }
    test_field_isPredefined();
    fn test_field_appName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).appName) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V3),
                "::",
                stringify!(appName)
            )
        );
    }
    test_field_appName();
    fn test_field_userFriendlyName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).userFriendlyName) as usize - ptr as usize
            },
            4104usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V3),
                "::",
                stringify!(userFriendlyName)
            )
        );
    }
    test_field_userFriendlyName();
    fn test_field_launcher() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).launcher) as usize - ptr as usize
            },
            8200usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V3),
                "::",
                stringify!(launcher)
            )
        );
    }
    test_field_launcher();
    fn test_field_fileInFolder() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fileInFolder) as usize - ptr as usize
            },
            12296usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V3),
                "::",
                stringify!(fileInFolder)
            )
        );
    }
    test_field_fileInFolder();
}
impl Default for _NVDRS_APPLICATION_V3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NVDRS_APPLICATION_V3 {
    #[inline]
    pub fn isMetro(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMetro(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isCommandLine(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isCommandLine(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isMetro: NvU32,
        isCommandLine: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isMetro: u32 = unsafe { ::std::mem::transmute(isMetro) };
            isMetro as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isCommandLine: u32 = unsafe { ::std::mem::transmute(isCommandLine) };
            isCommandLine as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NVDRS_APPLICATION_V3 = _NVDRS_APPLICATION_V3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVDRS_APPLICATION_V4 {
    #[doc = "!< Structure Version"]
    pub version: NvU32,
    #[doc = "!< Is the application userdefined/predefined"]
    pub isPredefined: NvU32,
    #[doc = "!< String name of the Application"]
    pub appName: NvAPI_UnicodeString,
    #[doc = "!< UserFriendly name of the Application"]
    pub userFriendlyName: NvAPI_UnicodeString,
    #[doc = "!< Indicates the name (if any) of the launcher that starts the Application"]
    pub launcher: NvAPI_UnicodeString,
    #[doc = "!< Select this application only if this file is found."]
    #[doc = "!< When specifying multiple files, separate them using the ':' character."]
    pub fileInFolder: NvAPI_UnicodeString,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< If isCommandLine is set to 0 this must be an empty. If isCommandLine is set to 1"]
    #[doc = "!< this contains application's command line as if it was returned by GetCommandLineW."]
    pub commandLine: NvAPI_UnicodeString,
}
#[test]
fn bindgen_test_layout__NVDRS_APPLICATION_V4() {
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_APPLICATION_V4>(),
        20492usize,
        concat!("Size of: ", stringify!(_NVDRS_APPLICATION_V4))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_APPLICATION_V4>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_APPLICATION_V4))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V4),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_isPredefined() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).isPredefined) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V4),
                "::",
                stringify!(isPredefined)
            )
        );
    }
    test_field_isPredefined();
    fn test_field_appName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).appName) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V4),
                "::",
                stringify!(appName)
            )
        );
    }
    test_field_appName();
    fn test_field_userFriendlyName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).userFriendlyName) as usize - ptr as usize
            },
            4104usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V4),
                "::",
                stringify!(userFriendlyName)
            )
        );
    }
    test_field_userFriendlyName();
    fn test_field_launcher() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).launcher) as usize - ptr as usize
            },
            8200usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V4),
                "::",
                stringify!(launcher)
            )
        );
    }
    test_field_launcher();
    fn test_field_fileInFolder() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fileInFolder) as usize - ptr as usize
            },
            12296usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V4),
                "::",
                stringify!(fileInFolder)
            )
        );
    }
    test_field_fileInFolder();
    fn test_field_commandLine() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_APPLICATION_V4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).commandLine) as usize - ptr as usize
            },
            16396usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_APPLICATION_V4),
                "::",
                stringify!(commandLine)
            )
        );
    }
    test_field_commandLine();
}
impl Default for _NVDRS_APPLICATION_V4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NVDRS_APPLICATION_V4 {
    #[inline]
    pub fn isMetro(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMetro(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isCommandLine(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isCommandLine(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isMetro: NvU32,
        isCommandLine: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isMetro: u32 = unsafe { ::std::mem::transmute(isMetro) };
            isMetro as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isCommandLine: u32 = unsafe { ::std::mem::transmute(isCommandLine) };
            isCommandLine as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NVDRS_APPLICATION_V4 = _NVDRS_APPLICATION_V4;
pub type NVDRS_APPLICATION = NVDRS_APPLICATION_V4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVDRS_PROFILE_V1 {
    #[doc = "!< Structure Version"]
    pub version: NvU32,
    #[doc = "!< String name of the Profile"]
    pub profileName: NvAPI_UnicodeString,
    #[doc = "!< This read-only flag indicates the profile support on either"]
    #[doc = "!< Quadro, or Geforce, or both."]
    pub gpuSupport: NVDRS_GPU_SUPPORT,
    #[doc = "!< Is the Profile user-defined, or predefined"]
    pub isPredefined: NvU32,
    #[doc = "!< Total number of applications that belong to this profile. Read-only"]
    pub numOfApps: NvU32,
    #[doc = "!< Total number of settings applied for this Profile. Read-only"]
    pub numOfSettings: NvU32,
}
#[test]
fn bindgen_test_layout__NVDRS_PROFILE_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_PROFILE_V1>(),
        4116usize,
        concat!("Size of: ", stringify!(_NVDRS_PROFILE_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_PROFILE_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_PROFILE_V1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_PROFILE_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_PROFILE_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_profileName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_PROFILE_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).profileName) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_PROFILE_V1),
                "::",
                stringify!(profileName)
            )
        );
    }
    test_field_profileName();
    fn test_field_gpuSupport() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_PROFILE_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gpuSupport) as usize - ptr as usize
            },
            4100usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_PROFILE_V1),
                "::",
                stringify!(gpuSupport)
            )
        );
    }
    test_field_gpuSupport();
    fn test_field_isPredefined() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_PROFILE_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).isPredefined) as usize - ptr as usize
            },
            4104usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_PROFILE_V1),
                "::",
                stringify!(isPredefined)
            )
        );
    }
    test_field_isPredefined();
    fn test_field_numOfApps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_PROFILE_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numOfApps) as usize - ptr as usize
            },
            4108usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_PROFILE_V1),
                "::",
                stringify!(numOfApps)
            )
        );
    }
    test_field_numOfApps();
    fn test_field_numOfSettings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NVDRS_PROFILE_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numOfSettings) as usize - ptr as usize
            },
            4112usize,
            concat!(
                "Offset of field: ",
                stringify!(_NVDRS_PROFILE_V1),
                "::",
                stringify!(numOfSettings)
            )
        );
    }
    test_field_numOfSettings();
}
impl Default for _NVDRS_PROFILE_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NVDRS_PROFILE_V1 = _NVDRS_PROFILE_V1;
pub type NVDRS_PROFILE = NVDRS_PROFILE_V1;
extern "C" {
    #[doc = ""]
    pub fn NvAPI_DRS_CreateSession(phSession: *mut NvDRSSessionHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    pub fn NvAPI_DRS_DestroySession(hSession: NvDRSSessionHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    pub fn NvAPI_DRS_LoadSettings(hSession: NvDRSSessionHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    pub fn NvAPI_DRS_SaveSettings(hSession: NvDRSSessionHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    pub fn NvAPI_DRS_LoadSettingsFromFile(
        hSession: NvDRSSessionHandle,
        fileName: *mut NvU16,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = ""]
    pub fn NvAPI_DRS_SaveSettingsToFile(
        hSession: NvDRSSessionHandle,
        fileName: *mut NvU16,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API creates an empty profile."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]  hSession        Input to the session handle."]
    #[doc = "! \\param [in]  *pProfileInfo   Input pointer to NVDRS_PROFILE."]
    #[doc = "! \\param [in]  *phProfile      Returns pointer to profile handle."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK     SUCCESS"]
    #[doc = "! \\retval ::NVAPI_ERROR  For miscellaneous errors."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_CreateProfile(
        hSession: NvDRSSessionHandle,
        pProfileInfo: *mut NVDRS_PROFILE,
        phProfile: *mut NvDRSProfileHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API deletes a profile or sets it back to a predefined value."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in] hSession  Input to the session handle."]
    #[doc = "! \\param [in] hProfile  Input profile handle."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK     SUCCESS if the profile is found"]
    #[doc = "! \\retval ::NVAPI_ERROR  For miscellaneous errors."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_DeleteProfile(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API sets the current global profile in the driver."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in] hSession                Input to the session handle."]
    #[doc = "! \\param [in] wszGlobalProfileName    Input current Global profile name."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK     SUCCESS"]
    #[doc = "! \\retval ::NVAPI_ERROR  For miscellaneous errors."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_SetCurrentGlobalProfile(
        hSession: NvDRSSessionHandle,
        wszGlobalProfileName: *mut NvU16,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API returns the handle to the current global profile."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]   hSession     Input to the session handle."]
    #[doc = "! \\param [out]  *phProfile   Returns current Global profile handle."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK     SUCCESS"]
    #[doc = "! \\retval ::NVAPI_ERROR  For miscellaneous errors."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_GetCurrentGlobalProfile(
        hSession: NvDRSSessionHandle,
        phProfile: *mut NvDRSProfileHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API gets information about the given profile. User needs to specify the name of the Profile."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]  hSession       Input to the session handle."]
    #[doc = "! \\param [in]  hProfile       Input profile handle."]
    #[doc = "! \\param [out] *pProfileInfo  Return the profile info."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK     SUCCESS"]
    #[doc = "! \\retval ::NVAPI_ERROR  For miscellaneous errors."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_GetProfileInfo(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        pProfileInfo: *mut NVDRS_PROFILE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: Specifies flags for a given profile. Currently only the NVDRS_GPU_SUPPORT is"]
    #[doc = "!                used to update the profile. Neither the name, number of settings or applications"]
    #[doc = "!                or other profile information can be changed with this function."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]  hSession       Input to the session handle."]
    #[doc = "! \\param [in]  hProfile       Input profile handle."]
    #[doc = "! \\param [in]  *pProfileInfo  Input the new profile info."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK     SUCCESS"]
    #[doc = "! \\retval ::NVAPI_ERROR  For miscellaneous errors."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_SetProfileInfo(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        pProfileInfo: *mut NVDRS_PROFILE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API finds a profile in the current session."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]   hSession      Input to the session handle."]
    #[doc = "! \\param [in]   profileName   Input profileName."]
    #[doc = "! \\param [out]  phProfile     Input profile handle."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                SUCCESS if the profile is found"]
    #[doc = "! \\retval ::NVAPI_PROFILE_NOT_FOUND if profile is not found"]
    #[doc = "! \\retval ::NVAPI_ERROR             For miscellaneous errors."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_FindProfileByName(
        hSession: NvDRSSessionHandle,
        profileName: *mut NvU16,
        phProfile: *mut NvDRSProfileHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API enumerates through all the profiles in the session."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]   hSession        Input to the session handle."]
    #[doc = "! \\param [in]   index           Input the index for enumeration."]
    #[doc = "! \\param [out]  *phProfile      Returns profile handle."]
    #[doc = "!"]
    #[doc = "!   RETURN STATUS: NVAPI_OK: SUCCESS if the profile is found"]
    #[doc = "!                  NVAPI_ERROR: For miscellaneous errors."]
    #[doc = "!                  NVAPI_END_ENUMERATION: index exceeds the total number of available Profiles in DB."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_EnumProfiles(
        hSession: NvDRSSessionHandle,
        index: NvU32,
        phProfile: *mut NvDRSProfileHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API obtains the number of profiles in the current session object."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]  hSession       Input to the session handle."]
    #[doc = "! \\param out]  *numProfiles   Returns count of profiles in the current hSession."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                  SUCCESS"]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED  Failed to initialize."]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT    Invalid Arguments."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_GetNumProfiles(
        hSession: NvDRSSessionHandle,
        numProfiles: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API adds an executable name to a profile."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]  hSession       Input to the session handle."]
    #[doc = "! \\param [in]  hProfile       Input profile handle."]
    #[doc = "! \\param [in]  *pApplication  Input NVDRS_APPLICATION struct with the executable name to be added."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK     SUCCESS"]
    #[doc = "! \\retval ::NVAPI_ERROR  For miscellaneous errors."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_CreateApplication(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        pApplication: *mut NVDRS_APPLICATION,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API removes an executable from a profile."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]   hSession  - Input to the session handle."]
    #[doc = "! \\param [in]   hProfile  - Input profile handle."]
    #[doc = "! \\param [in]   *pApp     - Input all the information about the application to be removed."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK  SUCCESS"]
    #[doc = "! \\retval ::NVAPI_ERROR For miscellaneous errors."]
    #[doc = "! \\retval ::NVAPI_EXECUTABLE_PATH_IS_AMBIGUOUS If the path provided could refer to two different executables,"]
    #[doc = "!                                              this error will be returned."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_DeleteApplicationEx(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        pApp: *mut NVDRS_APPLICATION,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API removes an executable name from a profile."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]  hSessionPARAMETERS   Input to the session handle."]
    #[doc = "! \\param [in]  hProfile             Input profile handle."]
    #[doc = "! \\param [in]  appName              Input the executable name to be removed."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK     SUCCESS"]
    #[doc = "! \\retval ::NVAPI_ERROR  For miscellaneous errors."]
    #[doc = "! \\retval ::NVAPI_EXECUTABLE_PATH_IS_AMBIGUOUS If the path provided could refer to two different executables,"]
    #[doc = "!                                              this error will be returned"]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_DeleteApplication(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        appName: *mut NvU16,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! \\retval ::NVAPI_EXECUTABLE_NOT_FOUND           No application with that name is found on the profile."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_GetApplicationInfo(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        appName: *mut NvU16,
        pApplication: *mut NVDRS_APPLICATION,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API enumerates all the applications in a given profile from the starting index to the maximum length."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]      hSession         Input to the session handle."]
    #[doc = "! \\param [in]      hProfile         Input profile handle."]
    #[doc = "! \\param [in]      startIndex       Indicates starting index for enumeration."]
    #[doc = "! \\param [in,out]  *appCount        Input maximum length of the passed in arrays. Returns the actual length."]
    #[doc = "! \\param [out]     *pApplication    Returns NVDRS_APPLICATION struct with all the attributes."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK               SUCCESS"]
    #[doc = "! \\retval ::NVAPI_ERROR            For miscellaneous errors."]
    #[doc = "! \\retval ::NVAPI_END_ENUMERATION  startIndex exceeds the total appCount."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_EnumApplications(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        startIndex: NvU32,
        appCount: *mut NvU32,
        pApplication: *mut NVDRS_APPLICATION,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API searches the application and the associated profile for the given application name."]
    #[doc = "!                If a fully qualified path is provided, this function will always return the profile"]
    #[doc = "!                the driver will apply upon running the application (on the path provided)."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]      hSession       Input to the hSession handle"]
    #[doc = "! \\param [in]      appName        Input appName. For best results, provide a fully qualified path of the type"]
    #[doc = "!                                 c:/Folder1/Folder2/App.exe"]
    #[doc = "! \\param [out]     *phProfile     Returns profile handle."]
    #[doc = "! \\param [in,out]  *pApplication  Returns NVDRS_APPLICATION struct pointer."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in #NvAPI_Status."]
    #[doc = "!                  If there are return error codes with specific meaning for this API,"]
    #[doc = "!                  they are listed below:"]
    #[doc = "! \\retval ::NVAPI_APPLICATION_NOT_FOUND          If App not found"]
    #[doc = "! \\retval ::NVAPI_EXECUTABLE_PATH_IS_AMBIGUOUS   If the input appName was not fully qualified, this error might return in the case of multiple matches"]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_FindApplicationByName(
        hSession: NvDRSSessionHandle,
        appName: *mut NvU16,
        phProfile: *mut NvDRSProfileHandle,
        pApplication: *mut NVDRS_APPLICATION,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API adds/modifies a setting to a profile."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]  hSession     Input to the session handle."]
    #[doc = "! \\param [in]  hProfile     Input profile handle."]
    #[doc = "! \\param [in]   *pSetting   Input NVDRS_SETTING struct pointer."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK     SUCCESS"]
    #[doc = "! \\retval ::NVAPI_ERROR  For miscellaneous errors."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_SetSetting(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        pSetting: *mut NVDRS_SETTING,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API gets information about the given setting."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]   hSession   Input to the session handle."]
    #[doc = "! \\param [in]   hProfile   Input profile handle."]
    #[doc = "! \\param [in]   settingId  Input settingId."]
    #[doc = "! \\param [out]  *pSetting  Returns all the setting info"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK     SUCCESS"]
    #[doc = "! \\retval ::NVAPI_ERROR  For miscellaneous errors."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_GetSetting(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        settingId: NvU32,
        pSetting: *mut NVDRS_SETTING,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API enumerates all the settings of a given profile from startIndex to the maximum length."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]      hSession        Input to the session handle."]
    #[doc = "! \\param [in]      hProfile        Input profile handle."]
    #[doc = "! \\param [in]      startIndex      Indicates starting index for enumeration."]
    #[doc = "! \\param [in,out]  *settingsCount  Input max length of the passed in arrays, Returns the actual length."]
    #[doc = "! \\param [out]     *pSetting       Returns all the settings info."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK              SUCCESS"]
    #[doc = "! \\retval ::NVAPI_ERROR           For miscellaneous errors."]
    #[doc = "! \\retval ::NVAPI_END_ENUMERATION startIndex exceeds the total appCount."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_EnumSettings(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        startIndex: NvU32,
        settingsCount: *mut NvU32,
        pSetting: *mut NVDRS_SETTING,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API enumerates all the Ids of all the settings recognized by NVAPI."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [out]    pSettingIds     User-provided array of length *pMaxCount that NVAPI will fill with IDs."]
    #[doc = "! \\param [in,out] pMaxCount       Input max length of the passed in array, Returns the actual length."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK     SUCCESS"]
    #[doc = "! \\retval ::NVAPI_ERROR  For miscellaneous errors."]
    #[doc = "!                  NVAPI_END_ENUMERATION: the provided pMaxCount is not enough to hold all settingIds."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_EnumAvailableSettingIds(
        pSettingIds: *mut NvU32,
        pMaxCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API enumerates all available setting values for a given setting."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]      settingId          Input settingId."]
    #[doc = "! \\param [in,out]  pMaxNumValues      Input max length of the passed in arrays, Returns the actual length."]
    #[doc = "! \\param [out]     *pSettingValues    Returns all available setting values and its count."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK     SUCCESS"]
    #[doc = "! \\retval ::NVAPI_ERROR  For miscellaneous errors."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_EnumAvailableSettingValues(
        settingId: NvU32,
        pMaxNumValues: *mut NvU32,
        pSettingValues: *mut NVDRS_SETTING_VALUES,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API gets the binary ID of a setting given the setting name."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]   settingName  Input Unicode settingName."]
    #[doc = "! \\param [out]  *pSettingId  Returns corresponding settingId."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                 SUCCESS if the profile is found"]
    #[doc = "! \\retval ::NVAPI_PROFILE_NOT_FOUND  if profile is not found"]
    #[doc = "! \\retval ::NVAPI_SETTING_NOT_FOUND  if setting is not found"]
    #[doc = "! \\retval ::NVAPI_ERROR              For miscellaneous errors."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_GetSettingIdFromName(
        settingName: *mut NvU16,
        pSettingId: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API gets the setting name given the binary ID."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]  settingId        Input settingId."]
    #[doc = "! \\param [in]  *pSettingName    Returns corresponding Unicode settingName."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK                 SUCCESS if the profile is found"]
    #[doc = "! \\retval ::NVAPI_PROFILE_NOT_FOUND  if profile is not found"]
    #[doc = "! \\retval ::NVAPI_SETTING_NOT_FOUND  if setting is not found"]
    #[doc = "! \\retval ::NVAPI_ERROR              For miscellaneous errors."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_GetSettingNameFromId(
        settingId: NvU32,
        pSettingName: *mut NvAPI_UnicodeString,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API deletes a setting or sets it back to predefined value."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]  hSession            Input to the session handle."]
    #[doc = "! \\param [in]  hProfile            Input profile handle."]
    #[doc = "! \\param [in]  settingId           Input settingId to be deleted."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK     SUCCESS if the profile is found"]
    #[doc = "! \\retval ::NVAPI_ERROR  For miscellaneous errors."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_DeleteProfileSetting(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        settingId: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API restores the whole system to predefined(default) values."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]  hSession  Input to the session handle."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK     SUCCESS if the profile is found"]
    #[doc = "! \\retval ::NVAPI_ERROR  For miscellaneous errors."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_RestoreAllDefaults(hSession: NvDRSSessionHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API restores the given profile to predefined(default) values."]
    #[doc = "!                Any and all user specified modifications will be removed."]
    #[doc = "!                If the whole profile was set by the user, the profile will be removed."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]  hSession  Input to the session handle."]
    #[doc = "! \\param [in]  hProfile  Input profile handle."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK              SUCCESS if the profile is found"]
    #[doc = "! \\retval ::NVAPI_ERROR           For miscellaneous errors."]
    #[doc = "! \\retval ::NVAPI_PROFILE_REMOVED SUCCESS, and the hProfile is no longer valid."]
    #[doc = "! \\retval ::NVAPI_ERROR           For miscellaneous errors."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_RestoreProfileDefault(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API restores the given profile setting to predefined(default) values."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]  hSession  Input to the session handle."]
    #[doc = "! \\param [in]  hProfile  Input profile handle."]
    #[doc = "! \\param [in]  settingId Input settingId."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK     SUCCESS if the profile is found"]
    #[doc = "! \\retval ::NVAPI_ERROR  For miscellaneous errors."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_RestoreProfileDefaultSetting(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        settingId: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: Returns the handle to the current global profile."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]  hSession    Input to the session handle."]
    #[doc = "! \\param [in]  *phProfile   Returns Base profile handle."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK     SUCCESS if the profile is found"]
    #[doc = "! \\retval ::NVAPI_ERROR  For miscellaneous errors."]
    #[doc = "!"]
    #[doc = "! \\ingroup drsapi"]
    #[doc = ""]
    pub fn NvAPI_DRS_GetBaseProfile(
        hSession: NvDRSSessionHandle,
        phProfile: *mut NvDRSProfileHandle,
    ) -> NvAPI_Status;
}
#[doc = "! \\addtogroup sysgeneral"]
#[doc = "! @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_CHIPSET_INFO_v4 {
    #[doc = "!< structure version"]
    pub version: NvU32,
    #[doc = "!< Chipset vendor identification"]
    pub vendorId: NvU32,
    #[doc = "!< Chipset device identification"]
    pub deviceId: NvU32,
    #[doc = "!< Chipset vendor Name"]
    pub szVendorName: NvAPI_ShortString,
    #[doc = "!< Chipset device Name"]
    pub szChipsetName: NvAPI_ShortString,
    #[doc = "!< Chipset info flags - obsolete"]
    pub flags: NvU32,
    #[doc = "!< Chipset subsystem vendor identification"]
    pub subSysVendorId: NvU32,
    #[doc = "!< Chipset subsystem device identification"]
    pub subSysDeviceId: NvU32,
    #[doc = "!< subsystem vendor Name"]
    pub szSubSysVendorName: NvAPI_ShortString,
    #[doc = "!< Host bridge vendor identification"]
    pub HBvendorId: NvU32,
    #[doc = "!< Host bridge device identification"]
    pub HBdeviceId: NvU32,
    #[doc = "!< Host bridge subsystem vendor identification"]
    pub HBsubSysVendorId: NvU32,
    #[doc = "!< Host bridge subsystem device identification"]
    pub HBsubSysDeviceId: NvU32,
}
#[test]
fn bindgen_test_layout_NV_CHIPSET_INFO_v4() {
    assert_eq!(
        ::std::mem::size_of::<NV_CHIPSET_INFO_v4>(),
        232usize,
        concat!("Size of: ", stringify!(NV_CHIPSET_INFO_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_CHIPSET_INFO_v4>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_CHIPSET_INFO_v4))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v4),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_vendorId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vendorId) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v4),
                "::",
                stringify!(vendorId)
            )
        );
    }
    test_field_vendorId();
    fn test_field_deviceId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceId) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v4),
                "::",
                stringify!(deviceId)
            )
        );
    }
    test_field_deviceId();
    fn test_field_szVendorName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).szVendorName) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v4),
                "::",
                stringify!(szVendorName)
            )
        );
    }
    test_field_szVendorName();
    fn test_field_szChipsetName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).szChipsetName) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v4),
                "::",
                stringify!(szChipsetName)
            )
        );
    }
    test_field_szChipsetName();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v4),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_subSysVendorId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subSysVendorId) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v4),
                "::",
                stringify!(subSysVendorId)
            )
        );
    }
    test_field_subSysVendorId();
    fn test_field_subSysDeviceId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subSysDeviceId) as usize - ptr as usize
            },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v4),
                "::",
                stringify!(subSysDeviceId)
            )
        );
    }
    test_field_subSysDeviceId();
    fn test_field_szSubSysVendorName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).szSubSysVendorName) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v4),
                "::",
                stringify!(szSubSysVendorName)
            )
        );
    }
    test_field_szSubSysVendorName();
    fn test_field_HBvendorId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).HBvendorId) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v4),
                "::",
                stringify!(HBvendorId)
            )
        );
    }
    test_field_HBvendorId();
    fn test_field_HBdeviceId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).HBdeviceId) as usize - ptr as usize
            },
            220usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v4),
                "::",
                stringify!(HBdeviceId)
            )
        );
    }
    test_field_HBdeviceId();
    fn test_field_HBsubSysVendorId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).HBsubSysVendorId) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v4),
                "::",
                stringify!(HBsubSysVendorId)
            )
        );
    }
    test_field_HBsubSysVendorId();
    fn test_field_HBsubSysDeviceId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).HBsubSysDeviceId) as usize - ptr as usize
            },
            228usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v4),
                "::",
                stringify!(HBsubSysDeviceId)
            )
        );
    }
    test_field_HBsubSysDeviceId();
}
impl Default for NV_CHIPSET_INFO_v4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_CHIPSET_INFO_v3 {
    #[doc = "!< structure version"]
    pub version: NvU32,
    #[doc = "!< vendor ID"]
    pub vendorId: NvU32,
    #[doc = "!< device ID"]
    pub deviceId: NvU32,
    #[doc = "!< vendor Name"]
    pub szVendorName: NvAPI_ShortString,
    #[doc = "!< device Name"]
    pub szChipsetName: NvAPI_ShortString,
    #[doc = "!< Chipset info flags - obsolete"]
    pub flags: NvU32,
    #[doc = "!< subsystem vendor ID"]
    pub subSysVendorId: NvU32,
    #[doc = "!< subsystem device ID"]
    pub subSysDeviceId: NvU32,
    #[doc = "!< subsystem vendor Name"]
    pub szSubSysVendorName: NvAPI_ShortString,
}
#[test]
fn bindgen_test_layout_NV_CHIPSET_INFO_v3() {
    assert_eq!(
        ::std::mem::size_of::<NV_CHIPSET_INFO_v3>(),
        216usize,
        concat!("Size of: ", stringify!(NV_CHIPSET_INFO_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_CHIPSET_INFO_v3>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_CHIPSET_INFO_v3))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v3),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_vendorId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vendorId) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v3),
                "::",
                stringify!(vendorId)
            )
        );
    }
    test_field_vendorId();
    fn test_field_deviceId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceId) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v3),
                "::",
                stringify!(deviceId)
            )
        );
    }
    test_field_deviceId();
    fn test_field_szVendorName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).szVendorName) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v3),
                "::",
                stringify!(szVendorName)
            )
        );
    }
    test_field_szVendorName();
    fn test_field_szChipsetName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).szChipsetName) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v3),
                "::",
                stringify!(szChipsetName)
            )
        );
    }
    test_field_szChipsetName();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v3),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_subSysVendorId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subSysVendorId) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v3),
                "::",
                stringify!(subSysVendorId)
            )
        );
    }
    test_field_subSysVendorId();
    fn test_field_subSysDeviceId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subSysDeviceId) as usize - ptr as usize
            },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v3),
                "::",
                stringify!(subSysDeviceId)
            )
        );
    }
    test_field_subSysDeviceId();
    fn test_field_szSubSysVendorName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).szSubSysVendorName) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v3),
                "::",
                stringify!(szSubSysVendorName)
            )
        );
    }
    test_field_szSubSysVendorName();
}
impl Default for NV_CHIPSET_INFO_v3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const NV_CHIPSET_INFO_FLAGS_NV_CHIPSET_INFO_HYBRID: NV_CHIPSET_INFO_FLAGS = 1;
pub type NV_CHIPSET_INFO_FLAGS = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_CHIPSET_INFO_v2 {
    #[doc = "!< structure version"]
    pub version: NvU32,
    #[doc = "!< vendor ID"]
    pub vendorId: NvU32,
    #[doc = "!< device ID"]
    pub deviceId: NvU32,
    #[doc = "!< vendor Name"]
    pub szVendorName: NvAPI_ShortString,
    #[doc = "!< device Name"]
    pub szChipsetName: NvAPI_ShortString,
    #[doc = "!< Chipset info flags"]
    pub flags: NvU32,
}
#[test]
fn bindgen_test_layout_NV_CHIPSET_INFO_v2() {
    assert_eq!(
        ::std::mem::size_of::<NV_CHIPSET_INFO_v2>(),
        144usize,
        concat!("Size of: ", stringify!(NV_CHIPSET_INFO_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_CHIPSET_INFO_v2>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_CHIPSET_INFO_v2))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v2),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_vendorId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vendorId) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v2),
                "::",
                stringify!(vendorId)
            )
        );
    }
    test_field_vendorId();
    fn test_field_deviceId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceId) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v2),
                "::",
                stringify!(deviceId)
            )
        );
    }
    test_field_deviceId();
    fn test_field_szVendorName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).szVendorName) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v2),
                "::",
                stringify!(szVendorName)
            )
        );
    }
    test_field_szVendorName();
    fn test_field_szChipsetName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).szChipsetName) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v2),
                "::",
                stringify!(szChipsetName)
            )
        );
    }
    test_field_szChipsetName();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v2),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
impl Default for NV_CHIPSET_INFO_v2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_CHIPSET_INFO_v1 {
    pub version: NvU32,
    pub vendorId: NvU32,
    pub deviceId: NvU32,
    pub szVendorName: NvAPI_ShortString,
    pub szChipsetName: NvAPI_ShortString,
}
#[test]
fn bindgen_test_layout_NV_CHIPSET_INFO_v1() {
    assert_eq!(
        ::std::mem::size_of::<NV_CHIPSET_INFO_v1>(),
        140usize,
        concat!("Size of: ", stringify!(NV_CHIPSET_INFO_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_CHIPSET_INFO_v1>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_CHIPSET_INFO_v1))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_vendorId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vendorId) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v1),
                "::",
                stringify!(vendorId)
            )
        );
    }
    test_field_vendorId();
    fn test_field_deviceId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceId) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v1),
                "::",
                stringify!(deviceId)
            )
        );
    }
    test_field_deviceId();
    fn test_field_szVendorName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).szVendorName) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v1),
                "::",
                stringify!(szVendorName)
            )
        );
    }
    test_field_szVendorName();
    fn test_field_szChipsetName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_CHIPSET_INFO_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).szChipsetName) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_CHIPSET_INFO_v1),
                "::",
                stringify!(szChipsetName)
            )
        );
    }
    test_field_szChipsetName();
}
impl Default for NV_CHIPSET_INFO_v1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "!  This function returns information about the system's chipset."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 95"]
    #[doc = "!"]
    #[doc = "! \\retval  NVAPI_INVALID_ARGUMENT              pChipSetInfo is NULL."]
    #[doc = "! \\retval  NVAPI_OK                           *pChipSetInfo is now set."]
    #[doc = "! \\retval  NVAPI_INCOMPATIBLE_STRUCT_VERSION   NV_CHIPSET_INFO version not compatible with driver."]
    #[doc = "! \\ingroup sysgeneral"]
    #[doc = ""]
    pub fn NvAPI_SYS_GetChipSetInfo(pChipSetInfo: *mut NV_CHIPSET_INFO_v4) -> NvAPI_Status;
}
#[doc = "! \\ingroup sysgeneral"]
#[doc = "! Lid and dock information - used in NvAPI_GetLidDockInfo()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NV_LID_DOCK_PARAMS {
    pub version: NvU32,
    #[doc = "! Structure version, constructed from the macro #NV_LID_DOCK_PARAMS_VER"]
    pub currentLidState: NvU32,
    pub currentDockState: NvU32,
    pub currentLidPolicy: NvU32,
    pub currentDockPolicy: NvU32,
    pub forcedLidMechanismPresent: NvU32,
    pub forcedDockMechanismPresent: NvU32,
}
#[test]
fn bindgen_test_layout_NV_LID_DOCK_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<NV_LID_DOCK_PARAMS>(),
        28usize,
        concat!("Size of: ", stringify!(NV_LID_DOCK_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_LID_DOCK_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_LID_DOCK_PARAMS))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_LID_DOCK_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_LID_DOCK_PARAMS),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_currentLidState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_LID_DOCK_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).currentLidState) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_LID_DOCK_PARAMS),
                "::",
                stringify!(currentLidState)
            )
        );
    }
    test_field_currentLidState();
    fn test_field_currentDockState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_LID_DOCK_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).currentDockState) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_LID_DOCK_PARAMS),
                "::",
                stringify!(currentDockState)
            )
        );
    }
    test_field_currentDockState();
    fn test_field_currentLidPolicy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_LID_DOCK_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).currentLidPolicy) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_LID_DOCK_PARAMS),
                "::",
                stringify!(currentLidPolicy)
            )
        );
    }
    test_field_currentLidPolicy();
    fn test_field_currentDockPolicy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_LID_DOCK_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).currentDockPolicy) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_LID_DOCK_PARAMS),
                "::",
                stringify!(currentDockPolicy)
            )
        );
    }
    test_field_currentDockPolicy();
    fn test_field_forcedLidMechanismPresent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_LID_DOCK_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).forcedLidMechanismPresent) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_LID_DOCK_PARAMS),
                "::",
                stringify!(forcedLidMechanismPresent)
            )
        );
    }
    test_field_forcedLidMechanismPresent();
    fn test_field_forcedDockMechanismPresent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NV_LID_DOCK_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).forcedDockMechanismPresent) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(NV_LID_DOCK_PARAMS),
                "::",
                stringify!(forcedDockMechanismPresent)
            )
        );
    }
    test_field_forcedDockMechanismPresent();
}
extern "C" {
    #[doc = "! DESCRIPTION: This function returns the current lid and dock information."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 177"]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK"]
    #[doc = "! \\retval ::NVAPI_ERROR"]
    #[doc = "! \\retval ::NVAPI_NOT_SUPPORTED"]
    #[doc = "! \\retval ::NVAPI_HANDLE_INVALIDATED"]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED"]
    #[doc = "!"]
    #[doc = "! \\ingroup sysgeneral"]
    #[doc = ""]
    pub fn NvAPI_SYS_GetLidAndDockInfo(pLidAndDock: *mut NV_LID_DOCK_PARAMS) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API converts a Physical GPU handle and output ID to a"]
    #[doc = "!                  display ID."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]     hPhysicalGpu   Handle to the physical GPU"]
    #[doc = "! \\param [in]     outputId       Connected display output ID on the"]
    #[doc = "!                                target GPU - must only have one bit set"]
    #[doc = "! \\param [out]    displayId      Pointer to an NvU32 which contains"]
    #[doc = "!                                 the display ID"]
    #[doc = "!"]
    #[doc = "! \\retval  ::NVAPI_OK - completed request"]
    #[doc = "! \\retval  ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized"]
    #[doc = "! \\retval  ::NVAPI_ERROR - miscellaneous error occurred"]
    #[doc = "! \\retval  ::NVAPI_INVALID_ARGUMENT - Invalid input parameter."]
    #[doc = "!"]
    #[doc = "! \\ingroup sysgeneral"]
    #[doc = ""]
    pub fn NvAPI_SYS_GetDisplayIdFromGpuAndOutputId(
        hPhysicalGpu: NvPhysicalGpuHandle,
        outputId: NvU32,
        displayId: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API converts a display ID to a Physical GPU handle and output ID."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\param [in]     displayId       Display ID of display to retrieve"]
    #[doc = "!                                 GPU and outputId for"]
    #[doc = "! \\param [out]    hPhysicalGpu    Handle to the physical GPU"]
    #[doc = "! \\param [out]    outputId )      Connected display output ID on the"]
    #[doc = "!                                 target GPU will only have one bit set."]
    #[doc = "!"]
    #[doc = "! \\retval ::NVAPI_OK"]
    #[doc = "! \\retval ::NVAPI_API_NOT_INTIALIZED"]
    #[doc = "! \\retval ::NVAPI_ID_OUT_OF_RANGE    The DisplayId corresponds to a"]
    #[doc = "!                                    display which is not within the"]
    #[doc = "!                                    normal outputId range."]
    #[doc = "! \\retval ::NVAPI_ERROR"]
    #[doc = "! \\retval ::NVAPI_INVALID_ARGUMENT"]
    #[doc = "!"]
    #[doc = "! \\ingroup sysgeneral"]
    #[doc = ""]
    pub fn NvAPI_SYS_GetGpuAndOutputIdFromDisplayId(
        displayId: NvU32,
        hPhysicalGpu: *mut NvPhysicalGpuHandle,
        outputId: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! \\code"]
    #[doc = "! DESCRIPTION:     This API retrieves the Physical GPU handle of the connected display"]
    #[doc = "!"]
    #[doc = "! \\since Release: 313"]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! PARAMETERS:      displayId(IN)     - Display ID of display to retrieve"]
    #[doc = "!                                      GPU handle"]
    #[doc = "!                  hPhysicalGpu(OUT) - Handle to the physical GPU"]
    #[doc = "!"]
    #[doc = "! RETURN STATUS:"]
    #[doc = "!                  NVAPI_OK - completed request"]
    #[doc = "!                  NVAPI_API_NOT_INTIALIZED - NVAPI not initialized"]
    #[doc = "!                  NVAPI_ERROR - miscellaneous error occurred"]
    #[doc = "!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter."]
    #[doc = "! \\endcode"]
    #[doc = "! \\ingroup sysgeneral"]
    #[doc = ""]
    pub fn NvAPI_SYS_GetPhysicalGpuFromDisplayId(
        displayId: NvU32,
        hPhysicalGpu: *mut NvPhysicalGpuHandle,
    ) -> NvAPI_Status;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_DISPLAY_DRIVER_INFO {
    #[doc = "!< Structure Version."]
    pub version: NvU32,
    #[doc = "!< Contains the driver version after successful return."]
    pub driverVersion: NvU32,
    #[doc = "!< Contains the driver-branch string after successful return."]
    pub szBuildBranch: NvAPI_ShortString,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NV_DISPLAY_DRIVER_INFO() {
    assert_eq!(
        ::std::mem::size_of::<_NV_DISPLAY_DRIVER_INFO>(),
        76usize,
        concat!("Size of: ", stringify!(_NV_DISPLAY_DRIVER_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_DISPLAY_DRIVER_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_DISPLAY_DRIVER_INFO))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAY_DRIVER_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAY_DRIVER_INFO),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_driverVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAY_DRIVER_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).driverVersion) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAY_DRIVER_INFO),
                "::",
                stringify!(driverVersion)
            )
        );
    }
    test_field_driverVersion();
    fn test_field_szBuildBranch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NV_DISPLAY_DRIVER_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).szBuildBranch) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_DISPLAY_DRIVER_INFO),
                "::",
                stringify!(szBuildBranch)
            )
        );
    }
    test_field_szBuildBranch();
}
impl Default for _NV_DISPLAY_DRIVER_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_DISPLAY_DRIVER_INFO {
    #[inline]
    pub fn bIsDCHDriver(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsDCHDriver(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsNVIDIAStudioPackage(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsNVIDIAStudioPackage(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsNVIDIAGameReadyPackage(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsNVIDIAGameReadyPackage(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsNVIDIARTXProductionBranchPackage(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsNVIDIARTXProductionBranchPackage(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsNVIDIARTXNewFeatureBranchPackage(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsNVIDIARTXNewFeatureBranchPackage(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsDCHDriver: NvU32,
        bIsNVIDIAStudioPackage: NvU32,
        bIsNVIDIAGameReadyPackage: NvU32,
        bIsNVIDIARTXProductionBranchPackage: NvU32,
        bIsNVIDIARTXNewFeatureBranchPackage: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsDCHDriver: u32 = unsafe { ::std::mem::transmute(bIsDCHDriver) };
            bIsDCHDriver as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bIsNVIDIAStudioPackage: u32 =
                unsafe { ::std::mem::transmute(bIsNVIDIAStudioPackage) };
            bIsNVIDIAStudioPackage as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bIsNVIDIAGameReadyPackage: u32 =
                unsafe { ::std::mem::transmute(bIsNVIDIAGameReadyPackage) };
            bIsNVIDIAGameReadyPackage as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bIsNVIDIARTXProductionBranchPackage: u32 =
                unsafe { ::std::mem::transmute(bIsNVIDIARTXProductionBranchPackage) };
            bIsNVIDIARTXProductionBranchPackage as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let bIsNVIDIARTXNewFeatureBranchPackage: u32 =
                unsafe { ::std::mem::transmute(bIsNVIDIARTXNewFeatureBranchPackage) };
            bIsNVIDIARTXNewFeatureBranchPackage as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_DISPLAY_DRIVER_INFO_V1 = _NV_DISPLAY_DRIVER_INFO;
pub type NV_DISPLAY_DRIVER_INFO = NV_DISPLAY_DRIVER_INFO_V1;
extern "C" {
    #[doc = "! DESCRIPTION: This API will return information related to the NVIDIA Display Driver."]
    #[doc = "!              Note that out of the driver types - Studio, Game Ready, RTX Production Branch, RTX New Feature Branch - only one driver type can be available in system."]
    #[doc = "!              If NVAPI is unable to get the information of particular driver type, we report all flags as 0 (Unknown)."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 7 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release: 396"]
    #[doc = "!"]
    #[doc = "! \\param [inout] pDriverInfo - This structure will be filled with required information."]
    #[doc = "!"]
    #[doc = "! \\return  This API can return any of the error codes enumerated in"]
    #[doc = "!          #NvAPI_Status.  If there are return error codes with specific"]
    #[doc = "!          meaning for this API, they are listed below."]
    #[doc = "!"]
    #[doc = "! \\ingroup gpu"]
    #[doc = ""]
    pub fn NvAPI_SYS_GetDisplayDriverInfo(pDriverInfo: *mut NV_DISPLAY_DRIVER_INFO)
        -> NvAPI_Status;
}
#[doc = " Callback settings common to all client callbacks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1 {
    #[doc = " [in] Generic callback parameter which will be passed to the callback."]
    pub pCallbackParam: *mut ::std::os::raw::c_void,
    #[doc = " Reserved bytes for future expansion."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(_NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1)
        )
    );
    fn test_field_pCallbackParam() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pCallbackParam) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1),
                "::",
                stringify!(pCallbackParam)
            )
        );
    }
    test_field_pCallbackParam();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Callback settings common to all client callbacks."]
pub type NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1 = _NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1;
#[doc = " Callback settings common to all client callbacks."]
pub type NV_GPU_CLIENT_CALLBACK_SETTINGS_SUPER_V1 = NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1;
#[doc = " Callback settings common to all periodic client callbacks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1 {
    #[doc = " [in] Super class data."]
    pub super_: NV_GPU_CLIENT_CALLBACK_SETTINGS_SUPER_V1,
    #[doc = " [in] Minimum interval at which callback will be called."]
    #[doc = ""]
    #[doc = " The callback may be invoked slower than this interval if underlying"]
    #[doc = " sampling rate does not align precisely to the provided period."]
    pub callbackPeriodms: NvU32,
    #[doc = " Reserved bytes for future expansion."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1)
        )
    );
    fn test_field_super() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).super_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1),
                "::",
                stringify!(super_)
            )
        );
    }
    test_field_super();
    fn test_field_callbackPeriodms() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).callbackPeriodms) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1),
                "::",
                stringify!(callbackPeriodms)
            )
        );
    }
    test_field_callbackPeriodms();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Callback settings common to all periodic client callbacks."]
pub type NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1 =
    _NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1;
#[doc = " Callback data common to all client callbacks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1 {
    #[doc = " [out] Generic callback parameter which was passed in at registration time."]
    pub pCallbackParam: *mut ::std::os::raw::c_void,
    #[doc = " Reserved bytes for future expansion."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1)
        )
    );
    fn test_field_pCallbackParam() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pCallbackParam) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1),
                "::",
                stringify!(pCallbackParam)
            )
        );
    }
    test_field_pCallbackParam();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Callback data common to all client callbacks."]
pub type NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1 = _NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1;
pub const _NV_GPU_CLIENT_UTIL_DOMAIN_ID_NV_GPU_CLIENT_UTIL_DOMAIN_GRAPHICS:
    _NV_GPU_CLIENT_UTIL_DOMAIN_ID = 0;
pub const _NV_GPU_CLIENT_UTIL_DOMAIN_ID_NV_GPU_CLIENT_UTIL_DOMAIN_FRAME_BUFFER:
    _NV_GPU_CLIENT_UTIL_DOMAIN_ID = 1;
pub const _NV_GPU_CLIENT_UTIL_DOMAIN_ID_NV_GPU_CLIENT_UTIL_DOMAIN_VIDEO:
    _NV_GPU_CLIENT_UTIL_DOMAIN_ID = 2;
#[doc = " Reserved for future use."]
pub const _NV_GPU_CLIENT_UTIL_DOMAIN_ID_NV_GPU_CLIENT_UTIL_DOMAIN_RSVD:
    _NV_GPU_CLIENT_UTIL_DOMAIN_ID = 3;
#[doc = " Enumeration of different utilization domains"]
pub type _NV_GPU_CLIENT_UTIL_DOMAIN_ID = ::std::os::raw::c_int;
#[doc = " Enumeration of different utilization domains"]
pub use self::_NV_GPU_CLIENT_UTIL_DOMAIN_ID as NV_GPU_CLIENT_UTIL_DOMAIN_ID;
#[doc = " Data specific to a single utilization domain."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_UTILIZATION_DATA_V1 {
    #[doc = " [out] Utilization domain identifier."]
    pub utilId: NV_GPU_CLIENT_UTIL_DOMAIN_ID,
    #[doc = " [out] Percentage of time where the domain is considered busy since the"]
    #[doc = " last sample. Units of percent*100; i.e. 5000 = 50%."]
    pub utilizationPercent: NvU32,
    #[doc = " Reserved bytes for future expansion."]
    pub rsvd: [NvU8; 61usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_UTILIZATION_DATA_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_UTILIZATION_DATA_V1>(),
        72usize,
        concat!("Size of: ", stringify!(_NV_GPU_CLIENT_UTILIZATION_DATA_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_UTILIZATION_DATA_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_UTILIZATION_DATA_V1)
        )
    );
    fn test_field_utilId() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_UTILIZATION_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).utilId) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_UTILIZATION_DATA_V1),
                "::",
                stringify!(utilId)
            )
        );
    }
    test_field_utilId();
    fn test_field_utilizationPercent() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_UTILIZATION_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).utilizationPercent) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_UTILIZATION_DATA_V1),
                "::",
                stringify!(utilizationPercent)
            )
        );
    }
    test_field_utilizationPercent();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_UTILIZATION_DATA_V1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_UTILIZATION_DATA_V1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_GPU_CLIENT_UTILIZATION_DATA_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Data specific to a single utilization domain."]
pub type NV_GPU_CLIENT_UTILIZATION_DATA_V1 = _NV_GPU_CLIENT_UTILIZATION_DATA_V1;
#[doc = " Data passed back to callback registered with"]
#[doc = " @ref NvAPI_GPU_ClientRegisterForUtilizationSampleUpdates."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1 {
    #[doc = " [out] Super struct."]
    pub super_: NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1,
    #[doc = " [out] Number of valid entries in `utils` array."]
    pub numUtils: NvU32,
    #[doc = " [out] Time at which data was collected. Represented as elapsed"]
    #[doc = " microseconds since 00:00:00 UTC on January 1, 1970."]
    pub timestamp: NvU64,
    #[doc = " Reserved bytes for future expansion."]
    pub rsvd: [NvU8; 64usize],
    #[doc = " [out] Status data for each utilization domain."]
    pub utils: [NV_GPU_CLIENT_UTILIZATION_DATA_V1; 4usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1>(),
        440usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1)
        )
    );
    fn test_field_super() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).super_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1),
                "::",
                stringify!(super_)
            )
        );
    }
    test_field_super();
    fn test_field_numUtils() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numUtils) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1),
                "::",
                stringify!(numUtils)
            )
        );
    }
    test_field_numUtils();
    fn test_field_timestamp() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1),
                "::",
                stringify!(timestamp)
            )
        );
    }
    test_field_timestamp();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
    fn test_field_utils() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).utils) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1),
                "::",
                stringify!(utils)
            )
        );
    }
    test_field_utils();
}
impl Default for _NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Data passed back to callback registered with"]
#[doc = " @ref NvAPI_GPU_ClientRegisterForUtilizationSampleUpdates."]
pub type NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1 = _NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1;
#[doc = " Function prototype for a periodic utilization data callback that will be registered with NvAPI."]
pub type NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_V1 = ::std::option::Option<
    unsafe extern "C" fn(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pData: *mut NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1,
    ),
>;
#[doc = " Data required to register a periodic callback for utilization data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1 {
    #[doc = " [in] Structure Version, must always be first."]
    pub version: NvU32,
    #[doc = " [in] Generic callback settings. Some data within will be passed to the"]
    #[doc = " callback when invoked."]
    pub super_: NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1,
    #[doc = " [in] Callback. Pass in NULL or nullptr to indicate request to unregister."]
    pub callback: NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_V1,
    #[doc = " Reserved bytes for future expansion."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1() {
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1>(),
        224usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1)
        )
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_super() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).super_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1),
                "::",
                stringify!(super_)
            )
        );
    }
    test_field_super();
    fn test_field_callback() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1),
                "::",
                stringify!(callback)
            )
        );
    }
    test_field_callback();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    _NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
}
impl Default for _NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Data required to register a periodic callback for utilization data."]
pub type NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1 =
    _NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1;
#[doc = " Data required to register a periodic callback for utilization data."]
pub type NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS =
    NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1;
extern "C" {
    #[doc = "! \\fn NvAPI_GPU_ClientRegisterForUtilizationSampleUpdates()"]
    #[doc = "! \\code"]
    #[doc = "!   DESCRIPTION: Register to receive samples of utilization data periodically"]
    #[doc = "!                via a function pointer callback."]
    #[doc = "!"]
    #[doc = "! SUPPORTED OS:  Windows 10 and higher"]
    #[doc = "!"]
    #[doc = "!"]
    #[doc = "! \\since Release 455"]
    #[doc = "!"]
    #[doc = "! \\return        NVAPI_OK                          - Registration was successful"]
    #[doc = "!                NVAPI_API_NOT_INITIALIZED         - NVAPI not initialized"]
    #[doc = "!                NVAPI_INCOMPATIBLE_STRUCT_VERSION - Invalid structure version specified"]
    #[doc = "!                NVAPI_INVALID_CONFIGURATION       - Invalid software environment configuration"]
    #[doc = "!                NVAPI_TIMEOUT                     - Registration request timed out"]
    #[doc = "!                NVAPI_ERROR                       - Unknown underlying error"]
    #[doc = "!"]
    #[doc = "! \\endcode"]
    #[doc = "! \\ingroup nvtopps"]
    #[doc = ""]
    pub fn NvAPI_GPU_ClientRegisterForUtilizationSampleUpdates(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pCallbackSettings: *mut NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS,
    ) -> NvAPI_Status;
}
